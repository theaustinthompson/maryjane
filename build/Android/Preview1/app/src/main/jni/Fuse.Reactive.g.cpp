// This file was generated based on '(multiple files)'.
// WARNING: Changes might be lost if you edit this file directly.

#include <Fuse.Binding.h>
#include <Fuse.DeferredManager.h>
#include <Fuse.Diagnostics.h>
#include <Fuse.IArray.h>
#include <Fuse.Internal.ObjectL-a57e6857.h>
#include <Fuse.Internal.ObjectList-1.h>
#include <Fuse.IObject.h>
#include <Fuse.ITemplateSource.h>
#include <Fuse.Json.h>
#include <Fuse.LayoutPriority.h>
#include <Fuse.Marshal.h>
#include <Fuse.MarshalException.h>
#include <Fuse.NameRegistry.h>
#include <Fuse.NameValuePair.h>
#include <Fuse.Node.ContextDataResult.h>
#include <Fuse.Node.DataType.h>
#include <Fuse.Node.h>
#include <Fuse.Node.NodeDataSubscription.h>
#include <Fuse.Platform.SystemUI.h>
#include <Fuse.Properties.h>
#include <Fuse.PropertyHandle.h>
#include <Fuse.Reactive.Abs.h>
#include <Fuse.Reactive.Acos.h>
#include <Fuse.Reactive.Add.h>
#include <Fuse.Reactive.Alternate.h>
#include <Fuse.Reactive.Array.h>
#include <Fuse.Reactive.ArrayObject.h>
#include <Fuse.Reactive.Asin.h>
#include <Fuse.Reactive.Atan.h>
#include <Fuse.Reactive.Atan2.h>
#include <Fuse.Reactive.AtanVector.h>
#include <Fuse.Reactive.BinaryF-177abc0d.h>
#include <Fuse.Reactive.BinaryF-f494d274.h>
#include <Fuse.Reactive.BinaryOperator.h>
#include <Fuse.Reactive.BindingMode.h>
#include <Fuse.Reactive.CapsObj-14c0d77e.h>
#include <Fuse.Reactive.CapsObject.h>
#include <Fuse.Reactive.Case.h>
#include <Fuse.Reactive.Ceil.h>
#include <Fuse.Reactive.Clamp.h>
#include <Fuse.Reactive.Closure.h>
#include <Fuse.Reactive.ClosureArgs.h>
#include <Fuse.Reactive.ClosureHandler.h>
#include <Fuse.Reactive.Compute-2d5dc615.h>
#include <Fuse.Reactive.Compute-37d95ed4.h>
#include <Fuse.Reactive.Compute-7b0008a8.h>
#include <Fuse.Reactive.Concat.h>
#include <Fuse.Reactive.Conditional.h>
#include <Fuse.Reactive.Console.h>
#include <Fuse.Reactive.Constan-264ec80.h>
#include <Fuse.Reactive.Constant.h>
#include <Fuse.Reactive.Cos.h>
#include <Fuse.Reactive.Data.h>
#include <Fuse.Reactive.DataBinding.h>
#include <Fuse.Reactive.DataFun-b1d67e21.h>
#include <Fuse.Reactive.DataFunction.h>
#include <Fuse.Reactive.DataSubscription.h>
#include <Fuse.Reactive.DataToR-16f9ac8f.h>
#include <Fuse.Reactive.DataToResource.h>
#include <Fuse.Reactive.DebugLog.h>
#include <Fuse.Reactive.DegreesToRadians.h>
#include <Fuse.Reactive.DeviceCaps.h>
#include <Fuse.Reactive.Divide.h>
#include <Fuse.Reactive.Each.h>
#include <Fuse.Reactive.Equal.h>
#include <Fuse.Reactive.Even.h>
#include <Fuse.Reactive.EventBinding.h>
#include <Fuse.Reactive.EventRecord.h>
#include <Fuse.Reactive.Exp.h>
#include <Fuse.Reactive.Exp2.h>
#include <Fuse.Reactive.Express-2cf41af6.h>
#include <Fuse.Reactive.Express-46994d37.h>
#include <Fuse.Reactive.Express-6b713f70.h>
#include <Fuse.Reactive.Express-bdb0a595.h>
#include <Fuse.Reactive.Express-ee33104d.h>
#include <Fuse.Reactive.Expression.h>
#include <Fuse.Reactive.Floor.h>
#include <Fuse.Reactive.Fract.h>
#include <Fuse.Reactive.GreaterOrEqual.h>
#include <Fuse.Reactive.GreaterThan.h>
#include <Fuse.Reactive.IContext.h>
#include <Fuse.Reactive.IEventHandler.h>
#include <Fuse.Reactive.IEventRecord.h>
#include <Fuse.Reactive.IExpression.h>
#include <Fuse.Reactive.IListener.h>
#include <Fuse.Reactive.IndexFunction.h>
#include <Fuse.Reactive.InfixOperator.h>
#include <Fuse.Reactive.InnerLi-d480603c.h>
#include <Fuse.Reactive.InnerListener.h>
#include <Fuse.Reactive.Instance.h>
#include <Fuse.Reactive.InstanceDefaults.h>
#include <Fuse.Reactive.InstanceDefer.h>
#include <Fuse.Reactive.InstanceIdentity.h>
#include <Fuse.Reactive.InstanceReuse.h>
#include <Fuse.Reactive.Instant-2359146.h>
#include <Fuse.Reactive.Instant-28638d5d.h>
#include <Fuse.Reactive.Instant-75b959b5.h>
#include <Fuse.Reactive.Instantiator.h>
#include <Fuse.Reactive.Interna-2d54a663.h>
#include <Fuse.Reactive.Interna-5501e448.h>
#include <Fuse.Reactive.Interna-d7d4e77c.h>
#include <Fuse.Reactive.Internal.PatchOp.h>
#include <Fuse.Reactive.IObserv-45c40f03.h>
#include <Fuse.Reactive.IObservable.h>
#include <Fuse.Reactive.IObservableArray.h>
#include <Fuse.Reactive.IObserver.h>
#include <Fuse.Reactive.IProper-5c136cab.h>
#include <Fuse.Reactive.IProper-fa34e162.h>
#include <Fuse.Reactive.IsAndro-6431d4fd.h>
#include <Fuse.Reactive.IsDefined.h>
#include <Fuse.Reactive.IsDeskt-39804416.h>
#include <Fuse.Reactive.IsIOSFunction.h>
#include <Fuse.Reactive.IsMobileFunction.h>
#include <Fuse.Reactive.IsNull.h>
#include <Fuse.Reactive.IsOSXFunction.h>
#include <Fuse.Reactive.ISubscription.h>
#include <Fuse.Reactive.IsWindo-55989659.h>
#include <Fuse.Reactive.ItemsWi-215702d0.h>
#include <Fuse.Reactive.ItemsWi-e7592013.h>
#include <Fuse.Reactive.IWriteable.h>
#include <Fuse.Reactive.JavaScr-6ae501cc.h>
#include <Fuse.Reactive.JavaScript.h>
#include <Fuse.Reactive.Lerp.h>
#include <Fuse.Reactive.LessOrEqual.h>
#include <Fuse.Reactive.LessThan.h>
#include <Fuse.Reactive.Let.h>
#include <Fuse.Reactive.LetBase.h>
#include <Fuse.Reactive.LetBool.h>
#include <Fuse.Reactive.LetFloat.h>
#include <Fuse.Reactive.LetFloat2.h>
#include <Fuse.Reactive.LetFloat3.h>
#include <Fuse.Reactive.LetFloat4.h>
#include <Fuse.Reactive.LetObse-59fda1bf.h>
#include <Fuse.Reactive.LetObservable.h>
#include <Fuse.Reactive.LetSize.h>
#include <Fuse.Reactive.LetSize2.h>
#include <Fuse.Reactive.LetString.h>
#include <Fuse.Reactive.LetType-1.h>
#include <Fuse.Reactive.Log.h>
#include <Fuse.Reactive.Log2.h>
#include <Fuse.Reactive.LogicalAnd.h>
#include <Fuse.Reactive.LogicalNot.h>
#include <Fuse.Reactive.LogicalOr.h>
#include <Fuse.Reactive.LookUp.-f2be5323.h>
#include <Fuse.Reactive.LookUp.h>
#include <Fuse.Reactive.Match.h>
#include <Fuse.Reactive.Max.h>
#include <Fuse.Reactive.Member.-80cd0e57.h>
#include <Fuse.Reactive.Member.h>
#include <Fuse.Reactive.Min.h>
#include <Fuse.Reactive.Mod.h>
#include <Fuse.Reactive.Multiply.h>
#include <Fuse.Reactive.NamedFu-cc08ec09.h>
#include <Fuse.Reactive.NameValuePair.h>
#include <Fuse.Reactive.Negate.h>
#include <Fuse.Reactive.NodeExp-869eb6a1.h>
#include <Fuse.Reactive.NonNull.h>
#include <Fuse.Reactive.NotEqual.h>
#include <Fuse.Reactive.NullCoalesce.h>
#include <Fuse.Reactive.Object.h>
#include <Fuse.Reactive.ObserverMap-1.h>
#include <Fuse.Reactive.Odd.h>
#include <Fuse.Reactive.OffsetI-b46b8d5b.h>
#include <Fuse.Reactive.Paramet-3c258f00.h>
#include <Fuse.Reactive.Parameter.h>
#include <Fuse.Reactive.Platfor-dd4a5534.h>
#include <Fuse.Reactive.PlatformFunction.h>
#include <Fuse.Reactive.Pow.h>
#include <Fuse.Reactive.Propert-3b65e5e6.h>
#include <Fuse.Reactive.Property.h>
#include <Fuse.Reactive.PropertyBinding.h>
#include <Fuse.Reactive.Quatern-4692c3b2.h>
#include <Fuse.Reactive.RadiansToDegrees.h>
#include <Fuse.Reactive.Resourc-a4dc08c7.h>
#include <Fuse.Reactive.Resource.h>
#include <Fuse.Reactive.ResourceBinding.h>
#include <Fuse.Reactive.Round.h>
#include <Fuse.Reactive.Select.h>
#include <Fuse.Reactive.Sign.h>
#include <Fuse.Reactive.SimpleV-1e1b52a3.h>
#include <Fuse.Reactive.SimpleV-737a24c.h>
#include <Fuse.Reactive.Sin.h>
#include <Fuse.Reactive.Snapsho-9e1b433f.h>
#include <Fuse.Reactive.Snapshot.h>
#include <Fuse.Reactive.Sqrt.h>
#include <Fuse.Reactive.Subtract.h>
#include <Fuse.Reactive.Tan.h>
#include <Fuse.Reactive.TemplateMatch.h>
#include <Fuse.Reactive.TernaryOperator.h>
#include <Fuse.Reactive.ToFloat.h>
#include <Fuse.Reactive.ToLower.h>
#include <Fuse.Reactive.ToSize.h>
#include <Fuse.Reactive.ToString.h>
#include <Fuse.Reactive.ToUpper.h>
#include <Fuse.Reactive.Trunc.h>
#include <Fuse.Reactive.UnaryFl-1bdb1fc6.h>
#include <Fuse.Reactive.UnaryFl-dfc153fb.h>
#include <Fuse.Reactive.UnaryOperator.h>
#include <Fuse.Reactive.UnmappedView-1.h>
#include <Fuse.Reactive.ValueFo-a26c06f.h>
#include <Fuse.Reactive.ValueForwarder.h>
#include <Fuse.Reactive.ValueObserver.h>
#include <Fuse.Reactive.VarArgF-cd333e8.h>
#include <Fuse.Reactive.VarArgFunction.h>
#include <Fuse.Reactive.Vector.h>
#include <Fuse.Reactive.VectorW.h>
#include <Fuse.Reactive.VectorZ.h>
#include <Fuse.Reactive.WhileCount.h>
#include <Fuse.Reactive.WhileCount.Range.h>
#include <Fuse.Reactive.WhileEmpty.h>
#include <Fuse.Reactive.WhileNotEmpty.h>
#include <Fuse.Reactive.WindowCaps.h>
#include <Fuse.Reactive.WindowF-2ad7cf81.h>
#include <Fuse.Reactive.WindowFunction.h>
#include <Fuse.Reactive.WindowItem.h>
#include <Fuse.Reactive.WindowL-23794a38.h>
#include <Fuse.Reactive.WindowList-1.h>
#include <Fuse.Reactive.WindowListItem.h>
#include <Fuse.Reactive.With.h>
#include <Fuse.Resources.Resour-fabdcc8b.h>
#include <Fuse.RootViewport.h>
#include <Fuse.Scripting.AppInitialized.h>
#include <Fuse.Scripting.Array.h>
#include <Fuse.Scripting.Callback.h>
#include <Fuse.Scripting.Context.h>
#include <Fuse.Scripting.Function.h>
#include <Fuse.Scripting.IEvent-434826af.h>
#include <Fuse.Scripting.IScriptEvent.h>
#include <Fuse.Scripting.IThreadWorker.h>
#include <Fuse.Scripting.JavaSc-4716ab56.h>
#include <Fuse.Scripting.JavaSc-523a45a7.h>
#include <Fuse.Scripting.JavaSc-c105a89e.h>
#include <Fuse.Scripting.JavaSc-d44b1a66.h>
#include <Fuse.Scripting.Module.h>
#include <Fuse.Scripting.NativeModule.h>
#include <Fuse.Scripting.Object.h>
#include <Fuse.Scripting.ScriptModule.h>
#include <Fuse.Scripting.ValueMirror.h>
#include <Fuse.Triggers.BusyTask.h>
#include <Fuse.Triggers.BusyTaskActivity.h>
#include <Fuse.Triggers.Trigger.h>
#include <Fuse.UpdateManager.h>
#include <Fuse.UpdateStage.h>
#include <Fuse.Visual.h>
#include <Uno.Action.h>
#include <Uno.Action1-1.h>
#include <Uno.Bool.h>
#include <Uno.Collections.Dicti-87d2e37d.h>
#include <Uno.Collections.Dicti-98f6bc43.h>
#include <Uno.Collections.Dicti-d1699346.h>
#include <Uno.Collections.Dicti-d6e3a7c5.h>
#include <Uno.Collections.Dictionary-2.h>
#include <Uno.Collections.Enume-8ddd045.h>
#include <Uno.Collections.ICollection-1.h>
#include <Uno.Collections.IEnumerable-1.h>
#include <Uno.Collections.IEnumerator.h>
#include <Uno.Collections.IEnumerator1-1.h>
#include <Uno.Collections.IList-1.h>
#include <Uno.Collections.KeyValuePair-2.h>
#include <Uno.Collections.List-1.h>
#include <Uno.Collections.List--251bdc7d.h>
#include <Uno.Collections.RootableList-1.h>
#include <Uno.Delegate.h>
#include <Uno.Diagnostics.Debug.h>
#include <Uno.Diagnostics.Debug-5d778620.h>
#include <Uno.Double.h>
#include <Uno.EventArgs.h>
#include <Uno.EventHandler.h>
#include <Uno.Exception.h>
#include <Uno.Float.h>
#include <Uno.Float2.h>
#include <Uno.Float3.h>
#include <Uno.Float4.h>
#include <Uno.IDisposable.h>
#include <Uno.IndexOutOfRangeException.h>
#include <Uno.Int.h>
#include <Uno.Int3.h>
#include <Uno.Math.h>
#include <Uno.Object.h>
#include <Uno.Predicate-1.h>
#include <Uno.String.h>
#include <Uno.Text.StringBuilder.h>
#include <Uno.Type.h>
#include <Uno.UX.FileSource.h>
#include <Uno.UX.IPropertyListener.h>
#include <Uno.UX.NameTable.h>
#include <Uno.UX.Property.h>
#include <Uno.UX.PropertyAccessor.h>
#include <Uno.UX.PropertyObject.h>
#include <Uno.UX.Resource.h>
#include <Uno.UX.Selector.h>
#include <Uno.UX.Size.h>
#include <Uno.UX.Size2.h>
#include <Uno.UX.Template.h>
static uString* STRINGS[171];
static uType* TYPES[71];

namespace g{
namespace Fuse{
namespace Reactive{

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Abs :287
// {
static void Abs_build(uType* type)
{
    ::STRINGS[0] = uString::Const("abs");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Abs__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Abs_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Abs);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Abs", options);
    type->fp_build_ = Abs_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Abs(Fuse.Reactive.Expression operand) :290
void Abs__ctor_5_fn(Abs* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Abs New(Fuse.Reactive.Expression operand) :290
void Abs__New1_fn(::g::Fuse::Reactive::Expression* operand, Abs** __retval)
{
    *__retval = Abs::New1(operand);
}

// public Abs(Fuse.Reactive.Expression operand) [instance] :290
void Abs::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[0/*"abs"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Abs_fn));
}

// public Abs New(Fuse.Reactive.Expression operand) [static] :290
Abs* Abs::New1(::g::Fuse::Reactive::Expression* operand)
{
    Abs* obj1 = (Abs*)uNew(Abs_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Acos :231
// {
static void Acos_build(uType* type)
{
    ::STRINGS[1] = uString::Const("acos");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Acos__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Acos_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Acos);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Acos", options);
    type->fp_build_ = Acos_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Acos(Fuse.Reactive.Expression operand) :234
void Acos__ctor_5_fn(Acos* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Acos New(Fuse.Reactive.Expression operand) :234
void Acos__New1_fn(::g::Fuse::Reactive::Expression* operand, Acos** __retval)
{
    *__retval = Acos::New1(operand);
}

// public Acos(Fuse.Reactive.Expression operand) [instance] :234
void Acos::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[1/*"acos"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Acos_fn));
}

// public Acos New(Fuse.Reactive.Expression operand) [static] :234
Acos* Acos::New1(::g::Fuse::Reactive::Expression* operand)
{
    Acos* obj1 = (Acos*)uNew(Acos_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class Add :49
// {
static void Add_build(uType* type)
{
    ::STRINGS[2] = uString::Const("+");
    ::TYPES[1] = ::g::Uno::String_typeof();
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Add__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* Add_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InfixOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(Add);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.Add", options);
    type->fp_build_ = Add_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))Add__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Add(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :52
void Add__ctor_6_fn(Add* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_6(left, right);
}

// public Add New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :52
void Add__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, Add** __retval)
{
    *__retval = Add::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :54
void Add__TryCompute1_fn(Add* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    if (uIs(left, ::TYPES[1/*string*/]) || uIs(right, ::TYPES[1/*string*/]))
        return *__retval = ::g::Fuse::Reactive::Concat::TryComputeImpl(left, right, result), void();

    return *__retval = ::g::Fuse::Marshal::TryAdd(left, right, result), void();
}

// public Add(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :52
void Add::ctor_6(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    ctor_5(left, right, ::STRINGS[2/*"+"*/], 0);
}

// public Add New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :52
Add* Add::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    Add* obj1 = (Add*)uNew(Add_typeof());
    obj1->ctor_6(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Alternate :98
// {
static void Alternate_build(uType* type)
{
    ::STRINGS[3] = uString::Const("alternate");
    ::TYPES[2] = ::g::Fuse::Marshal_typeof()->MakeMethod(1/*TryToType<float>*/, ::g::Uno::Float_typeof(), NULL);
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Alternate__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* Alternate_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::BinaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Alternate);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.Alternate", options);
    type->fp_build_ = Alternate_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))Alternate__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Alternate(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :101
void Alternate__ctor_4_fn(Alternate* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_4(left, right);
}

// public Alternate New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :101
void Alternate__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, Alternate** __retval)
{
    *__retval = Alternate::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :104
void Alternate__TryCompute1_fn(Alternate* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.Alternate", "TryCompute(object,object,object&)");
    bool ret2;
    bool ret3;
    *result = NULL;
    float fvalue = 0.0f;
    float fgroup = 0.0f;

    if (!(::g::Fuse::Marshal__TryToType_fn(::TYPES[2/*Fuse.Marshal.TryToType<float>*/], left, &fvalue, &ret2), ret2) || !(::g::Fuse::Marshal__TryToType_fn(::TYPES[2/*Fuse.Marshal.TryToType<float>*/], right, &fgroup, &ret3), ret3))
        return *__retval = false, void();

    int32_t value = (int32_t)::g::Uno::Math::Round2(fvalue);
    int32_t group = (int32_t)::g::Uno::Math::Round2(fgroup);
    bool b = (value >= 0) ? (value % (group * 2)) < group : (-(value + 1) % (group * 2)) >= group;
    *result = uBox(::TYPES[12/*bool*/], b);
    return *__retval = true, void();
}

// public Alternate(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :101
void Alternate::ctor_4(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    ctor_3(left, right, ::STRINGS[3/*"alternate"*/], 0);
}

// public Alternate New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :101
Alternate* Alternate::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    Alternate* obj1 = (Alternate*)uNew(Alternate_typeof());
    obj1->ctor_4(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Expression.uno
// --------------------------------------------------------------------------------------------------

// public sealed class Expression.Argument :14
// {
static void Expression__Argument_build(uType* type)
{
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    type->SetFields(0,
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(Expression__Argument, Source), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(Expression__Argument, Subscription), 0,
        ::g::Uno::Bool_typeof(), offsetof(Expression__Argument, _HasValue), 0,
        uObject_typeof(), offsetof(Expression__Argument, _Value), 0);
    type->Reflection.SetFunctions(3,
        new uFunction("get_HasValue", NULL, (void*)Expression__Argument__get_HasValue_fn, 0, false, ::g::Uno::Bool_typeof(), 0),
        new uFunction(".ctor", NULL, (void*)Expression__Argument__New1_fn, 0, true, type, 0),
        new uFunction("get_Value", NULL, (void*)Expression__Argument__get_Value_fn, 0, false, uObject_typeof(), 0));
}

uType* Expression__Argument_typeof()
{
    static uSStrong<uType*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 4;
    options.ObjectSize = sizeof(Expression__Argument);
    options.TypeSize = sizeof(uType);
    type = uClassType::New("Fuse.Reactive.Expression.Argument", options);
    type->fp_build_ = Expression__Argument_build;
    type->fp_ctor_ = (void*)Expression__Argument__New1_fn;
    return type;
}

// public generated Argument() :14
void Expression__Argument__ctor__fn(Expression__Argument* __this)
{
    __this->ctor_();
}

// internal void Dispose() :27
void Expression__Argument__Dispose_fn(Expression__Argument* __this)
{
    __this->Dispose();
}

// public generated bool get_HasValue() :25
void Expression__Argument__get_HasValue_fn(Expression__Argument* __this, bool* __retval)
{
    *__retval = __this->HasValue();
}

// internal generated void set_HasValue(bool value) :25
void Expression__Argument__set_HasValue_fn(Expression__Argument* __this, bool* value)
{
    __this->HasValue(*value);
}

// public generated Argument New() :14
void Expression__Argument__New1_fn(Expression__Argument** __retval)
{
    *__retval = Expression__Argument::New1();
}

// public generated object get_Value() :20
void Expression__Argument__get_Value_fn(Expression__Argument* __this, uObject** __retval)
{
    *__retval = __this->Value();
}

// internal generated void set_Value(object value) :20
void Expression__Argument__set_Value_fn(Expression__Argument* __this, uObject* value)
{
    __this->Value(value);
}

// public generated Argument() [instance] :14
void Expression__Argument::ctor_()
{
}

// internal void Dispose() [instance] :27
void Expression__Argument::Dispose()
{
    uStackFrame __("Fuse.Reactive.Expression.Argument", "Dispose()");

    if (Subscription != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(Subscription), ::TYPES[3/*Uno.IDisposable*/]));
        Subscription = NULL;
    }

    Value(NULL);
    HasValue(false);
}

// public generated bool get_HasValue() [instance] :25
bool Expression__Argument::HasValue()
{
    return _HasValue;
}

// internal generated void set_HasValue(bool value) [instance] :25
void Expression__Argument::HasValue(bool value)
{
    _HasValue = value;
}

// public generated object get_Value() [instance] :20
uObject* Expression__Argument::Value()
{
    return _Value;
}

// internal generated void set_Value(object value) [instance] :20
void Expression__Argument::Value(uObject* value)
{
    _Value = value;
}

// public generated Argument New() [static] :14
Expression__Argument* Expression__Argument::New1()
{
    Expression__Argument* obj1 = (Expression__Argument*)uNew(Expression__Argument_typeof());
    obj1->ctor_();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\VectorFunctions.uno
// -------------------------------------------------------------------------------------------------------

// internal class Array :24
// {
static void Array_build(uType* type)
{
    ::STRINGS[4] = uString::Const("(");
    ::STRINGS[5] = uString::Const(", ");
    ::STRINGS[6] = uString::Const(")");
    ::TYPES[4] = uObject_typeof()->Array();
    type->SetInterfaces(
        ::g::Fuse::IArray_typeof(), offsetof(Array_type, interface0));
    type->SetFields(0,
        ::TYPES[4/*object[]*/], offsetof(Array, _items), 0);
}

Array_type* Array_typeof()
{
    static uSStrong<Array_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Array);
    options.TypeSize = sizeof(Array_type);
    type = (Array_type*)uClassType::New("Fuse.Reactive.Array", options);
    type->fp_build_ = Array_build;
    type->fp_ToString = (void(*)(uObject*, uString**))Array__ToString_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uObject**))Array__FuseIArrayget_Item_fn;
    type->interface0.fp_get_Length = (void(*)(uObject*, int32_t*))Array__FuseIArrayget_Length_fn;
    return type;
}

// public Array(Fuse.Reactive.Expression.Argument[] args) :27
void Array__ctor__fn(Array* __this, uArray* args)
{
    __this->ctor_(args);
}

// private object Fuse.IArray.get_Item(int index) :33
void Array__FuseIArrayget_Item_fn(Array* __this, int32_t* index, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.Array", "Fuse.IArray.get_Item(int)");
    int32_t index_ = *index;
    return *__retval = uPtr(__this->_items)->Strong<uObject*>(index_), void();
}

// private int Fuse.IArray.get_Length() :34
void Array__FuseIArrayget_Length_fn(Array* __this, int32_t* __retval)
{
    uStackFrame __("Fuse.Reactive.Array", "Fuse.IArray.get_Length()");
    return *__retval = uPtr(__this->_items)->Length(), void();
}

// public Array New(Fuse.Reactive.Expression.Argument[] args) :27
void Array__New1_fn(uArray* args, Array** __retval)
{
    *__retval = Array::New1(args);
}

// public override sealed string ToString() :36
void Array__ToString_fn(Array* __this, uString** __retval)
{
    uStackFrame __("Fuse.Reactive.Array", "ToString()");
    ::g::Uno::Text::StringBuilder* sb = ::g::Uno::Text::StringBuilder::New1();
    sb->Append2(::STRINGS[4/*"("*/]);

    for (int32_t i = 0; i < uPtr(__this->_items)->Length(); i++)
    {
        if (i > 0)
            uPtr(sb)->Append2(::STRINGS[5/*", "*/]);

        uPtr(sb)->Append2(::g::Uno::Object::ToString(uPtr(uPtr(__this->_items)->Strong<uObject*>(i))));
    }

    sb->Append2(::STRINGS[6/*")"*/]);
    return *__retval = sb->ToString(), void();
}

// public Array(Fuse.Reactive.Expression.Argument[] args) [instance] :27
void Array::ctor_(uArray* args)
{
    uStackFrame __("Fuse.Reactive.Array", ".ctor(Fuse.Reactive.Expression.Argument[])");
    _items = uArray::New(::TYPES[4/*object[]*/], uPtr(args)->Length());

    for (int32_t i = 0; i < args->Length(); i++)
        uPtr(_items)->Strong<uObject*>(i) = uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->Value();
}

// public Array New(Fuse.Reactive.Expression.Argument[] args) [static] :27
Array* Array::New1(uArray* args)
{
    Array* obj1 = (Array*)uNew(Array_typeof());
    obj1->ctor_(args);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Object.uno
// ----------------------------------------------------------------------------------------------

// internal sealed class ArrayObject :24
// {
static void ArrayObject_build(uType* type)
{
    ::TYPES[5] = ::g::Uno::Collections::Dictionary_typeof()->MakeType(::g::Uno::String_typeof(), uObject_typeof(), NULL);
    ::TYPES[6] = ::g::Fuse::NameValuePair_typeof();
    ::TYPES[7] = ::g::Uno::Collections::EnumerableExtensions_typeof()->MakeMethod(8/*ToArray<string>*/, ::g::Uno::String_typeof(), NULL);
    type->SetInterfaces(
        ::g::Fuse::IArray_typeof(), offsetof(ArrayObject_type, interface0),
        ::g::Fuse::IObject_typeof(), offsetof(ArrayObject_type, interface1));
    type->SetFields(1,
        ::TYPES[5/*Uno.Collections.Dictionary<string, object>*/], offsetof(ArrayObject, _dict), 0);
}

ArrayObject_type* ArrayObject_typeof()
{
    static uSStrong<ArrayObject_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Array_typeof();
    options.FieldCount = 2;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(ArrayObject);
    options.TypeSize = sizeof(ArrayObject_type);
    type = (ArrayObject_type*)uClassType::New("Fuse.Reactive.ArrayObject", options);
    type->fp_build_ = ArrayObject_build;
    type->interface1.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))ArrayObject__FuseIObjectContainsKey_fn;
    type->interface1.fp_get_Item = (void(*)(uObject*, uString*, uObject**))ArrayObject__FuseIObjectget_Item_fn;
    type->interface1.fp_get_Keys = (void(*)(uObject*, uArray**))ArrayObject__FuseIObjectget_Keys_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uObject**))::g::Fuse::Reactive::Array__FuseIArrayget_Item_fn;
    type->interface0.fp_get_Length = (void(*)(uObject*, int32_t*))::g::Fuse::Reactive::Array__FuseIArrayget_Length_fn;
    return type;
}

// public ArrayObject(Fuse.Reactive.Expression.Argument[] args) :28
void ArrayObject__ctor_1_fn(ArrayObject* __this, uArray* args)
{
    __this->ctor_1(args);
}

// private bool Fuse.IObject.ContainsKey(string key) :38
void ArrayObject__FuseIObjectContainsKey_fn(ArrayObject* __this, uString* key, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.ArrayObject", "Fuse.IObject.ContainsKey(string)");
    bool ret2;
    return *__retval = (::g::Uno::Collections::Dictionary__ContainsKey_fn(uPtr(__this->_dict), key, &ret2), ret2), void();
}

// private object Fuse.IObject.get_Item(string key) :45
void ArrayObject__FuseIObjectget_Item_fn(ArrayObject* __this, uString* key, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.ArrayObject", "Fuse.IObject.get_Item(string)");
    uObject* ret3;
    return *__retval = (::g::Uno::Collections::Dictionary__get_Item_fn(uPtr(__this->_dict), key, &ret3), ret3), void();
}

// private string[] Fuse.IObject.get_Keys() :50
void ArrayObject__FuseIObjectget_Keys_fn(ArrayObject* __this, uArray** __retval)
{
    uStackFrame __("Fuse.Reactive.ArrayObject", "Fuse.IObject.get_Keys()");
    return *__retval = (uArray*)::g::Uno::Collections::EnumerableExtensions::ToArray(::TYPES[7/*Uno.Collections.EnumerableExtensions.ToArray<string>*/], (uObject*)((::g::Uno::Collections::Dictionary__KeyCollection*)uPtr(__this->_dict)->Keys())), void();
}

// public ArrayObject New(Fuse.Reactive.Expression.Argument[] args) :28
void ArrayObject__New2_fn(uArray* args, ArrayObject** __retval)
{
    *__retval = ArrayObject::New2(args);
}

// public ArrayObject(Fuse.Reactive.Expression.Argument[] args) [instance] :28
void ArrayObject::ctor_1(uArray* args)
{
    uStackFrame __("Fuse.Reactive.ArrayObject", ".ctor(Fuse.Reactive.Expression.Argument[])");
    _dict = ((::g::Uno::Collections::Dictionary*)::g::Uno::Collections::Dictionary::New1(::TYPES[5/*Uno.Collections.Dictionary<string, object>*/]));
    ctor_(args);

    for (int32_t i = 0; i < uPtr(args)->Length(); i++)
    {
        ::g::Fuse::NameValuePair* nvp = uAs< ::g::Fuse::NameValuePair*>(uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->Value(), ::TYPES[6/*Fuse.NameValuePair*/]);

        if (nvp != NULL)
            ::g::Uno::Collections::Dictionary__Add_fn(uPtr(_dict), uPtr(nvp)->Name(), uPtr(nvp)->Value());
    }
}

// public ArrayObject New(Fuse.Reactive.Expression.Argument[] args) [static] :28
ArrayObject* ArrayObject::New2(uArray* args)
{
    ArrayObject* obj1 = (ArrayObject*)uNew(ArrayObject_typeof());
    obj1->ctor_1(args);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Asin :222
// {
static void Asin_build(uType* type)
{
    ::STRINGS[7] = uString::Const("asin");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Asin__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Asin_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Asin);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Asin", options);
    type->fp_build_ = Asin_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Asin(Fuse.Reactive.Expression operand) :225
void Asin__ctor_5_fn(Asin* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Asin New(Fuse.Reactive.Expression operand) :225
void Asin__New1_fn(::g::Fuse::Reactive::Expression* operand, Asin** __retval)
{
    *__retval = Asin::New1(operand);
}

// public Asin(Fuse.Reactive.Expression operand) [instance] :225
void Asin::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[7/*"asin"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Asin_fn));
}

// public Asin New(Fuse.Reactive.Expression operand) [static] :225
Asin* Asin::New1(::g::Fuse::Reactive::Expression* operand)
{
    Asin* obj1 = (Asin*)uNew(Asin_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Atan :240
// {
static void Atan_build(uType* type)
{
    ::STRINGS[8] = uString::Const("atan");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Atan__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Atan_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Atan);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Atan", options);
    type->fp_build_ = Atan_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Atan(Fuse.Reactive.Expression operand) :243
void Atan__ctor_5_fn(Atan* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Atan New(Fuse.Reactive.Expression operand) :243
void Atan__New1_fn(::g::Fuse::Reactive::Expression* operand, Atan** __retval)
{
    *__retval = Atan::New1(operand);
}

// public Atan(Fuse.Reactive.Expression operand) [instance] :243
void Atan::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[8/*"atan"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Atan_fn));
}

// public Atan New(Fuse.Reactive.Expression operand) [static] :243
Atan* Atan::New1(::g::Fuse::Reactive::Expression* operand)
{
    Atan* obj1 = (Atan*)uNew(Atan_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Atan2 :253
// {
static void Atan2_build(uType* type)
{
    ::STRINGS[9] = uString::Const("atan2");
    ::TYPES[8] = ::g::Fuse::Reactive::BinaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Atan2__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* Atan2_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::BinaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Atan2);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.Atan2", options);
    type->fp_build_ = Atan2_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Atan2(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :256
void Atan2__ctor_5_fn(Atan2* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_5(left, right);
}

// public Atan2 New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :256
void Atan2__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, Atan2** __retval)
{
    *__retval = Atan2::New1(left, right);
}

// public Atan2(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :256
void Atan2::ctor_5(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    ctor_4(left, right, ::STRINGS[9/*"atan2"*/], uDelegate::New(::TYPES[8/*Fuse.Reactive.BinaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Atan21_fn));
}

// public Atan2 New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :256
Atan2* Atan2::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    Atan2* obj1 = (Atan2*)uNew(Atan2_typeof());
    obj1->ctor_5(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class AtanVector :266
// {
static void AtanVector_build(uType* type)
{
    ::STRINGS[10] = uString::Const("atanVector");
    ::TYPES[9] = ::g::Fuse::Marshal_typeof()->MakeMethod(1/*TryToType<float2>*/, ::g::Uno::Float2_typeof(), NULL);
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)AtanVector__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* AtanVector_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(AtanVector);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.AtanVector", options);
    type->fp_build_ = AtanVector_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::UnaryOperator*, uObject*, uObject**, bool*))AtanVector__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public AtanVector(Fuse.Reactive.Expression operand) :269
void AtanVector__ctor_4_fn(AtanVector* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_4(operand);
}

// public AtanVector New(Fuse.Reactive.Expression operand) :269
void AtanVector__New1_fn(::g::Fuse::Reactive::Expression* operand, AtanVector** __retval)
{
    *__retval = AtanVector::New1(operand);
}

// protected override sealed bool TryCompute(object operand, object& result) :273
void AtanVector__TryCompute1_fn(AtanVector* __this, uObject* operand, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.AtanVector", "TryCompute(object,object&)");
    bool ret2;
    *result = NULL;
    ::g::Uno::Float2 v = ::g::Uno::Float2__New1(0.0f);

    if (!(::g::Fuse::Marshal__TryToType_fn(::TYPES[9/*Fuse.Marshal.TryToType<float2>*/], operand, &v, &ret2), ret2))
        return *__retval = false, void();

    *result = uBox(::TYPES[21/*float*/], ::g::Uno::Math::Atan22(v.Y, v.X));
    return *__retval = true, void();
}

// public AtanVector(Fuse.Reactive.Expression operand) [instance] :269
void AtanVector::ctor_4(::g::Fuse::Reactive::Expression* operand)
{
    ctor_3(operand, ::STRINGS[10/*"atanVector"*/], 0);
}

// public AtanVector New(Fuse.Reactive.Expression operand) [static] :269
AtanVector* AtanVector::New1(::g::Fuse::Reactive::Expression* operand)
{
    AtanVector* obj1 = (AtanVector*)uNew(AtanVector_typeof());
    obj1->ctor_4(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public abstract class BinaryFloatOperator :169
// {
static void BinaryFloatOperator_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3,
        BinaryFloatOperator__FloatOp_typeof(), offsetof(BinaryFloatOperator, _op), 0);
}

::g::Fuse::Reactive::BinaryOperator_type* BinaryFloatOperator_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::BinaryOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(BinaryFloatOperator);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.BinaryFloatOperator", options);
    type->fp_build_ = BinaryFloatOperator_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))BinaryFloatOperator__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// internal BinaryFloatOperator(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right, string name, Fuse.Reactive.BinaryFloatOperator.FloatOp op) :173
void BinaryFloatOperator__ctor_4_fn(BinaryFloatOperator* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, uString* name, uDelegate* op)
{
    __this->ctor_4(left, right, name, op);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :179
void BinaryFloatOperator__TryCompute1_fn(BinaryFloatOperator* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.BinaryFloatOperator", "TryCompute(object,object,object&)");
    bool ret1;
    bool ret2;
    double ret3;
    *result = NULL;
    double lv = 0.0;
    double rv = 0.0;

    if (!(::g::Fuse::Marshal__TryToType_fn(::TYPES[48/*Fuse.Marshal*/]->MakeMethod(1/*TryToType<double>*/, ::TYPES[14/*double*/], NULL), left, &lv, &ret1), ret1) || !(::g::Fuse::Marshal__TryToType_fn(::TYPES[48/*Fuse.Marshal*/]->MakeMethod(1/*TryToType<double>*/, ::TYPES[14/*double*/], NULL), right, &rv, &ret2), ret2))
        return *__retval = false, void();

    *result = uBox(::TYPES[14/*double*/], (uPtr(__this->_op)->Invoke(&ret3, 2, uCRef(lv), uCRef(rv)), ret3));
    return *__retval = true, void();
}

// internal BinaryFloatOperator(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right, string name, Fuse.Reactive.BinaryFloatOperator.FloatOp op) [instance] :173
void BinaryFloatOperator::ctor_4(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, uString* name, uDelegate* op)
{
    ctor_3(left, right, name, 0);
    _op = op;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\BinaryOperator.uno
// ------------------------------------------------------------------------------------------------------

// public abstract class BinaryOperator :8
// {
static void BinaryOperator_build(uType* type)
{
    ::STRINGS[11] = uString::Const(" No `TryCompute`, or a deprecated form, overriden. Migrate your code to override the one with `bool` return. ");
    ::STRINGS[12] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Expressions\\1.8.1\\BinaryOperator.uno");
    ::STRINGS[13] = uString::Const("TryCompute");
    ::TYPES[10] = ::g::Fuse::Reactive::Expression_typeof()->Array();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(2,
        new uFunction("get_Left", NULL, (void*)BinaryOperator__get_Left_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0),
        new uFunction("get_Right", NULL, (void*)BinaryOperator__get_Right_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0));
}

BinaryOperator_type* BinaryOperator_typeof()
{
    static uSStrong<BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ComputeExpression_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(BinaryOperator);
    options.TypeSize = sizeof(BinaryOperator_type);
    type = (BinaryOperator_type*)uClassType::New("Fuse.Reactive.BinaryOperator", options);
    type->fp_build_ = BinaryOperator_build;
    type->fp_GetFlags = (void(*)(::g::Fuse::Reactive::ComputeExpression*, int32_t*))BinaryOperator__GetFlags_fn;
    type->fp_TryCompute = (void(*)(::g::Fuse::Reactive::ComputeExpression*, uArray*, uObject**, bool*))BinaryOperator__TryCompute_fn;
    type->fp_TryCompute1 = BinaryOperator__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// protected BinaryOperator(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right, [Fuse.Reactive.ComputeExpression.Flags flags]) :13
void BinaryOperator__ctor_2_fn(BinaryOperator* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, int32_t* flags)
{
    __this->ctor_2(left, right, *flags);
}

// protected BinaryOperator(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right, string name, [Fuse.Reactive.ComputeExpression.Flags flags]) :18
void BinaryOperator__ctor_3_fn(BinaryOperator* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, uString* name, int32_t* flags)
{
    __this->ctor_3(left, right, name, *flags);
}

// protected object Compute(object left, object right) :41
void BinaryOperator__Compute_fn(BinaryOperator* __this, uObject* left, uObject* right, uObject** __retval)
{
    *__retval = __this->Compute(left, right);
}

// internal override sealed Fuse.Reactive.ComputeExpression.Flags GetFlags() :23
void BinaryOperator__GetFlags_fn(BinaryOperator* __this, int32_t* __retval)
{
    return *__retval = (0 | (__this->IsLeftOptional() ? 1 : 0)) | (__this->IsRightOptional() ? 2 : 0), void();
}

// protected bool get_IsLeftOptional() :30
void BinaryOperator__get_IsLeftOptional_fn(BinaryOperator* __this, bool* __retval)
{
    *__retval = __this->IsLeftOptional();
}

// protected bool get_IsRightOptional() :31
void BinaryOperator__get_IsRightOptional_fn(BinaryOperator* __this, bool* __retval)
{
    *__retval = __this->IsRightOptional();
}

// public Fuse.Reactive.Expression get_Left() :10
void BinaryOperator__get_Left_fn(BinaryOperator* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->Left();
}

// public Fuse.Reactive.Expression get_Right() :11
void BinaryOperator__get_Right_fn(BinaryOperator* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->Right();
}

// protected override sealed bool TryCompute(Fuse.Reactive.Expression.Argument[] args, object& result) :43
void BinaryOperator__TryCompute_fn(BinaryOperator* __this, uArray* args, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.BinaryOperator", "TryCompute(Fuse.Reactive.Expression.Argument[],object&)");
    return *__retval = __this->TryCompute1(uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(0))->Value(), uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(1))->Value(), result), void();
}

// protected virtual bool TryCompute(object left, object right, object& result) :33
void BinaryOperator__TryCompute1_fn(BinaryOperator* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.BinaryOperator", "TryCompute(object,object,object&)");
    ::g::Fuse::Diagnostics::Deprecated(::STRINGS[11/*" No `TryCom...*/], __this, ::STRINGS[12/*"C:\\Users\\...*/], 35, ::STRINGS[13/*"TryCompute"*/]);
    *result = __this->Compute(left, right);
    return *__retval = true, void();
}

// protected BinaryOperator(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right, [Fuse.Reactive.ComputeExpression.Flags flags]) [instance] :13
void BinaryOperator::ctor_2(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, int32_t flags)
{
    uStackFrame __("Fuse.Reactive.BinaryOperator", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression,[Fuse.Reactive.ComputeExpression.Flags])");
    ctor_1(uArray::Init< ::g::Fuse::Reactive::Expression*>(::TYPES[10/*Fuse.Reactive.Expression[]*/], 2, left, right), flags, NULL);
}

// protected BinaryOperator(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right, string name, [Fuse.Reactive.ComputeExpression.Flags flags]) [instance] :18
void BinaryOperator::ctor_3(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, uString* name, int32_t flags)
{
    uStackFrame __("Fuse.Reactive.BinaryOperator", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression,string,[Fuse.Reactive.ComputeExpression.Flags])");
    ctor_1(uArray::Init< ::g::Fuse::Reactive::Expression*>(::TYPES[10/*Fuse.Reactive.Expression[]*/], 2, left, right), flags, name);
}

// protected object Compute(object left, object right) [instance] :41
uObject* BinaryOperator::Compute(uObject* left, uObject* right)
{
    return NULL;
}

// protected bool get_IsLeftOptional() [instance] :30
bool BinaryOperator::IsLeftOptional()
{
    return false;
}

// protected bool get_IsRightOptional() [instance] :31
bool BinaryOperator::IsRightOptional()
{
    return false;
}

// public Fuse.Reactive.Expression get_Left() [instance] :10
::g::Fuse::Reactive::Expression* BinaryOperator::Left()
{
    uStackFrame __("Fuse.Reactive.BinaryOperator", "get_Left()");
    return GetArgument(0);
}

// public Fuse.Reactive.Expression get_Right() [instance] :11
::g::Fuse::Reactive::Expression* BinaryOperator::Right()
{
    uStackFrame __("Fuse.Reactive.BinaryOperator", "get_Right()");
    return GetArgument(1);
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\DataBinding.uno
// ------------------------------------------------------------------------------------------------

// public enum BindingMode :8
uEnumType* BindingMode_typeof()
{
    static uSStrong<uEnumType*> type;
    if (type != NULL) return type;

    type = uEnumType::New("Fuse.Reactive.BindingMode", ::g::Uno::Int_typeof(), 8);
    type->SetLiterals(
        "Read", 1LL,
        "Write", 2LL,
        "Clear", 4LL,
        "ReadClear", 5LL,
        "WriteClear", 6LL,
        "ReadWriteClear", 7LL,
        "ReadWrite", 3LL,
        "Default", 3LL);
    return type;
}

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Device.uno
// ----------------------------------------------------------------------------------------------

// public class CapsObject :7
// {
static void CapsObject_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IObservableObject_typeof(), offsetof(CapsObject_type, interface0),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(CapsObject_type, interface1),
        ::g::Fuse::IObject_typeof(), offsetof(CapsObject_type, interface2));
    type->SetFields(2,
        ::g::Uno::Collections::Dictionary_typeof()->MakeType(::g::Uno::String_typeof(), uObject_typeof(), NULL), offsetof(CapsObject, _props), 0);
    type->Reflection.SetFunctions(3,
        new uFunction("ContainsKey", NULL, (void*)CapsObject__ContainsKey_fn, 0, false, ::g::Uno::Bool_typeof(), 1, ::g::Uno::String_typeof()),
        new uFunction("get_Item", NULL, (void*)CapsObject__get_Item_fn, 0, false, uObject_typeof(), 1, ::g::Uno::String_typeof()),
        new uFunction("get_Keys", NULL, (void*)CapsObject__get_Keys_fn, 0, false, ::g::Uno::String_typeof()->Array(), 0));
}

CapsObject_type* CapsObject_typeof()
{
    static uSStrong<CapsObject_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Uno::UX::PropertyObject_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 3;
    options.ObjectSize = sizeof(CapsObject);
    options.TypeSize = sizeof(CapsObject_type);
    type = (CapsObject_type*)uClassType::New("Fuse.Reactive.CapsObject", options);
    type->fp_build_ = CapsObject_build;
    type->fp_ctor_ = (void*)CapsObject__New2_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject**))CapsObject__FuseReactiveIObservableObjectSubscribe_fn;
    type->interface1.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))CapsObject__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface2.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))CapsObject__ContainsKey_fn;
    type->interface2.fp_get_Item = (void(*)(uObject*, uString*, uObject**))CapsObject__get_Item_fn;
    type->interface2.fp_get_Keys = (void(*)(uObject*, uArray**))CapsObject__get_Keys_fn;
    return type;
}

// internal CapsObject() :12
void CapsObject__ctor_1_fn(CapsObject* __this)
{
    __this->ctor_1();
}

// protected void ChangeProperty(Uno.UX.Selector name, object value) :43
void CapsObject__ChangeProperty_fn(CapsObject* __this, ::g::Uno::UX::Selector* name, uObject* value)
{
    __this->ChangeProperty(*name, value);
}

// public bool ContainsKey(string key) :14
void CapsObject__ContainsKey_fn(CapsObject* __this, uString* key, bool* __retval)
{
    *__retval = __this->ContainsKey(key);
}

// private Fuse.Reactive.IPropertySubscription Fuse.Reactive.IObservableObject.Subscribe(Fuse.Reactive.IPropertyObserver observer) :36
void CapsObject__FuseReactiveIObservableObjectSubscribe_fn(CapsObject* __this, uObject* observer, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.CapsObject", "Fuse.Reactive.IObservableObject.Subscribe(Fuse.Reactive.IPropertyObserver)");
    CapsObject__PropertySubscription* sub = CapsObject__PropertySubscription::New1(__this, observer);
    __this->AddPropertyListener((uObject*)sub);
    return *__retval = (uObject*)sub, void();
}

// private object GetValue(string key) :23
void CapsObject__GetValue_fn(CapsObject* __this, uString* key, uObject** __retval)
{
    *__retval = __this->GetValue(key);
}

// public object get_Item(string key) :21
void CapsObject__get_Item_fn(CapsObject* __this, uString* key, uObject** __retval)
{
    *__retval = __this->Item(key);
}

// public string[] get_Keys() :33
void CapsObject__get_Keys_fn(CapsObject* __this, uArray** __retval)
{
    *__retval = __this->Keys();
}

// internal CapsObject New() :12
void CapsObject__New2_fn(CapsObject** __retval)
{
    *__retval = CapsObject::New2();
}

// protected Uno.Collections.Dictionary<string, object> get_Props() :10
void CapsObject__get_Props_fn(CapsObject* __this, ::g::Uno::Collections::Dictionary** __retval)
{
    *__retval = __this->Props();
}

// private void Uno.UX.IPropertyListener.OnPropertyChanged(Uno.UX.PropertyObject obj, Uno.UX.Selector name) :49
void CapsObject__UnoUXIPropertyListenerOnPropertyChanged_fn(CapsObject* __this, ::g::Uno::UX::PropertyObject* obj, ::g::Uno::UX::Selector* name)
{
}

// internal CapsObject() [instance] :12
void CapsObject::ctor_1()
{
    _props = ((::g::Uno::Collections::Dictionary*)::g::Uno::Collections::Dictionary::New1(::TYPES[5/*Uno.Collections.Dictionary<string, object>*/]));
    ctor_();
}

// protected void ChangeProperty(Uno.UX.Selector name, object value) [instance] :43
void CapsObject::ChangeProperty(::g::Uno::UX::Selector name, uObject* value)
{
    uStackFrame __("Fuse.Reactive.CapsObject", "ChangeProperty(Uno.UX.Selector,object)");
    ::g::Uno::Collections::Dictionary__set_Item_fn(uPtr(_props), ::g::Uno::UX::Selector__op_Implicit1(name), value);
    OnPropertyChanged1(name, (uObject*)this);
}

// public bool ContainsKey(string key) [instance] :14
bool CapsObject::ContainsKey(uString* key)
{
    uStackFrame __("Fuse.Reactive.CapsObject", "ContainsKey(string)");
    bool ret2;
    return (::g::Uno::Collections::Dictionary__ContainsKey_fn(uPtr(_props), key, &ret2), ret2);
}

// private object GetValue(string key) [instance] :23
uObject* CapsObject::GetValue(uString* key)
{
    uStackFrame __("Fuse.Reactive.CapsObject", "GetValue(string)");
    bool ret3;
    uObject* value;

    if ((::g::Uno::Collections::Dictionary__TryGetValue_fn(uPtr(_props), key, (void**)(&value), &ret3), ret3))
        return value;

    return NULL;
}

// public object get_Item(string key) [instance] :21
uObject* CapsObject::Item(uString* key)
{
    uStackFrame __("Fuse.Reactive.CapsObject", "get_Item(string)");
    return GetValue(key);
}

// public string[] get_Keys() [instance] :33
uArray* CapsObject::Keys()
{
    uStackFrame __("Fuse.Reactive.CapsObject", "get_Keys()");
    return (uArray*)::g::Uno::Collections::EnumerableExtensions::ToArray(::TYPES[7/*Uno.Collections.EnumerableExtensions.ToArray<string>*/], (uObject*)((::g::Uno::Collections::Dictionary__KeyCollection*)uPtr(_props)->Keys()));
}

// protected Uno.Collections.Dictionary<string, object> get_Props() [instance] :10
::g::Uno::Collections::Dictionary* CapsObject::Props()
{
    return _props;
}

// internal CapsObject New() [static] :12
CapsObject* CapsObject::New2()
{
    CapsObject* obj1 = (CapsObject*)uNew(CapsObject_typeof());
    obj1->ctor_1();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\MatchCase.uno
// ----------------------------------------------------------------------------------------------

// public sealed class Case :274
// {
static void Case_build(uType* type)
{
    ::STRINGS[14] = uString::Const("Case already has a Match");
    ::TYPES[11] = ::g::Uno::Action1_typeof()->MakeType(::g::Uno::UX::Template_typeof(), NULL);
    ::TYPES[12] = ::g::Uno::Bool_typeof();
    ::TYPES[13] = ::g::Uno::Collections::RootableList_typeof()->MakeType(::g::Uno::UX::Template_typeof(), NULL);
    ::TYPES[14] = ::g::Uno::Double_typeof();
    ::TYPES[1] = ::g::Uno::String_typeof();
    type->SetFields(0,
        ::g::Fuse::Reactive::Match_typeof(), offsetof(Case, _match), 0,
        uObject_typeof(), offsetof(Case, _value), 0,
        ::TYPES[13/*Uno.Collections.RootableList<Uno.UX.Template>*/], offsetof(Case, _factories), 0,
        ::TYPES[12/*bool*/], offsetof(Case, _IsDefault), 0);
    type->Reflection.SetFunctions(12,
        new uFunction("get_Bool", NULL, (void*)Case__get_Bool_fn, 0, false, ::TYPES[12/*bool*/], 0),
        new uFunction("set_Bool", NULL, (void*)Case__set_Bool_fn, 0, false, uVoid_typeof(), 1, ::TYPES[12/*bool*/]),
        new uFunction("get_Factories", NULL, (void*)Case__get_Factories_fn, 0, false, ::g::Uno::Collections::IList_typeof()->MakeType(::g::Uno::UX::Template_typeof(), NULL), 0),
        new uFunction("get_IsDefault", NULL, (void*)Case__get_IsDefault_fn, 0, false, ::TYPES[12/*bool*/], 0),
        new uFunction("set_IsDefault", NULL, (void*)Case__set_IsDefault_fn, 0, false, uVoid_typeof(), 1, ::TYPES[12/*bool*/]),
        new uFunction(".ctor", NULL, (void*)Case__New1_fn, 0, true, type, 0),
        new uFunction("get_Number", NULL, (void*)Case__get_Number_fn, 0, false, ::TYPES[14/*double*/], 0),
        new uFunction("set_Number", NULL, (void*)Case__set_Number_fn, 0, false, uVoid_typeof(), 1, ::TYPES[14/*double*/]),
        new uFunction("get_String", NULL, (void*)Case__get_String_fn, 0, false, ::TYPES[1/*string*/], 0),
        new uFunction("set_String", NULL, (void*)Case__set_String_fn, 0, false, uVoid_typeof(), 1, ::TYPES[1/*string*/]),
        new uFunction("get_Value", NULL, (void*)Case__get_Value_fn, 0, false, uObject_typeof(), 0),
        new uFunction("set_Value", NULL, (void*)Case__set_Value_fn, 0, false, uVoid_typeof(), 1, uObject_typeof()));
}

uType* Case_typeof()
{
    static uSStrong<uType*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 4;
    options.ObjectSize = sizeof(Case);
    options.TypeSize = sizeof(uType);
    type = uClassType::New("Fuse.Reactive.Case", options);
    type->fp_build_ = Case_build;
    type->fp_ctor_ = (void*)Case__New1_fn;
    return type;
}

// public generated Case() :274
void Case__ctor__fn(Case* __this)
{
    __this->ctor_();
}

// public bool get_Bool() :333
void Case__get_Bool_fn(Case* __this, bool* __retval)
{
    *__retval = __this->Bool();
}

// public void set_Bool(bool value) :334
void Case__set_Bool_fn(Case* __this, bool* value)
{
    __this->Bool(*value);
}

// public Uno.Collections.IList<Uno.UX.Template> get_Factories() :353
void Case__get_Factories_fn(Case* __this, uObject** __retval)
{
    *__retval = __this->Factories();
}

// private void Invalidate() :370
void Case__Invalidate_fn(Case* __this)
{
    __this->Invalidate();
}

// public generated bool get_IsDefault() :341
void Case__get_IsDefault_fn(Case* __this, bool* __retval)
{
    *__retval = __this->IsDefault();
}

// public generated void set_IsDefault(bool value) :342
void Case__set_IsDefault_fn(Case* __this, bool* value)
{
    __this->IsDefault(*value);
}

// private bool get_IsRooted() :277
void Case__get_IsRooted_fn(Case* __this, bool* __retval)
{
    *__retval = __this->IsRooted();
}

// public generated Case New() :274
void Case__New1_fn(Case** __retval)
{
    *__retval = Case::New1();
}

// public double get_Number() :325
void Case__get_Number_fn(Case* __this, double* __retval)
{
    *__retval = __this->Number();
}

// public void set_Number(double value) :326
void Case__set_Number_fn(Case* __this, double* value)
{
    __this->Number(*value);
}

// private void OnFactoriesChanged(Uno.UX.Template f) :365
void Case__OnFactoriesChanged_fn(Case* __this, ::g::Uno::UX::Template* f)
{
    __this->OnFactoriesChanged(f);
}

// internal void Root(Fuse.Reactive.Match match) :279
void Case__Root_fn(Case* __this, ::g::Fuse::Reactive::Match* match)
{
    __this->Root(match);
}

// public string get_String() :317
void Case__get_String_fn(Case* __this, uString** __retval)
{
    *__retval = __this->String();
}

// public void set_String(string value) :318
void Case__set_String_fn(Case* __this, uString* value)
{
    __this->String(value);
}

// internal void Unroot() :288
void Case__Unroot_fn(Case* __this)
{
    __this->Unroot();
}

// public object get_Value() :302
void Case__get_Value_fn(Case* __this, uObject** __retval)
{
    *__retval = __this->Value();
}

// public void set_Value(object value) :303
void Case__set_Value_fn(Case* __this, uObject* value)
{
    __this->Value(value);
}

// public generated Case() [instance] :274
void Case::ctor_()
{
}

// public bool get_Bool() [instance] :333
bool Case::Bool()
{
    uStackFrame __("Fuse.Reactive.Case", "get_Bool()");
    return uIs((uObject*)_value, ::TYPES[12/*bool*/]) ? uUnbox<bool>(::TYPES[12/*bool*/], _value) : false;
}

// public void set_Bool(bool value) [instance] :334
void Case::Bool(bool value)
{
    Value(uBox(::TYPES[12/*bool*/], value));
}

// public Uno.Collections.IList<Uno.UX.Template> get_Factories() [instance] :353
uObject* Case::Factories()
{
    uStackFrame __("Fuse.Reactive.Case", "get_Factories()");

    if (_factories == NULL)
    {
        _factories = ((::g::Uno::Collections::RootableList*)::g::Uno::Collections::RootableList::New1(::TYPES[13/*Uno.Collections.RootableList<Uno.UX.Template>*/]));

        if (IsRooted())
            uPtr(_factories)->Subscribe(uDelegate::New(::TYPES[11/*Uno.Action<Uno.UX.Template>*/], (void*)Case__OnFactoriesChanged_fn, this), uDelegate::New(::TYPES[11/*Uno.Action<Uno.UX.Template>*/], (void*)Case__OnFactoriesChanged_fn, this));
    }

    return (uObject*)_factories;
}

// private void Invalidate() [instance] :370
void Case::Invalidate()
{
    uStackFrame __("Fuse.Reactive.Case", "Invalidate()");

    if (_match != NULL)
        uPtr(_match)->Invalidate();
}

// public generated bool get_IsDefault() [instance] :341
bool Case::IsDefault()
{
    return _IsDefault;
}

// public generated void set_IsDefault(bool value) [instance] :342
void Case::IsDefault(bool value)
{
    _IsDefault = value;
}

// private bool get_IsRooted() [instance] :277
bool Case::IsRooted()
{
    return _match != NULL;
}

// public double get_Number() [instance] :325
double Case::Number()
{
    uStackFrame __("Fuse.Reactive.Case", "get_Number()");
    return uIs((uObject*)_value, ::TYPES[14/*double*/]) ? uUnbox<double>(::TYPES[14/*double*/], _value) : 0.0;
}

// public void set_Number(double value) [instance] :326
void Case::Number(double value)
{
    Value(uBox(::TYPES[14/*double*/], value));
}

// private void OnFactoriesChanged(Uno.UX.Template f) [instance] :365
void Case::OnFactoriesChanged(::g::Uno::UX::Template* f)
{
    uStackFrame __("Fuse.Reactive.Case", "OnFactoriesChanged(Uno.UX.Template)");
    Invalidate();
}

// internal void Root(Fuse.Reactive.Match match) [instance] :279
void Case::Root(::g::Fuse::Reactive::Match* match)
{
    uStackFrame __("Fuse.Reactive.Case", "Root(Fuse.Reactive.Match)");

    if (_match != NULL)
        U_THROW(::g::Uno::Exception::New2(::STRINGS[14/*"Case alread...*/]));

    _match = match;

    if (_factories != NULL)
        uPtr(_factories)->Subscribe(uDelegate::New(::TYPES[11/*Uno.Action<Uno.UX.Template>*/], (void*)Case__OnFactoriesChanged_fn, this), uDelegate::New(::TYPES[11/*Uno.Action<Uno.UX.Template>*/], (void*)Case__OnFactoriesChanged_fn, this));
}

// public string get_String() [instance] :317
uString* Case::String()
{
    return uAs<uString*>(_value, ::TYPES[1/*string*/]);
}

// public void set_String(string value) [instance] :318
void Case::String(uString* value)
{
    Value(value);
}

// internal void Unroot() [instance] :288
void Case::Unroot()
{
    uStackFrame __("Fuse.Reactive.Case", "Unroot()");

    if (_factories != NULL)
        uPtr(_factories)->Unsubscribe();

    _match = NULL;
}

// public object get_Value() [instance] :302
uObject* Case::Value()
{
    return _value;
}

// public void set_Value(object value) [instance] :303
void Case::Value(uObject* value)
{
    uStackFrame __("Fuse.Reactive.Case", "set_Value(object)");

    if (_value != value)
    {
        _value = value;
        Invalidate();
    }
}

// public generated Case New() [static] :274
Case* Case::New1()
{
    Case* obj1 = (Case*)uNew(Case_typeof());
    obj1->ctor_();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Ceil :303
// {
static void Ceil_build(uType* type)
{
    ::STRINGS[15] = uString::Const("ceil");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Ceil__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Ceil_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Ceil);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Ceil", options);
    type->fp_build_ = Ceil_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Ceil(Fuse.Reactive.Expression operand) :306
void Ceil__ctor_5_fn(Ceil* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Ceil New(Fuse.Reactive.Expression operand) :306
void Ceil__New1_fn(::g::Fuse::Reactive::Expression* operand, Ceil** __retval)
{
    *__retval = Ceil::New1(operand);
}

// public Ceil(Fuse.Reactive.Expression operand) [instance] :306
void Ceil::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[15/*"ceil"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Ceil_fn));
}

// public Ceil New(Fuse.Reactive.Expression operand) [static] :306
Ceil* Ceil::New1(::g::Fuse::Reactive::Expression* operand)
{
    Ceil* obj1 = (Ceil*)uNew(Ceil_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Clamp :480
// {
static void Clamp_build(uType* type)
{
    ::STRINGS[16] = uString::Const("clamp(");
    ::STRINGS[17] = uString::Const(",");
    ::STRINGS[6] = uString::Const(")");
    ::TYPES[2] = ::g::Fuse::Marshal_typeof()->MakeMethod(1/*TryToType<float>*/, ::g::Uno::Float_typeof(), NULL);
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::TernaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Clamp__New1_fn, 0, true, type, 3, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::TernaryOperator_type* Clamp_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::TernaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::TernaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(Clamp);
    options.TypeSize = sizeof(::g::Fuse::Reactive::TernaryOperator_type);
    type = (::g::Fuse::Reactive::TernaryOperator_type*)uClassType::New("Fuse.Reactive.Clamp", options);
    type->fp_build_ = Clamp_build;
    type->fp_ToString = (void(*)(uObject*, uString**))Clamp__ToString_fn;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::TernaryOperator*, uObject*, uObject*, uObject*, uObject**, bool*))Clamp__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Clamp(Fuse.Reactive.Expression first, Fuse.Reactive.Expression second, Fuse.Reactive.Expression third) :483
void Clamp__ctor_3_fn(Clamp* __this, ::g::Fuse::Reactive::Expression* first, ::g::Fuse::Reactive::Expression* second, ::g::Fuse::Reactive::Expression* third)
{
    __this->ctor_3(first, second, third);
}

// public Clamp New(Fuse.Reactive.Expression first, Fuse.Reactive.Expression second, Fuse.Reactive.Expression third) :483
void Clamp__New1_fn(::g::Fuse::Reactive::Expression* first, ::g::Fuse::Reactive::Expression* second, ::g::Fuse::Reactive::Expression* third, Clamp** __retval)
{
    *__retval = Clamp::New1(first, second, third);
}

// public override sealed string ToString() :512
void Clamp__ToString_fn(Clamp* __this, uString** __retval)
{
    uStackFrame __("Fuse.Reactive.Clamp", "ToString()");
    return *__retval = ::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::STRINGS[16/*"clamp("*/], __this->First()), ::STRINGS[17/*","*/]), __this->Second()), ::STRINGS[17/*","*/]), __this->Third()), ::STRINGS[6/*")"*/]), void();
}

// protected override sealed bool TryCompute(object a, object mn, object mx, object& result) :488
void Clamp__TryCompute1_fn(Clamp* __this, uObject* a, uObject* mn, uObject* mx, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.Clamp", "TryCompute(object,object,object,object&)");
    bool ret2;
    bool ret3;
    *result = NULL;
    ::g::Uno::Float4 av = ::g::Uno::Float4__New1(0.0f);
    float mxv = 0.0f, mnv = 0.0f;
    int32_t size = 0;

    if ((!::g::Fuse::Marshal::TryToZeroFloat4(a, &av, &size) || !(::g::Fuse::Marshal__TryToType_fn(::TYPES[2/*Fuse.Marshal.TryToType<float>*/], mn, &mnv, &ret2), ret2)) || !(::g::Fuse::Marshal__TryToType_fn(::TYPES[2/*Fuse.Marshal.TryToType<float>*/], mx, &mxv, &ret3), ret3))
        return *__retval = false, void();

    if (size == 1)
        *result = uBox(::TYPES[21/*float*/], ::g::Uno::Math::Clamp1(av.X, mnv, mxv));
    else if (size == 2)
        *result = uBox(::g::Uno::Float2_typeof(), ::g::Uno::Math::Clamp2(::g::Uno::Float2__New2(av.X, av.Y), mnv, mxv));
    else if (size == 3)
        *result = uBox(::g::Uno::Float3_typeof(), ::g::Uno::Math::Clamp4(::g::Uno::Float3__New2(av.X, av.Y, av.Z), mnv, mxv));
    else if (size == 4)
        *result = uBox(::g::Uno::Float4_typeof(), ::g::Uno::Math::Clamp6(av, mnv, mxv));
    else
        return *__retval = false, void();

    return *__retval = true, void();
}

// public Clamp(Fuse.Reactive.Expression first, Fuse.Reactive.Expression second, Fuse.Reactive.Expression third) [instance] :483
void Clamp::ctor_3(::g::Fuse::Reactive::Expression* first, ::g::Fuse::Reactive::Expression* second, ::g::Fuse::Reactive::Expression* third)
{
    ctor_2(first, second, third, 0);
}

// public Clamp New(Fuse.Reactive.Expression first, Fuse.Reactive.Expression second, Fuse.Reactive.Expression third) [static] :483
Clamp* Clamp::New1(::g::Fuse::Reactive::Expression* first, ::g::Fuse::Reactive::Expression* second, ::g::Fuse::Reactive::Expression* third)
{
    Clamp* obj1 = (Clamp*)uNew(Clamp_typeof());
    obj1->ctor_3(first, second, third);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Closure.uno
// --------------------------------------------------------------------------------------------

// public sealed class Closure :43
// {
static void Closure_build(uType* type)
{
    ::TYPES[15] = ::g::Fuse::Reactive::ClosureHandler_typeof();
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Node_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Node_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Node_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Node_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Node_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Node_type, interface5));
    type->SetFields(16,
        ::g::Uno::UX::NameTable_typeof(), offsetof(Closure, _nameTable), 0,
        ::TYPES[15/*Fuse.Reactive.ClosureHandler*/], offsetof(Closure, _ready), 0);
    type->Reflection.SetFunctions(3,
        new uFunction(".ctor", NULL, (void*)Closure__New2_fn, 0, true, type, 1, ::g::Uno::UX::NameTable_typeof()),
        new uFunction("add_Ready", NULL, (void*)Closure__add_Ready_fn, 0, false, uVoid_typeof(), 1, ::TYPES[15/*Fuse.Reactive.ClosureHandler*/]),
        new uFunction("remove_Ready", NULL, (void*)Closure__remove_Ready_fn, 0, false, uVoid_typeof(), 1, ::TYPES[15/*Fuse.Reactive.ClosureHandler*/]));
}

::g::Fuse::Node_type* Closure_typeof()
{
    static uSStrong< ::g::Fuse::Node_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Node_typeof();
    options.FieldCount = 18;
    options.InterfaceCount = 6;
    options.ObjectSize = sizeof(Closure);
    options.TypeSize = sizeof(::g::Fuse::Node_type);
    type = (::g::Fuse::Node_type*)uClassType::New("Fuse.Reactive.Closure", options);
    type->fp_build_ = Closure_build;
    type->fp_OnRooted = (void(*)(::g::Fuse::Node*))Closure__OnRooted_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public Closure(Uno.UX.NameTable nameTable) :48
void Closure__ctor_2_fn(Closure* __this, ::g::Uno::UX::NameTable* nameTable)
{
    __this->ctor_2(nameTable);
}

// public Closure New(Uno.UX.NameTable nameTable) :48
void Closure__New2_fn(::g::Uno::UX::NameTable* nameTable, Closure** __retval)
{
    *__retval = Closure::New2(nameTable);
}

// protected override sealed void OnRooted() :93
void Closure__OnRooted_fn(Closure* __this)
{
    uStackFrame __("Fuse.Reactive.Closure", "OnRooted()");
    ::g::Fuse::Node__OnRooted_fn(__this);
    __this->ScheduleReady();
}

// public void add_Ready(Fuse.Reactive.ClosureHandler value) :80
void Closure__add_Ready_fn(Closure* __this, uDelegate* value)
{
    __this->add_Ready(value);
}

// public void remove_Ready(Fuse.Reactive.ClosureHandler value) :87
void Closure__remove_Ready_fn(Closure* __this, uDelegate* value)
{
    __this->remove_Ready(value);
}

// private void ScheduleReady() :99
void Closure__ScheduleReady_fn(Closure* __this)
{
    __this->ScheduleReady();
}

// public Closure(Uno.UX.NameTable nameTable) [instance] :48
void Closure::ctor_2(::g::Uno::UX::NameTable* nameTable)
{
    ctor_1();
    _nameTable = nameTable;
}

// public void add_Ready(Fuse.Reactive.ClosureHandler value) [instance] :80
void Closure::add_Ready(uDelegate* value)
{
    uStackFrame __("Fuse.Reactive.Closure", "add_Ready(Fuse.Reactive.ClosureHandler)");

    if (IsRootingCompleted())
        ScheduleReady();

    _ready = uCast<uDelegate*>(::g::Uno::Delegate::Combine(_ready, value), ::TYPES[15/*Fuse.Reactive.ClosureHandler*/]);
}

// public void remove_Ready(Fuse.Reactive.ClosureHandler value) [instance] :87
void Closure::remove_Ready(uDelegate* value)
{
    uStackFrame __("Fuse.Reactive.Closure", "remove_Ready(Fuse.Reactive.ClosureHandler)");
    _ready = uCast<uDelegate*>(::g::Uno::Delegate::Remove(_ready, value), ::TYPES[15/*Fuse.Reactive.ClosureHandler*/]);
}

// private void ScheduleReady() [instance] :99
void Closure::ScheduleReady()
{
    uStackFrame __("Fuse.Reactive.Closure", "ScheduleReady()");

    if (::g::Uno::Delegate::op_Inequality(_ready, NULL))
        uPtr(_ready)->Invoke(2, this, (::g::Fuse::Reactive::ClosureArgs*)::g::Fuse::Reactive::ClosureArgs::New2(_nameTable));
}

// public Closure New(Uno.UX.NameTable nameTable) [static] :48
Closure* Closure::New2(::g::Uno::UX::NameTable* nameTable)
{
    Closure* obj1 = (Closure*)uNew(Closure_typeof());
    obj1->ctor_2(nameTable);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Closure.uno
// --------------------------------------------------------------------------------------------

// public sealed class ClosureArgs :11
// {
static void ClosureArgs_build(uType* type)
{
    ::TYPES[16] = ::g::Uno::Collections::ICollection_typeof()->MakeType(uObject_typeof(), NULL);
    ::TYPES[17] = ::g::Uno::Collections::IList_typeof()->MakeType(uObject_typeof(), NULL);
    ::TYPES[18] = ::g::Fuse::Scripting::IEventSerializer_typeof();
    type->SetInterfaces(
        ::g::Fuse::Scripting::IScriptEvent_typeof(), offsetof(ClosureArgs_type, interface0));
    type->SetFields(0,
        ::g::Uno::UX::NameTable_typeof(), offsetof(ClosureArgs, _names), 0);
    type->Reflection.SetFunctions(1,
        new uFunction("Serialize", NULL, (void*)ClosureArgs__Serialize_fn, 0, false, uVoid_typeof(), 1, ::TYPES[18/*Fuse.Scripting.IEventSerializer*/]));
}

ClosureArgs_type* ClosureArgs_typeof()
{
    static uSStrong<ClosureArgs_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Uno::EventArgs_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(ClosureArgs);
    options.TypeSize = sizeof(ClosureArgs_type);
    type = (ClosureArgs_type*)uClassType::New("Fuse.Reactive.ClosureArgs", options);
    type->fp_build_ = ClosureArgs_build;
    type->interface0.fp_Serialize = (void(*)(uObject*, uObject*))ClosureArgs__Serialize_fn;
    return type;
}

// internal ClosureArgs(Uno.UX.NameTable names) :15
void ClosureArgs__ctor_1_fn(ClosureArgs* __this, ::g::Uno::UX::NameTable* names)
{
    __this->ctor_1(names);
}

// internal ClosureArgs New(Uno.UX.NameTable names) :15
void ClosureArgs__New2_fn(::g::Uno::UX::NameTable* names, ClosureArgs** __retval)
{
    *__retval = ClosureArgs::New2(names);
}

// public void Serialize(Fuse.Scripting.IEventSerializer s) :20
void ClosureArgs__Serialize_fn(ClosureArgs* __this, uObject* s)
{
    __this->Serialize(s);
}

// internal ClosureArgs(Uno.UX.NameTable names) [instance] :15
void ClosureArgs::ctor_1(::g::Uno::UX::NameTable* names)
{
    ctor_();
    _names = names;
}

// public void Serialize(Fuse.Scripting.IEventSerializer s) [instance] :20
void ClosureArgs::Serialize(uObject* s)
{
    uStackFrame __("Fuse.Reactive.ClosureArgs", "Serialize(Fuse.Scripting.IEventSerializer)");
    uObject* ret2;
    ::g::Uno::UX::NameTable* nt = _names;
    int32_t o = (nt != NULL) ? ::g::Uno::Collections::ICollection::Count(uInterface(uPtr(uPtr(nt)->Objects()), ::TYPES[16/*Uno.Collections.ICollection<object>*/])) - 1 : 0;

    while (nt != NULL)
    {
        for (int32_t e = uPtr(uPtr(nt)->Entries)->Length(); (e--) > 0; )
        {
            uString* name = uPtr(uPtr(nt)->Entries)->Strong<uString*>(e);
            uObject* obj = (::g::Uno::Collections::IList::get_Item_ex(uInterface(uPtr(uPtr(_names)->Objects()), ::TYPES[17/*Uno.Collections.IList<object>*/]), uCRef<int32_t>(o--), &ret2), ret2);
            ::g::Fuse::Scripting::IEventSerializer::AddObject(uInterface(uPtr(s), ::TYPES[18/*Fuse.Scripting.IEventSerializer*/]), name, obj);
        }

        nt = uPtr(nt)->ParentTable;
    }
}

// internal ClosureArgs New(Uno.UX.NameTable names) [static] :15
ClosureArgs* ClosureArgs::New2(::g::Uno::UX::NameTable* names)
{
    ClosureArgs* obj1 = (ClosureArgs*)uNew(ClosureArgs_typeof());
    obj1->ctor_1(names);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Closure.uno
// --------------------------------------------------------------------------------------------

// public delegate void ClosureHandler(object sender, Fuse.Reactive.ClosureArgs args) :38
uDelegateType* ClosureHandler_typeof()
{
    static uSStrong<uDelegateType*> type;
    if (type != NULL) return type;

    type = uDelegateType::New("Fuse.Reactive.ClosureHandler", 2, 0);
    type->SetSignature(uVoid_typeof(),
        uObject_typeof(),
        ::g::Fuse::Reactive::ClosureArgs_typeof());
    return type;
}

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\ExpressionListener.uno
// ----------------------------------------------------------------------------------------------------------

// public abstract class ComputeExpression :223
// {
static void ComputeExpression_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(ComputeExpression_type, interface0));
    type->SetFields(0,
        ::g::Fuse::Reactive::Expression_typeof()->Array(), offsetof(ComputeExpression, _args), 0,
        ComputeExpression__Flags_typeof(), offsetof(ComputeExpression, _flags), 0,
        ::g::Uno::String_typeof(), offsetof(ComputeExpression, _name), 0);
}

ComputeExpression_type* ComputeExpression_typeof()
{
    static uSStrong<ComputeExpression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(ComputeExpression);
    options.TypeSize = sizeof(ComputeExpression_type);
    type = (ComputeExpression_type*)uClassType::New("Fuse.Reactive.ComputeExpression", options);
    type->fp_build_ = ComputeExpression_build;
    type->fp_GetFlags = ComputeExpression__GetFlags_fn;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))ComputeExpression__Subscribe_fn;
    type->fp_ToString = (void(*)(uObject*, uString**))ComputeExpression__ToString_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))ComputeExpression__Subscribe_fn;
    return type;
}

// protected ComputeExpression(Fuse.Reactive.Expression[] args, [Fuse.Reactive.ComputeExpression.Flags flags], [string name]) :253
void ComputeExpression__ctor_1_fn(ComputeExpression* __this, uArray* args, int32_t* flags, uString* name)
{
    __this->ctor_1(args, *flags, name);
}

// private Fuse.Reactive.ExpressionSubscriber.Flags get_EffectiveFlags() :299
void ComputeExpression__get_EffectiveFlags_fn(ComputeExpression* __this, int32_t* __retval)
{
    *__retval = __this->EffectiveFlags();
}

// protected Fuse.Reactive.Expression GetArgument(int i) :246
void ComputeExpression__GetArgument_fn(ComputeExpression* __this, int32_t* i, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->GetArgument(*i);
}

// internal virtual Fuse.Reactive.ComputeExpression.Flags GetFlags() :313
void ComputeExpression__GetFlags_fn(ComputeExpression* __this, int32_t* __retval)
{
    return *__retval = __this->_flags, void();
}

// protected string get_Name() :277
void ComputeExpression__get_Name_fn(ComputeExpression* __this, uString** __retval)
{
    *__retval = __this->Name();
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :322
void ComputeExpression__Subscribe_fn(ComputeExpression* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.ComputeExpression", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    ComputeExpression__Subscription* sub = ComputeExpression__Subscription::New1(__this, listener);
    sub->Init(context);
    return *__retval = (uObject*)sub, void();
}

// public override string ToString() :284
void ComputeExpression__ToString_fn(ComputeExpression* __this, uString** __retval)
{
    uStackFrame __("Fuse.Reactive.ComputeExpression", "ToString()");
    uString* r = ::g::Uno::String::op_Addition2(__this->Name(), ::STRINGS[4/*"("*/]);

    for (int32_t i = 0; i < uPtr(__this->_args)->Length(); ++i)
    {
        if (i > 0)
            r = ::g::Uno::String::op_Addition2(r, ::STRINGS[5/*", "*/]);

        r = ::g::Uno::String::op_Addition1(r, uPtr(__this->_args)->Strong< ::g::Fuse::Reactive::Expression*>(i));
    }

    r = ::g::Uno::String::op_Addition2(r, ::STRINGS[6/*")"*/]);
    return *__retval = r, void();
}

// protected ComputeExpression(Fuse.Reactive.Expression[] args, [Fuse.Reactive.ComputeExpression.Flags flags], [string name]) [instance] :253
void ComputeExpression::ctor_1(uArray* args, int32_t flags, uString* name)
{
    uStackFrame __("Fuse.Reactive.ComputeExpression", ".ctor(Fuse.Reactive.Expression[],[Fuse.Reactive.ComputeExpression.Flags],[string])");
    ctor_();
    _flags = flags;
    _args = args;
    _name = name;

    if ((_flags & 1024) == 1024)
        ::g::Fuse::Diagnostics::Deprecated(uString::Const("This constructor and use of the Is*Optional virtuals is deprecated. Pass the optionals as flags to the constructor, or specifiy Flags.None to avoid the message"), this, ::STRINGS[141/*"C:\\Users\\...*/], 262, ::STRINGS[124/*".ctor"*/]);

    if ((_flags & 2048) == 2048)
    {
        if (!uIs(this, ::TYPES[67/*Fuse.Reactive.UnaryOperator*/]) || (uPtr(args)->Length() != 1))
            U_THROW(::g::Uno::Exception::New2(uString::Const("DeprecatedVirtualUnary supported only on UnaryOperator with 1 argument")));

        ::g::Fuse::Diagnostics::Deprecated(uString::Const("Overiding the UnaryOperator.OnNewOperand/OnLostData is deprecated. Implement `Compute` and call the other constructor, or pass Flags.None, or implement an `Expression` and `ExpressionListener` if you need the behavior (rare)."), this, ::STRINGS[141/*"C:\\Users\\...*/], 270, ::STRINGS[124/*".ctor"*/]);
    }
}

// private Fuse.Reactive.ExpressionSubscriber.Flags get_EffectiveFlags() [instance] :299
int32_t ComputeExpression::EffectiveFlags()
{
    uStackFrame __("Fuse.Reactive.ComputeExpression", "get_EffectiveFlags()");
    int32_t flags = ((_flags & 1024) == 1024) ? GetFlags() : _flags;
    return ((((0 | (((flags & 1) == 1) ? 1 : 0)) | (((flags & 2) == 2) ? 2 : 0)) | (((flags & 4) == 4) ? 4 : 0)) | (((flags & 8) == 8) ? 8 : 0)) | (((flags & 16) == 16) ? 1024 : 0);
}

// protected Fuse.Reactive.Expression GetArgument(int i) [instance] :246
::g::Fuse::Reactive::Expression* ComputeExpression::GetArgument(int32_t i)
{
    uStackFrame __("Fuse.Reactive.ComputeExpression", "GetArgument(int)");
    return uPtr(_args)->Strong< ::g::Fuse::Reactive::Expression*>(i);
}

// protected string get_Name() [instance] :277
uString* ComputeExpression::Name()
{
    return _name;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class Concat :26
// {
static void Concat_build(uType* type)
{
    ::STRINGS[18] = uString::Const("++");
    ::TYPES[19] = ::g::Fuse::Marshal_typeof()->MakeMethod(1/*TryToType<string>*/, ::g::Uno::String_typeof(), NULL);
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Concat__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* Concat_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InfixOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Concat);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.Concat", options);
    type->fp_build_ = Concat_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))Concat__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Concat(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :29
void Concat__ctor_6_fn(Concat* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_6(left, right);
}

// public Concat New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :29
void Concat__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, Concat** __retval)
{
    *__retval = Concat::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :31
void Concat__TryCompute1_fn(Concat* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    return *__retval = Concat::TryComputeImpl(left, right, result), void();
}

// internal static bool TryComputeImpl(object left, object right, object& result) :36
void Concat__TryComputeImpl_fn(uObject* left, uObject* right, uObject** result, bool* __retval)
{
    *__retval = Concat::TryComputeImpl(left, right, result);
}

// public Concat(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :29
void Concat::ctor_6(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    ctor_5(left, right, ::STRINGS[18/*"++"*/], 0);
}

// public Concat New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :29
Concat* Concat::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    Concat* obj1 = (Concat*)uNew(Concat_typeof());
    obj1->ctor_6(left, right);
    return obj1;
}

// internal static bool TryComputeImpl(object left, object right, object& result) [static] :36
bool Concat::TryComputeImpl(uObject* left, uObject* right, uObject** result)
{
    uStackFrame __("Fuse.Reactive.Concat", "TryComputeImpl(object,object,object&)");
    bool ret2;
    bool ret3;
    *result = NULL;
    uString* a = NULL, *b = NULL;

    if (!(::g::Fuse::Marshal__TryToType_fn(::TYPES[19/*Fuse.Marshal.TryToType<string>*/], left, (void**)(&a), &ret2), ret2) || !(::g::Fuse::Marshal__TryToType_fn(::TYPES[19/*Fuse.Marshal.TryToType<string>*/], right, (void**)(&b), &ret3), ret3))
        return false;

    *result = ::g::Uno::String::op_Addition2(a, b);
    return true;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class Conditional :98
// {
static void Conditional_build(uType* type)
{
    ::STRINGS[4] = uString::Const("(");
    ::STRINGS[19] = uString::Const(" ? ");
    ::STRINGS[20] = uString::Const(" : ");
    ::STRINGS[6] = uString::Const(")");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::TernaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Conditional__New1_fn, 0, true, type, 3, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::TernaryOperator_type* Conditional_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::TernaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::TernaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(Conditional);
    options.TypeSize = sizeof(::g::Fuse::Reactive::TernaryOperator_type);
    type = (::g::Fuse::Reactive::TernaryOperator_type*)uClassType::New("Fuse.Reactive.Conditional", options);
    type->fp_build_ = Conditional_build;
    type->fp_ToString = (void(*)(uObject*, uString**))Conditional__ToString_fn;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::TernaryOperator*, uObject*, uObject*, uObject*, uObject**, bool*))Conditional__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Conditional(Fuse.Reactive.Expression condition, Fuse.Reactive.Expression trueValue, Fuse.Reactive.Expression falseValue) :101
void Conditional__ctor_3_fn(Conditional* __this, ::g::Fuse::Reactive::Expression* condition, ::g::Fuse::Reactive::Expression* trueValue, ::g::Fuse::Reactive::Expression* falseValue)
{
    __this->ctor_3(condition, trueValue, falseValue);
}

// public Conditional New(Fuse.Reactive.Expression condition, Fuse.Reactive.Expression trueValue, Fuse.Reactive.Expression falseValue) :101
void Conditional__New1_fn(::g::Fuse::Reactive::Expression* condition, ::g::Fuse::Reactive::Expression* trueValue, ::g::Fuse::Reactive::Expression* falseValue, Conditional** __retval)
{
    *__retval = Conditional::New1(condition, trueValue, falseValue);
}

// public override sealed string ToString() :112
void Conditional__ToString_fn(Conditional* __this, uString** __retval)
{
    uStackFrame __("Fuse.Reactive.Conditional", "ToString()");
    return *__retval = ::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::STRINGS[4/*"("*/], __this->First()), ::STRINGS[19/*" ? "*/]), __this->Second()), ::STRINGS[20/*" : "*/]), __this->Third()), ::STRINGS[6/*")"*/]), void();
}

// protected override sealed bool TryCompute(object cond, object trueVal, object falseVal, object& result) :104
void Conditional__TryCompute1_fn(Conditional* __this, uObject* cond, uObject* trueVal, uObject* falseVal, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.Conditional", "TryCompute(object,object,object,object&)");
    *result = NULL;

    if (cond == NULL)
        return *__retval = false, void();

    *result = ::g::Fuse::Marshal::ToBool(cond) ? trueVal : falseVal;
    return *__retval = true, void();
}

// public Conditional(Fuse.Reactive.Expression condition, Fuse.Reactive.Expression trueValue, Fuse.Reactive.Expression falseValue) [instance] :101
void Conditional::ctor_3(::g::Fuse::Reactive::Expression* condition, ::g::Fuse::Reactive::Expression* trueValue, ::g::Fuse::Reactive::Expression* falseValue)
{
    ctor_2(condition, trueValue, falseValue, 4);
}

// public Conditional New(Fuse.Reactive.Expression condition, Fuse.Reactive.Expression trueValue, Fuse.Reactive.Expression falseValue) [static] :101
Conditional* Conditional::New1(::g::Fuse::Reactive::Expression* condition, ::g::Fuse::Reactive::Expression* trueValue, ::g::Fuse::Reactive::Expression* falseValue)
{
    Conditional* obj1 = (Conditional*)uNew(Conditional_typeof());
    obj1->ctor_3(condition, trueValue, falseValue);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Scripting.JavaScript\1.8.1\FuseJS\DebugLog.uno
// -------------------------------------------------------------------------------------------------------

// internal static class Console :24
// {
static void Console_build(uType* type)
{
    ::STRINGS[21] = uString::Const("C:/Users/borde_000/AppData/Local/Fusetools/Packages/Fuse.Scripting.JavaScript/1.8.1/FuseJS/DebugLog.uno");
    ::STRINGS[22] = uString::Const("null");
    ::STRINGS[23] = uString::Const("\"");
    ::STRINGS[24] = uString::Const("function");
    ::STRINGS[25] = uString::Const("Object");
    ::STRINGS[26] = uString::Const("");
    ::STRINGS[27] = uString::Const(": ");
    ::STRINGS[28] = uString::Const("Array[");
    ::STRINGS[29] = uString::Const("]");
    ::STRINGS[30] = uString::Const(" ");
    ::STRINGS[31] = uString::Const("  ");
    ::STRINGS[32] = uString::Const("log");
    ::STRINGS[33] = uString::Const("warn");
    ::STRINGS[34] = uString::Const("info");
    ::STRINGS[35] = uString::Const("error");
    ::STRINGS[36] = uString::Const("dir");
    ::STRINGS[37] = uString::Const("console");
    ::STRINGS[38] = uString::Const("fuse-builtins");
    ::STRINGS[39] = uString::Const("(function(obj) {\tif (obj instanceof Error) return obj.stack;\treturn '' + obj;})");
    ::TYPES[20] = ::g::Uno::Int_typeof();
    ::TYPES[21] = ::g::Uno::Float_typeof();
    ::TYPES[14] = ::g::Uno::Double_typeof();
    ::TYPES[12] = ::g::Uno::Bool_typeof();
    ::TYPES[1] = ::g::Uno::String_typeof();
    ::TYPES[22] = ::g::Fuse::Scripting::Function_typeof();
    ::TYPES[23] = ::g::Fuse::Scripting::Object_typeof();
    ::TYPES[24] = ::g::Fuse::Scripting::Array_typeof();
    ::TYPES[25] = ::g::Fuse::Scripting::Callback_typeof();
    ::TYPES[4] = uObject_typeof()->Array();
    type->SetDependencies(
        ::g::Uno::Diagnostics::Debug_typeof());
    type->SetFields(0,
        ::TYPES[22/*Fuse.Scripting.Function*/], (uintptr_t)&Console::_toStringFunction_, uFieldFlagsStatic);
}

uClassType* Console_typeof()
{
    static uSStrong<uClassType*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 1;
    options.DependencyCount = 1;
    options.TypeSize = sizeof(uClassType);
    type = uClassType::New("Fuse.Reactive.Console", options);
    type->fp_build_ = Console_build;
    return type;
}

// private static object Dir(Fuse.Scripting.Context context, object[] args) :96
void Console__Dir_fn(::g::Fuse::Scripting::Context* context, uArray* args, uObject** __retval)
{
    *__retval = Console::Dir(context, args);
}

// private static void Dir(Uno.Text.StringBuilder builder, object obj, [int maxDepth], [int indent]) :108
void Console__Dir1_fn(::g::Uno::Text::StringBuilder* builder, uObject* obj, int32_t* maxDepth, int32_t* indent)
{
    Console::Dir1(builder, obj, *maxDepth, *indent);
}

// private static object Error(Fuse.Scripting.Context context, object[] args) :60
void Console__Error_fn(::g::Fuse::Scripting::Context* context, uArray* args, uObject** __retval)
{
    *__retval = Console::Error(context, args);
}

// private static string Format(Fuse.Scripting.Context context, object[] args) :65
void Console__Format_fn(::g::Fuse::Scripting::Context* context, uArray* args, uString** __retval)
{
    *__retval = Console::Format(context, args);
}

// private static void Indent(Uno.Text.StringBuilder builder, int indent) :177
void Console__Indent_fn(::g::Uno::Text::StringBuilder* builder, int32_t* indent)
{
    Console::Indent(builder, *indent);
}

// private static object Info(Fuse.Scripting.Context context, object[] args) :55
void Console__Info_fn(::g::Fuse::Scripting::Context* context, uArray* args, uObject** __retval)
{
    *__retval = Console::Info(context, args);
}

// public static void Init(Fuse.Scripting.Context c) :26
void Console__Init_fn(::g::Fuse::Scripting::Context* c)
{
    Console::Init(c);
}

// private static object Log(Fuse.Scripting.Context context, object[] args) :45
void Console__Log_fn(::g::Fuse::Scripting::Context* context, uArray* args, uObject** __retval)
{
    *__retval = Console::Log(context, args);
}

// private static object LogInternal(Fuse.Scripting.Context context, object[] args, Uno.Diagnostics.DebugMessageType debugMessageType) :38
void Console__LogInternal_fn(::g::Fuse::Scripting::Context* context, uArray* args, int32_t* debugMessageType, uObject** __retval)
{
    *__retval = Console::LogInternal(context, args, *debugMessageType);
}

// private static string ToString(Fuse.Scripting.Context context, object obj) :81
void Console__ToString_fn(::g::Fuse::Scripting::Context* context, uObject* obj, uString** __retval)
{
    *__retval = Console::ToString(context, obj);
}

// private static object Warn(Fuse.Scripting.Context context, object[] args) :50
void Console__Warn_fn(::g::Fuse::Scripting::Context* context, uArray* args, uObject** __retval)
{
    *__retval = Console::Warn(context, args);
}

uSStrong< ::g::Fuse::Scripting::Function*> Console::_toStringFunction_;

// private static object Dir(Fuse.Scripting.Context context, object[] args) [static] :96
uObject* Console::Dir(::g::Fuse::Scripting::Context* context, uArray* args)
{
    uStackFrame __("Fuse.Reactive.Console", "Dir(Fuse.Scripting.Context,object[])");
    int32_t maxDepth = 1;
    ::g::Uno::Text::StringBuilder* builder = ::g::Uno::Text::StringBuilder::New1();

    for (int32_t i = 0; i < uPtr(args)->Length(); i++)
        Console::Dir1(builder, uPtr(args)->Strong<uObject*>(i), 1, 0);

    ::g::Uno::Diagnostics::Debug::Log3(builder->ToString(), 0, ::STRINGS[21/*"C:/Users/bo...*/], 104);
    return NULL;
}

// private static void Dir(Uno.Text.StringBuilder builder, object obj, [int maxDepth], [int indent]) [static] :108
void Console::Dir1(::g::Uno::Text::StringBuilder* builder, uObject* obj, int32_t maxDepth, int32_t indent)
{
    uStackFrame __("Fuse.Reactive.Console", "Dir(Uno.Text.StringBuilder,object,[int],[int])");
    uArray* array1;
    int32_t index2;
    int32_t length3;
    indent++;

    if (obj == NULL)
    {
        uPtr(builder)->AppendLine(::STRINGS[22/*"null"*/]);
        return;
    }

    if ((uIs(obj, ::TYPES[20/*int*/]) || uIs(obj, ::TYPES[21/*float*/])) || uIs(obj, ::TYPES[14/*double*/]))
    {
        uPtr(builder)->AppendLine(::g::Uno::Object::ToString(uPtr(obj)));
        return;
    }

    if (uIs(obj, ::TYPES[12/*bool*/]))
    {
        uPtr(builder)->AppendLine(::g::Uno::String::ToLower(uPtr(::g::Uno::Object::ToString(uPtr(obj)))));
        return;
    }

    if (uIs(obj, ::TYPES[1/*string*/]))
    {
        uPtr(builder)->AppendLine(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::STRINGS[23/*"\""*/], ::g::Uno::Object::ToString(uPtr(obj))), ::STRINGS[23/*"\""*/]));
        return;
    }

    if (uIs(obj, ::TYPES[22/*Fuse.Scripting.Function*/]))
    {
        uPtr(builder)->AppendLine(::STRINGS[24/*"function"*/]);
        return;
    }

    if (uIs(obj, ::TYPES[23/*Fuse.Scripting.Object*/]))
    {
        ::g::Fuse::Scripting::Object* o = uCast< ::g::Fuse::Scripting::Object*>(obj, ::TYPES[23/*Fuse.Scripting.Object*/]);
        uPtr(builder)->AppendLine(::STRINGS[25/*"Object"*/]);

        if (indent <= maxDepth)

            for (array1 = uPtr(o)->Keys(), index2 = 0, length3 = uPtr(array1)->Length(); index2 < length3; ++index2)
            {
                uString* k = uPtr(array1)->Strong<uString*>(index2);
                Console::Indent(builder, indent);
                uPtr(builder)->Append2(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::STRINGS[26/*""*/], k), ::STRINGS[27/*": "*/]));
                Console::Dir1(builder, uPtr(o)->Item(k), maxDepth, indent);
            }

        return;
    }

    if (uIs(obj, ::TYPES[24/*Fuse.Scripting.Array*/]))
    {
        ::g::Fuse::Scripting::Array* a = uCast< ::g::Fuse::Scripting::Array*>(obj, ::TYPES[24/*Fuse.Scripting.Array*/]);
        uPtr(builder)->AppendLine(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::STRINGS[28/*"Array["*/], uBox<int32_t>(::TYPES[20/*int*/], uPtr(a)->Length())), ::STRINGS[29/*"]"*/]));

        if (indent <= maxDepth)

            for (int32_t i = 0; i < uPtr(a)->Length(); i++)
            {
                Console::Indent(builder, indent);
                uPtr(builder)->Append2(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::STRINGS[26/*""*/], uBox<int32_t>(::TYPES[20/*int*/], i)), ::STRINGS[27/*": "*/]));
                Console::Dir1(builder, uPtr(a)->Item(i), maxDepth, indent);
            }

        return;
    }

    uPtr(builder)->AppendLine(::g::Uno::Object::ToString(uPtr(obj)));
}

// private static object Error(Fuse.Scripting.Context context, object[] args) [static] :60
uObject* Console::Error(::g::Fuse::Scripting::Context* context, uArray* args)
{
    return Console::LogInternal(context, args, 3);
}

// private static string Format(Fuse.Scripting.Context context, object[] args) [static] :65
uString* Console::Format(::g::Fuse::Scripting::Context* context, uArray* args)
{
    uStackFrame __("Fuse.Reactive.Console", "Format(Fuse.Scripting.Context,object[])");
    ::g::Uno::Text::StringBuilder* sb = ::g::Uno::Text::StringBuilder::New1();

    for (int32_t i = 0; i < uPtr(args)->Length(); ++i)
    {
        if (i != 0)
            uPtr(sb)->Append2(::STRINGS[30/*" "*/]);

        uPtr(sb)->Append2(Console::ToString(context, uPtr(args)->Strong<uObject*>(i)));
    }

    return sb->ToString();
}

// private static void Indent(Uno.Text.StringBuilder builder, int indent) [static] :177
void Console::Indent(::g::Uno::Text::StringBuilder* builder, int32_t indent)
{
    uStackFrame __("Fuse.Reactive.Console", "Indent(Uno.Text.StringBuilder,int)");

    for (int32_t i = 0; i < indent; i++)
        uPtr(builder)->Append2(::STRINGS[31/*"  "*/]);
}

// private static object Info(Fuse.Scripting.Context context, object[] args) [static] :55
uObject* Console::Info(::g::Fuse::Scripting::Context* context, uArray* args)
{
    return Console::LogInternal(context, args, 1);
}

// public static void Init(Fuse.Scripting.Context c) [static] :26
void Console::Init(::g::Fuse::Scripting::Context* c)
{
    uStackFrame __("Fuse.Reactive.Console", "Init(Fuse.Scripting.Context)");
    ::g::Fuse::Scripting::Object* console = uPtr(c)->NewObject();
    uPtr(console)->Item(::STRINGS[32/*"log"*/], uDelegate::New(::TYPES[25/*Fuse.Scripting.Callback*/], (void*)Console__Log_fn));
    console->Item(::STRINGS[33/*"warn"*/], uDelegate::New(::TYPES[25/*Fuse.Scripting.Callback*/], (void*)Console__Warn_fn));
    console->Item(::STRINGS[34/*"info"*/], uDelegate::New(::TYPES[25/*Fuse.Scripting.Callback*/], (void*)Console__Info_fn));
    console->Item(::STRINGS[35/*"error"*/], uDelegate::New(::TYPES[25/*Fuse.Scripting.Callback*/], (void*)Console__Error_fn));
    console->Item(::STRINGS[36/*"dir"*/], uDelegate::New(::TYPES[25/*Fuse.Scripting.Callback*/], (void*)Console__Dir_fn));
    uPtr(c->GlobalObject())->Item(::STRINGS[37/*"console"*/], console);
}

// private static object Log(Fuse.Scripting.Context context, object[] args) [static] :45
uObject* Console::Log(::g::Fuse::Scripting::Context* context, uArray* args)
{
    return Console::LogInternal(context, args, 0);
}

// private static object LogInternal(Fuse.Scripting.Context context, object[] args, Uno.Diagnostics.DebugMessageType debugMessageType) [static] :38
uObject* Console::LogInternal(::g::Fuse::Scripting::Context* context, uArray* args, int32_t debugMessageType)
{
    uStackFrame __("Fuse.Reactive.Console", "LogInternal(Fuse.Scripting.Context,object[],Uno.Diagnostics.DebugMessageType)");
    uString* formatted = Console::Format(context, args);
    ::g::Uno::Diagnostics::Debug::Log2(formatted, debugMessageType);
    return NULL;
}

// private static string ToString(Fuse.Scripting.Context context, object obj) [static] :81
uString* Console::ToString(::g::Fuse::Scripting::Context* context, uObject* obj)
{
    uStackFrame __("Fuse.Reactive.Console", "ToString(Fuse.Scripting.Context,object)");

    if (Console::_toStringFunction_ == NULL)
        Console::_toStringFunction_ = uCast< ::g::Fuse::Scripting::Function*>(uPtr(context)->Evaluate(::STRINGS[38/*"fuse-builtins"*/], ::STRINGS[39/*"(function(o...*/]), ::TYPES[22/*Fuse.Scripting.Function*/]);

    return ::g::Uno::Object::ToString(uPtr(uPtr(Console::_toStringFunction_)->Call(context, uArray::Init<uObject*>(::TYPES[4/*object[]*/], 1, obj))));
}

// private static object Warn(Fuse.Scripting.Context context, object[] args) [static] :50
uObject* Console::Warn(::g::Fuse::Scripting::Context* context, uArray* args)
{
    uStackFrame __("Fuse.Reactive.Console", "Warn(Fuse.Scripting.Context,object[])");
    return Console::LogInternal(context, args, 2);
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Expression.uno
// --------------------------------------------------------------------------------------------------

// public sealed class Constant :53
// {
static void Constant_build(uType* type)
{
    ::STRINGS[40] = uString::Const("'");
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::ConstantExpression_type, interface0));
    type->SetFields(0,
        uObject_typeof(), offsetof(Constant, _Value), 0);
    type->Reflection.SetFunctions(2,
        new uFunction(".ctor", NULL, (void*)Constant__New1_fn, 0, true, type, 1, uObject_typeof()),
        new uFunction("get_Value", NULL, (void*)Constant__get_Value_fn, 0, false, uObject_typeof(), 0));
}

::g::Fuse::Reactive::ConstantExpression_type* Constant_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::ConstantExpression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ConstantExpression_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Constant);
    options.TypeSize = sizeof(::g::Fuse::Reactive::ConstantExpression_type);
    type = (::g::Fuse::Reactive::ConstantExpression_type*)uClassType::New("Fuse.Reactive.Constant", options);
    type->fp_build_ = Constant_build;
    type->fp_GetValue = (void(*)(::g::Fuse::Reactive::ConstantExpression*, uObject*, uObject**))Constant__GetValue_fn;
    type->fp_ToString = (void(*)(uObject*, uString**))Constant__ToString_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ConstantExpression__Subscribe_fn;
    return type;
}

// public Constant(object value) :57
void Constant__ctor_2_fn(Constant* __this, uObject* value)
{
    __this->ctor_2(value);
}

// public override sealed object GetValue(Fuse.Reactive.IContext context) :58
void Constant__GetValue_fn(Constant* __this, uObject* context, uObject** __retval)
{
    return *__retval = __this->Value(), void();
}

// public Constant New(object value) :57
void Constant__New1_fn(uObject* value, Constant** __retval)
{
    *__retval = Constant::New1(value);
}

// public override sealed string ToString() :60
void Constant__ToString_fn(Constant* __this, uString** __retval)
{
    uStackFrame __("Fuse.Reactive.Constant", "ToString()");
    return *__retval = ::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::STRINGS[40/*"'"*/], ::g::Uno::Object::ToString(uPtr(__this->Value()))), ::STRINGS[40/*"'"*/]), void();
}

// public generated object get_Value() :55
void Constant__get_Value_fn(Constant* __this, uObject** __retval)
{
    *__retval = __this->Value();
}

// private generated void set_Value(object value) :55
void Constant__set_Value_fn(Constant* __this, uObject* value)
{
    __this->Value(value);
}

// public Constant(object value) [instance] :57
void Constant::ctor_2(uObject* value)
{
    ctor_1();
    Value(value);
}

// public generated object get_Value() [instance] :55
uObject* Constant::Value()
{
    return _Value;
}

// private generated void set_Value(object value) [instance] :55
void Constant::Value(uObject* value)
{
    _Value = value;
}

// public Constant New(object value) [static] :57
Constant* Constant::New1(uObject* value)
{
    Constant* obj1 = (Constant*)uNew(Constant_typeof());
    obj1->ctor_2(value);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Expression.uno
// --------------------------------------------------------------------------------------------------

// public abstract class ConstantExpression :42
// {
static void ConstantExpression_build(uType* type)
{
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(ConstantExpression_type, interface0));
    type->Reflection.SetFunctions(1,
        new uFunction("GetValue", NULL, NULL, offsetof(ConstantExpression_type, fp_GetValue), false, uObject_typeof(), 1, ::g::Fuse::Reactive::IContext_typeof()));
}

ConstantExpression_type* ConstantExpression_typeof()
{
    static uSStrong<ConstantExpression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(ConstantExpression);
    options.TypeSize = sizeof(ConstantExpression_type);
    type = (ConstantExpression_type*)uClassType::New("Fuse.Reactive.ConstantExpression", options);
    type->fp_build_ = ConstantExpression_build;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))ConstantExpression__Subscribe_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))ConstantExpression__Subscribe_fn;
    return type;
}

// protected generated ConstantExpression() :42
void ConstantExpression__ctor_1_fn(ConstantExpression* __this)
{
    __this->ctor_1();
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :46
void ConstantExpression__Subscribe_fn(ConstantExpression* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.ConstantExpression", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)__this, __this->GetValue(context));
    return *__retval = NULL, void();
}

// protected generated ConstantExpression() [instance] :42
void ConstantExpression::ctor_1()
{
    ctor_();
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Cos :204
// {
static void Cos_build(uType* type)
{
    ::STRINGS[41] = uString::Const("cos");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Cos__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Cos_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Cos);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Cos", options);
    type->fp_build_ = Cos_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Cos(Fuse.Reactive.Expression operand) :207
void Cos__ctor_5_fn(Cos* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Cos New(Fuse.Reactive.Expression operand) :207
void Cos__New1_fn(::g::Fuse::Reactive::Expression* operand, Cos** __retval)
{
    *__retval = Cos::New1(operand);
}

// public Cos(Fuse.Reactive.Expression operand) [instance] :207
void Cos::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[41/*"cos"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Cos_fn));
}

// public Cos New(Fuse.Reactive.Expression operand) [static] :207
Cos* Cos::New1(::g::Fuse::Reactive::Expression* operand)
{
    Cos* obj1 = (Cos*)uNew(Cos_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Expression.uno
// --------------------------------------------------------------------------------------------------

// public sealed class Data :66
// {
static void Data_build(uType* type)
{
    ::STRINGS[42] = uString::Const("{");
    ::STRINGS[43] = uString::Const("}");
    ::TYPES[27] = ::g::Fuse::Reactive::IContext_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->SetFields(0,
        ::g::Uno::String_typeof(), offsetof(Data, _Key), 0);
    type->Reflection.SetFunctions(2,
        new uFunction("get_Key", NULL, (void*)Data__get_Key_fn, 0, false, ::g::Uno::String_typeof(), 0),
        new uFunction(".ctor", NULL, (void*)Data__New1_fn, 0, true, type, 1, ::g::Uno::String_typeof()));
}

::g::Fuse::Reactive::Expression_type* Data_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Data);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.Data", options);
    type->fp_build_ = Data_build;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))Data__Subscribe_fn;
    type->fp_ToString = (void(*)(uObject*, uString**))Data__ToString_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))Data__Subscribe_fn;
    return type;
}

// public Data(string key) :70
void Data__ctor_1_fn(Data* __this, uString* key)
{
    __this->ctor_1(key);
}

// public generated string get_Key() :68
void Data__get_Key_fn(Data* __this, uString** __retval)
{
    *__retval = __this->Key();
}

// private generated void set_Key(string value) :68
void Data__set_Key_fn(Data* __this, uString* value)
{
    __this->Key(value);
}

// public Data New(string key) :70
void Data__New1_fn(uString* key, Data** __retval)
{
    *__retval = Data::New1(key);
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :72
void Data__Subscribe_fn(Data* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.Data", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    return *__retval = ::g::Fuse::Reactive::IContext::Subscribe(uInterface(uPtr(context), ::TYPES[27/*Fuse.Reactive.IContext*/]), (uObject*)__this, __this->Key(), listener), void();
}

// public override sealed string ToString() :77
void Data__ToString_fn(Data* __this, uString** __retval)
{
    uStackFrame __("Fuse.Reactive.Data", "ToString()");
    return *__retval = ::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::STRINGS[42/*"{"*/], __this->Key()), ::STRINGS[43/*"}"*/]), void();
}

// public Data(string key) [instance] :70
void Data::ctor_1(uString* key)
{
    ctor_();
    Key(key);
}

// public generated string get_Key() [instance] :68
uString* Data::Key()
{
    return _Key;
}

// private generated void set_Key(string value) [instance] :68
void Data::Key(uString* value)
{
    _Key = value;
}

// public Data New(string key) [static] :70
Data* Data::New1(uString* key)
{
    Data* obj1 = (Data*)uNew(Data_typeof());
    obj1->ctor_1(key);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\DataBinding.uno
// ------------------------------------------------------------------------------------------------

// public class DataBinding :45
// {
static void DataBinding_build(uType* type)
{
    ::STRINGS[26] = uString::Const("");
    ::STRINGS[44] = uString::Const("Cannot bind '");
    ::STRINGS[45] = uString::Const("' to property '");
    ::STRINGS[46] = uString::Const("'. The observable must contain exactly one ");
    ::STRINGS[47] = uString::Const(".");
    ::STRINGS[48] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Bindings\\1.8.1\\DataBinding.uno");
    ::STRINGS[49] = uString::Const("InvalidListOperation");
    ::STRINGS[50] = uString::Const("TryPushAsMarshalledValue");
    ::STRINGS[51] = uString::Const("number");
    ::STRINGS[52] = uString::Const("string");
    ::STRINGS[53] = uString::Const("value that can be converted to type ");
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    ::TYPES[28] = ::g::Fuse::IArray_typeof();
    ::TYPES[29] = ::g::Uno::Type_typeof();
    ::TYPES[30] = ::g::Fuse::Reactive::IObservableArray_typeof();
    ::TYPES[31] = ::g::Uno::UX::Selector_typeof();
    ::TYPES[1] = ::g::Uno::String_typeof();
    ::TYPES[32] = ::g::Uno::Exception_typeof();
    ::TYPES[33] = ::g::Uno::Predicate_typeof()->MakeType(::g::Fuse::Node_typeof(), NULL);
    ::TYPES[34] = ::g::Fuse::Reactive::ISubscription_typeof();
    type->SetDependencies(
        ::g::Fuse::Triggers::BusyTask_typeof(),
        ::g::Fuse::Marshal_typeof(),
        ::g::Fuse::NameRegistry_typeof(),
        ::g::Uno::Type_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IContext_typeof(), offsetof(DataBinding_type, interface0),
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(DataBinding_type, interface1),
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(DataBinding_type, interface2),
        ::g::Fuse::INameListener_typeof(), offsetof(DataBinding_type, interface3),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(DataBinding_type, interface4));
    type->SetFields(3,
        ::g::Fuse::Reactive::BindingMode_typeof(), offsetof(DataBinding, _mode), 0,
        ::g::Fuse::Triggers::BusyTask_typeof(), offsetof(DataBinding, _busyTask), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(DataBinding, _subscription), 0,
        uObject_typeof(), offsetof(DataBinding, _currentValue), 0,
        ::TYPES[1/*string*/], offsetof(DataBinding, _registryName), 0,
        ::g::Uno::UX::Property_typeof(), offsetof(DataBinding, _Target), 0);
    type->Reflection.SetFunctions(2,
        new uFunction(".ctor", NULL, (void*)DataBinding__New1_fn, 0, true, type, 3, ::g::Uno::UX::Property_typeof(), ::g::Fuse::Reactive::IExpression_typeof(), ::g::Fuse::Reactive::BindingMode_typeof()),
        new uFunction("get_Target", NULL, (void*)DataBinding__get_Target_fn, 0, false, ::g::Uno::UX::Property_typeof(), 0));
}

DataBinding_type* DataBinding_typeof()
{
    static uSStrong<DataBinding_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ExpressionBinding_typeof();
    options.FieldCount = 9;
    options.InterfaceCount = 5;
    options.DependencyCount = 4;
    options.ObjectSize = sizeof(DataBinding);
    options.TypeSize = sizeof(DataBinding_type);
    type = (DataBinding_type*)uClassType::New("Fuse.Reactive.DataBinding", options);
    type->fp_build_ = DataBinding_build;
    type->fp_LostValue = (void(*)(::g::Fuse::Reactive::ExpressionBinding*))DataBinding__LostValue_fn;
    type->fp_NewValue = (void(*)(::g::Fuse::Reactive::ExpressionBinding*, uObject*))DataBinding__NewValue_fn;
    type->fp_OnRooted = (void(*)(::g::Fuse::Binding*))DataBinding__OnRooted_fn;
    type->fp_OnUnrooted = (void(*)(::g::Fuse::Binding*))DataBinding__OnUnrooted_fn;
    type->fp_SubscribeResource = (void(*)(::g::Fuse::Reactive::ExpressionBinding*, uObject*, uString*, uObject*, uObject**))DataBinding__SubscribeResource_fn;
    type->interface2.fp_OnClear = (void(*)(uObject*))DataBinding__FuseReactiveIObserverOnClear_fn;
    type->interface2.fp_OnSet = (void(*)(uObject*, uObject*))DataBinding__FuseReactiveIObserverOnSet_fn;
    type->interface2.fp_OnAdd = (void(*)(uObject*, uObject*))DataBinding__FuseReactiveIObserverOnAdd_fn;
    type->interface2.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))DataBinding__FuseReactiveIObserverOnNewAt_fn;
    type->interface2.fp_OnFailed = (void(*)(uObject*, uString*))DataBinding__FuseReactiveIObserverOnFailed_fn;
    type->interface2.fp_OnNewAll = (void(*)(uObject*, uObject*))DataBinding__FuseReactiveIObserverOnNewAll_fn;
    type->interface2.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))DataBinding__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface2.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))DataBinding__FuseReactiveIObserverOnInsertAt_fn;
    type->interface3.fp_OnNameChanged = (void(*)(uObject*, ::g::Fuse::Node*, ::g::Uno::UX::Selector*))DataBinding__FuseINameListenerOnNameChanged_fn;
    type->interface4.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))DataBinding__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIContextSubscribe_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_get_Node = (void(*)(uObject*, ::g::Fuse::Node**))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIContextget_Node_fn;
    type->interface0.fp_SubscribeResource = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))DataBinding__SubscribeResource_fn;
    return type;
}

// public DataBinding(Uno.UX.Property target, Fuse.Reactive.IExpression key, Fuse.Reactive.BindingMode mode) :53
void DataBinding__ctor_2_fn(DataBinding* __this, ::g::Uno::UX::Property* target, uObject* key, int32_t* mode)
{
    __this->ctor_2(target, key, *mode);
}

// private bool Acceptor(object obj) :309
void DataBinding__Acceptor_fn(DataBinding* __this, uObject* obj, bool* __retval)
{
    *__retval = __this->Acceptor(obj);
}

// private void CleanSubscription() :197
void DataBinding__CleanSubscription_fn(DataBinding* __this)
{
    __this->CleanSubscription();
}

// private bool get_Clear() :69
void DataBinding__get_Clear_fn(DataBinding* __this, bool* __retval)
{
    *__retval = __this->Clear();
}

// private void ClearFailed() :138
void DataBinding__ClearFailed_fn(DataBinding* __this)
{
    __this->ClearFailed();
}

// private void ClearValue() :167
void DataBinding__ClearValue_fn(DataBinding* __this)
{
    __this->ClearValue();
}

// private void Fuse.INameListener.OnNameChanged(Fuse.Node obj, Uno.UX.Selector name) :172
void DataBinding__FuseINameListenerOnNameChanged_fn(DataBinding* __this, ::g::Fuse::Node* obj, ::g::Uno::UX::Selector* name)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "Fuse.INameListener.OnNameChanged(Fuse.Node,Uno.UX.Selector)");
    __this->PushValue(__this->_currentValue);
}

// private void Fuse.Reactive.IObserver.OnAdd(object addedValue) :93
void DataBinding__FuseReactiveIObserverOnAdd_fn(DataBinding* __this, uObject* addedValue)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "Fuse.Reactive.IObserver.OnAdd(object)");
    __this->InvalidListOperation();
}

// private void Fuse.Reactive.IObserver.OnClear() :71
void DataBinding__FuseReactiveIObserverOnClear_fn(DataBinding* __this)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "Fuse.Reactive.IObserver.OnClear()");
    __this->ClearValue();
}

// private void Fuse.Reactive.IObserver.OnFailed(string message) :103
void DataBinding__FuseReactiveIObserverOnFailed_fn(DataBinding* __this, uString* message)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "Fuse.Reactive.IObserver.OnFailed(string)");
    __this->ClearValue();
    __this->MarkFailed(message);
}

// private void Fuse.Reactive.IObserver.OnInsertAt(int index, object value) :120
void DataBinding__FuseReactiveIObserverOnInsertAt_fn(DataBinding* __this, int32_t* index, uObject* value)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "Fuse.Reactive.IObserver.OnInsertAt(int,object)");
    __this->InvalidListOperation();
}

// private void Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray values) :109
void DataBinding__FuseReactiveIObserverOnNewAll_fn(DataBinding* __this, uObject* values)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray)");

    if (::g::Fuse::IArray::Length(uInterface(uPtr(values), ::TYPES[28/*Fuse.IArray*/])) > 0)
        __this->InvalidListOperation();
}

// private void Fuse.Reactive.IObserver.OnNewAt(int index, object value) :98
void DataBinding__FuseReactiveIObserverOnNewAt_fn(DataBinding* __this, int32_t* index, uObject* value)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "Fuse.Reactive.IObserver.OnNewAt(int,object)");
    __this->InvalidListOperation();
}

// private void Fuse.Reactive.IObserver.OnRemoveAt(int index) :115
void DataBinding__FuseReactiveIObserverOnRemoveAt_fn(DataBinding* __this, int32_t* index)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "Fuse.Reactive.IObserver.OnRemoveAt(int)");
    __this->InvalidListOperation();
}

// private void Fuse.Reactive.IObserver.OnSet(object newValue) :76
void DataBinding__FuseReactiveIObserverOnSet_fn(DataBinding* __this, uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "Fuse.Reactive.IObserver.OnSet(object)");
    __this->PushValue(newValue);
}

// private void InvalidListOperation() :88
void DataBinding__InvalidListOperation_fn(DataBinding* __this)
{
    __this->InvalidListOperation();
}

// internal override sealed void LostValue() :231
void DataBinding__LostValue_fn(DataBinding* __this)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "LostValue()");
    __this->CleanSubscription();
    __this->ClearValue();
}

// private void MarkFailed(string message) :133
void DataBinding__MarkFailed_fn(DataBinding* __this, uString* message)
{
    __this->MarkFailed(message);
}

// public DataBinding New(Uno.UX.Property target, Fuse.Reactive.IExpression key, Fuse.Reactive.BindingMode mode) :53
void DataBinding__New1_fn(::g::Uno::UX::Property* target, uObject* key, int32_t* mode, DataBinding** __retval)
{
    *__retval = DataBinding::New1(target, key, *mode);
}

// internal override sealed void NewValue(object value) :206
void DataBinding__NewValue_fn(DataBinding* __this, uObject* value)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "NewValue(object)");
    __this->CleanSubscription();

    if (::g::Fuse::Marshal::Is(value, uPtr(__this->Target())->PropertyType()))
        __this->PushValue(value);
    else if (::g::Fuse::Marshal::Is(value, ::TYPES[46/*Fuse.Reactive.IObservable*/]))
    {
        uObject* obs = (uObject*)value;

        if (::g::Fuse::IArray::Length(uInterface(uPtr(obs), ::TYPES[28/*Fuse.IArray*/])) > 0)
            __this->PushValue(::g::Fuse::IArray::Item(uInterface(uPtr(obs), ::TYPES[28/*Fuse.IArray*/]), 0));

        __this->_subscription = ::g::Fuse::Reactive::IObservableArray::Subscribe(uInterface(uPtr(obs), ::TYPES[30/*Fuse.Reactive.IObservableArray*/]), (uObject*)__this);
    }
    else
        __this->PushValue(value);
}

// protected override sealed void OnRooted() :125
void DataBinding__OnRooted_fn(DataBinding* __this)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "OnRooted()");
    ::g::Fuse::Reactive::ExpressionBinding__OnRooted_fn(__this);

    if (__this->Write() && uPtr(__this->Target())->SupportsOriginSetter())
        uPtr(__this->Target())->AddListener((uObject*)__this);
}

// protected override sealed void OnUnrooted() :144
void DataBinding__OnUnrooted_fn(DataBinding* __this)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "OnUnrooted()");
    __this->ClearFailed();
    __this->UnlistenNameRegistry();

    if (__this->Write() && uPtr(__this->Target())->SupportsOriginSetter())
        uPtr(__this->Target())->RemoveListener((uObject*)__this);

    if (__this->_subscription != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(__this->_subscription), ::TYPES[3/*Uno.IDisposable*/]));
        __this->_subscription = NULL;
    }

    __this->ClearValue();
    ::g::Fuse::Reactive::ExpressionBinding__OnUnrooted_fn(__this);
}

// protected void PushValue(object newValue) :239
void DataBinding__PushValue_fn(DataBinding* __this, uObject* newValue)
{
    __this->PushValue(newValue);
}

// private bool get_Read() :67
void DataBinding__get_Read_fn(DataBinding* __this, bool* __retval)
{
    *__retval = __this->Read();
}

// internal void SetTarget(object value) :161
void DataBinding__SetTarget_fn(DataBinding* __this, uObject* value)
{
    __this->SetTarget(value);
}

// public override sealed Uno.IDisposable SubscribeResource(Fuse.Reactive.IExpression source, string key, Fuse.Reactive.IListener listener) :62
void DataBinding__SubscribeResource_fn(DataBinding* __this, uObject* source, uString* key, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "SubscribeResource(Fuse.Reactive.IExpression,string,Fuse.Reactive.IListener)");
    return *__retval = (uObject*)::g::Fuse::Reactive::ResourceSubscription::New1(source, __this->Parent(), key, listener, uPtr(__this->Target())->PropertyType()), void();
}

// public generated Uno.UX.Property get_Target() :48
void DataBinding__get_Target_fn(DataBinding* __this, ::g::Uno::UX::Property** __retval)
{
    *__retval = __this->Target();
}

// private generated void set_Target(Uno.UX.Property value) :48
void DataBinding__set_Target_fn(DataBinding* __this, ::g::Uno::UX::Property* value)
{
    __this->Target(value);
}

// private static Uno.UX.Selector ToSelector(object newValue) :302
void DataBinding__ToSelector_fn(uObject* newValue, ::g::Uno::UX::Selector* __retval)
{
    *__retval = DataBinding::ToSelector(newValue);
}

// private void TryPushAsMarshalledValue(object newValue) :314
void DataBinding__TryPushAsMarshalledValue_fn(DataBinding* __this, uObject* newValue)
{
    __this->TryPushAsMarshalledValue(newValue);
}

// private bool TryPushAsName(object newValue) :273
void DataBinding__TryPushAsName_fn(DataBinding* __this, uObject* newValue, bool* __retval)
{
    *__retval = __this->TryPushAsName(newValue);
}

// private bool TryPushAsValue(object newValue) :251
void DataBinding__TryPushAsValue_fn(DataBinding* __this, uObject* newValue, bool* __retval)
{
    *__retval = __this->TryPushAsValue(newValue);
}

// private static string TypeToJSName(Uno.Type t) :81
void DataBinding__TypeToJSName_fn(uType* t, uString** __retval)
{
    *__retval = DataBinding::TypeToJSName(t);
}

// private void UnlistenNameRegistry() :264
void DataBinding__UnlistenNameRegistry_fn(DataBinding* __this)
{
    __this->UnlistenNameRegistry();
}

// private void Uno.UX.IPropertyListener.OnPropertyChanged(Uno.UX.PropertyObject obj, Uno.UX.Selector prop) :177
void DataBinding__UnoUXIPropertyListenerOnPropertyChanged_fn(DataBinding* __this, ::g::Uno::UX::PropertyObject* obj, ::g::Uno::UX::Selector* prop)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "Uno.UX.IPropertyListener.OnPropertyChanged(Uno.UX.PropertyObject,Uno.UX.Selector)");
    ::g::Uno::UX::Selector prop_ = *prop;

    if (::g::Uno::UX::Selector__op_Equality(prop_, uPtr(__this->Target())->Name()))
    {
        if (__this->_subscription != NULL)
        {
            if (__this->Write())
            {
                uObject* sub = uAs<uObject*>(__this->_subscription, ::TYPES[34/*Fuse.Reactive.ISubscription*/]);

                if (sub != NULL)
                    ::g::Fuse::Reactive::ISubscription::SetExclusive(uInterface(uPtr(sub), ::TYPES[34/*Fuse.Reactive.ISubscription*/]), uPtr(__this->Target())->GetAsObject1());
            }
        }
        else if (__this->CanWriteBack())
            __this->WriteBack(uPtr(__this->Target())->GetAsObject1());
    }
}

// private bool get_Write() :68
void DataBinding__get_Write_fn(DataBinding* __this, bool* __retval)
{
    *__retval = __this->Write();
}

// public DataBinding(Uno.UX.Property target, Fuse.Reactive.IExpression key, Fuse.Reactive.BindingMode mode) [instance] :53
void DataBinding::ctor_2(::g::Uno::UX::Property* target, uObject* key, int32_t mode)
{
    ctor_1(key);
    _mode = mode;
    Target(target);
}

// private bool Acceptor(object obj) [instance] :309
bool DataBinding::Acceptor(uObject* obj)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "Acceptor(object)");
    return ::g::Fuse::Marshal::Is(obj, uPtr(Target())->PropertyType());
}

// private void CleanSubscription() [instance] :197
void DataBinding::CleanSubscription()
{
    uStackFrame __("Fuse.Reactive.DataBinding", "CleanSubscription()");

    if (_subscription != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_subscription), ::TYPES[3/*Uno.IDisposable*/]));
        _subscription = NULL;
    }
}

// private bool get_Clear() [instance] :69
bool DataBinding::Clear()
{
    return (_mode & 4) == 4;
}

// private void ClearFailed() [instance] :138
void DataBinding::ClearFailed()
{
    uStackFrame __("Fuse.Reactive.DataBinding", "ClearFailed()");

    if (Parent() != NULL)
        ::g::Fuse::Triggers::BusyTask::SetBusy(Parent(), &_busyTask, 0, ::STRINGS[26/*""*/]);
}

// private void ClearValue() [instance] :167
void DataBinding::ClearValue()
{
    uStackFrame __("Fuse.Reactive.DataBinding", "ClearValue()");

    if (Clear())
        SetTarget(NULL);
}

// private void InvalidListOperation() [instance] :88
void DataBinding::InvalidListOperation()
{
    uStackFrame __("Fuse.Reactive.DataBinding", "InvalidListOperation()");
    ::g::Fuse::Diagnostics::UserError(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::STRINGS[44/*"Cannot bind '"*/], Key()), ::STRINGS[45/*"' to proper...*/]), ::g::Uno::UX::Selector__op_Implicit1(uPtr(Target())->Name())), ::STRINGS[46/*"'. The obse...*/]), DataBinding::TypeToJSName(uPtr(Target())->PropertyType())), ::STRINGS[47/*"."*/]), this, ::STRINGS[48/*"C:\\Users\\...*/], 90, ::STRINGS[49/*"InvalidList...*/], NULL);
}

// private void MarkFailed(string message) [instance] :133
void DataBinding::MarkFailed(uString* message)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "MarkFailed(string)");
    ::g::Fuse::Triggers::BusyTask::SetBusy(Parent(), &_busyTask, 16, message);
}

// protected void PushValue(object newValue) [instance] :239
void DataBinding::PushValue(uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "PushValue(object)");

    if (!Read())
        return;

    if (Parent() == NULL)
        return;

    _currentValue = newValue;

    if (TryPushAsValue(newValue))
        return;
    else if (TryPushAsName(newValue))
        return;
    else
        TryPushAsMarshalledValue(newValue);
}

// private bool get_Read() [instance] :67
bool DataBinding::Read()
{
    return (_mode & 1) == 1;
}

// internal void SetTarget(object value) [instance] :161
void DataBinding::SetTarget(uObject* value)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "SetTarget(object)");
    ClearFailed();
    uPtr(Target())->SetAsObject1(value, (uObject*)this);
}

// public generated Uno.UX.Property get_Target() [instance] :48
::g::Uno::UX::Property* DataBinding::Target()
{
    return _Target;
}

// private generated void set_Target(Uno.UX.Property value) [instance] :48
void DataBinding::Target(::g::Uno::UX::Property* value)
{
    _Target = value;
}

// private void TryPushAsMarshalledValue(object newValue) [instance] :314
void DataBinding::TryPushAsMarshalledValue(uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "TryPushAsMarshalledValue(object)");
    uObject* res;

    if (::g::Fuse::Marshal::TryConvertTo(uPtr(Target())->PropertyType(), newValue, &res, this))
    {
        try
        {
            {
                SetTarget(res);
            }
        }

        catch (const uThrowable& __t)
        {
            ::g::Uno::Exception* e = __t.Exception;
            MarkFailed(uPtr(e)->ToString());
            ::g::Fuse::Diagnostics::UserError(e->ToString(), Target(), ::STRINGS[48/*"C:\\Users\\...*/], 327, ::STRINGS[50/*"TryPushAsMa...*/], NULL);
        }
    }
}

// private bool TryPushAsName(object newValue) [instance] :273
bool DataBinding::TryPushAsName(uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "TryPushAsName(object)");
    ::g::Uno::UX::Selector name = DataBinding::ToSelector(newValue);

    if (!name.IsNull())
    {
        UnlistenNameRegistry();
        _registryName = ::g::Uno::UX::Selector__op_Implicit1(name);
        ::g::Fuse::NameRegistry::AddListener(::g::Uno::UX::Selector__op_Implicit(_registryName), (uObject*)this);
        ::g::Fuse::Node* k = uPtr(Parent())->FindNodeByName(name, uDelegate::New(::TYPES[33/*Uno.Predicate<Fuse.Node>*/], (void*)DataBinding__Acceptor_fn, this));

        if (k != NULL)
        {
            SetTarget(k);
            return true;
        }

        if (::g::Uno::Type::IsClass(uPtr(uPtr(Target())->PropertyType())) && !::g::Fuse::Marshal::CanConvertClass(uPtr(Target())->PropertyType()))
            return true;
    }

    return false;
}

// private bool TryPushAsValue(object newValue) [instance] :251
bool DataBinding::TryPushAsValue(uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "TryPushAsValue(object)");

    if (::g::Fuse::Marshal::Is(newValue, uPtr(Target())->PropertyType()))
    {
        UnlistenNameRegistry();
        SetTarget(newValue);
        return true;
    }

    return false;
}

// private void UnlistenNameRegistry() [instance] :264
void DataBinding::UnlistenNameRegistry()
{
    uStackFrame __("Fuse.Reactive.DataBinding", "UnlistenNameRegistry()");

    if (::g::Uno::String::op_Inequality(_registryName, NULL))
    {
        ::g::Fuse::NameRegistry::RemoveListener1(::g::Uno::UX::Selector__op_Implicit(_registryName), (uObject*)this);
        _registryName = NULL;
    }
}

// private bool get_Write() [instance] :68
bool DataBinding::Write()
{
    return (_mode & 2) == 2;
}

// public DataBinding New(Uno.UX.Property target, Fuse.Reactive.IExpression key, Fuse.Reactive.BindingMode mode) [static] :53
DataBinding* DataBinding::New1(::g::Uno::UX::Property* target, uObject* key, int32_t mode)
{
    DataBinding* obj1 = (DataBinding*)uNew(DataBinding_typeof());
    obj1->ctor_2(target, key, mode);
    return obj1;
}

// private static Uno.UX.Selector ToSelector(object newValue) [static] :302
::g::Uno::UX::Selector DataBinding::ToSelector(uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "ToSelector(object)");
    return uIs(newValue, ::TYPES[31/*Uno.UX.Selector*/]) ? uUnbox< ::g::Uno::UX::Selector>(::TYPES[31/*Uno.UX.Selector*/], newValue) : uIs(newValue, ::TYPES[1/*string*/]) ? ::g::Uno::UX::Selector__New1(uCast<uString*>(newValue, ::TYPES[1/*string*/])) : uDefault< ::g::Uno::UX::Selector>();
}

// private static string TypeToJSName(Uno.Type t) [static] :81
uString* DataBinding::TypeToJSName(uType* t)
{
    uStackFrame __("Fuse.Reactive.DataBinding", "TypeToJSName(Uno.Type)");

    if ((::g::Uno::Type::op_Equality(t, ::TYPES[20/*int*/]) || ::g::Uno::Type::op_Equality(t, ::TYPES[21/*float*/])) || ::g::Uno::Type::op_Equality(t, ::TYPES[14/*double*/]))
        return ::STRINGS[51/*"number"*/];

    if (::g::Uno::Type::op_Equality(t, ::TYPES[1/*string*/]))
        return ::STRINGS[52/*"string"*/];

    return ::g::Uno::String::op_Addition2(::STRINGS[53/*"value that ...*/], ::g::Uno::Type::FullName(uPtr(t)));
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\DataFunction.uno
// -------------------------------------------------------------------------------------------------

// public sealed class DataFunction :21
// {
static void DataFunction_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)DataFunction__New1_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::Expression_type* DataFunction_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(DataFunction);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.DataFunction", options);
    type->fp_build_ = DataFunction_build;
    type->fp_ctor_ = (void*)DataFunction__New1_fn;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))DataFunction__Subscribe_fn;
    type->fp_ToString = (void(*)(uObject*, uString**))DataFunction__ToString_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))DataFunction__Subscribe_fn;
    return type;
}

// public DataFunction() :24
void DataFunction__ctor_1_fn(DataFunction* __this)
{
    __this->ctor_1();
}

// public DataFunction New() :24
void DataFunction__New1_fn(DataFunction** __retval)
{
    *__retval = DataFunction::New1();
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :33
void DataFunction__Subscribe_fn(DataFunction* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.DataFunction", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    DataFunction__Subscription* sub = DataFunction__Subscription::New1(__this, listener, ::g::Fuse::Reactive::IContext::Node(uInterface(uPtr(context), ::TYPES[27/*Fuse.Reactive.IContext*/])));
    sub->Init();
    return *__retval = (uObject*)sub, void();
}

// public override sealed string ToString() :28
void DataFunction__ToString_fn(DataFunction* __this, uString** __retval)
{
    return *__retval = uString::Const("data()"), void();
}

// public DataFunction() [instance] :24
void DataFunction::ctor_1()
{
    ctor_();
}

// public DataFunction New() [static] :24
DataFunction* DataFunction::New1()
{
    DataFunction* obj1 = (DataFunction*)uNew(DataFunction_typeof());
    obj1->ctor_1();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Subscription\DataSubscription.uno
// ------------------------------------------------------------------------------------------------------------------

// internal sealed class DataSubscription :6
// {
static void DataSubscription_build(uType* type)
{
    ::STRINGS[42] = uString::Const("{");
    ::STRINGS[54] = uString::Const("} not found in data context");
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    ::TYPES[35] = ::g::Fuse::Reactive::IObservableObject_typeof();
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    ::TYPES[36] = ::g::Fuse::Reactive::IPropertySubscription_typeof();
    type->SetInterfaces(
        ::TYPES[3/*Uno.IDisposable*/], offsetof(DataSubscription_type, interface0),
        ::g::Fuse::Node__IDataListener_typeof(), offsetof(DataSubscription_type, interface1),
        ::g::Fuse::Reactive::IPropertyObserver_typeof(), offsetof(DataSubscription_type, interface2),
        ::g::Fuse::Reactive::IWriteable_typeof(), offsetof(DataSubscription_type, interface3));
    type->SetFields(0,
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(DataSubscription, _source), 0,
        ::g::Fuse::Node_typeof(), offsetof(DataSubscription, _origin), 0,
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(DataSubscription, _listener), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(DataSubscription, _diag), 0,
        ::g::Uno::String_typeof(), offsetof(DataSubscription, _key), 0,
        ::g::Fuse::Node__NodeDataSubscription_typeof(), offsetof(DataSubscription, _dataSub), 0,
        ::g::Uno::Bool_typeof(), offsetof(DataSubscription, _isResolved), 0,
        ::g::Uno::Bool_typeof(), offsetof(DataSubscription, _hasData), 0,
        uObject_typeof(), offsetof(DataSubscription, _currentData), 0,
        ::TYPES[36/*Fuse.Reactive.IPropertySubscription*/], offsetof(DataSubscription, _sub), 0);
}

DataSubscription_type* DataSubscription_typeof()
{
    static uSStrong<DataSubscription_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 10;
    options.InterfaceCount = 4;
    options.ObjectSize = sizeof(DataSubscription);
    options.TypeSize = sizeof(DataSubscription_type);
    type = (DataSubscription_type*)uClassType::New("Fuse.Reactive.DataSubscription", options);
    type->fp_build_ = DataSubscription_build;
    type->interface3.fp_TrySetExclusive = (void(*)(uObject*, uObject*, bool*))DataSubscription__FuseReactiveIWriteableTrySetExclusive_fn;
    type->interface2.fp_OnPropertyChanged = (void(*)(uObject*, uObject*, uString*, uObject*))DataSubscription__FuseReactiveIPropertyObserverOnPropertyChanged_fn;
    type->interface1.fp_OnDataChanged = (void(*)(uObject*))DataSubscription__FuseNodeIDataListenerOnDataChanged_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))DataSubscription__Dispose_fn;
    return type;
}

// public DataSubscription(Fuse.Reactive.IExpression source, Fuse.Node origin, string key, Fuse.Reactive.IListener listener) :15
void DataSubscription__ctor__fn(DataSubscription* __this, uObject* source, ::g::Fuse::Node* origin, uString* key, uObject* listener)
{
    __this->ctor_(source, origin, key, listener);
}

// private void ClearDiagnostic() :120
void DataSubscription__ClearDiagnostic_fn(DataSubscription* __this)
{
    __this->ClearDiagnostic();
}

// public void Dispose() :101
void DataSubscription__Dispose_fn(DataSubscription* __this)
{
    __this->Dispose();
}

// private void DisposeSubscription() :59
void DataSubscription__DisposeSubscription_fn(DataSubscription* __this)
{
    __this->DisposeSubscription();
}

// private void FindData() :29
void DataSubscription__FindData_fn(DataSubscription* __this)
{
    __this->FindData();
}

// private void Fuse.Node.IDataListener.OnDataChanged() :115
void DataSubscription__FuseNodeIDataListenerOnDataChanged_fn(DataSubscription* __this)
{
    uStackFrame __("Fuse.Reactive.DataSubscription", "Fuse.Node.IDataListener.OnDataChanged()");
    __this->FindData();
}

// private void Fuse.Reactive.IPropertyObserver.OnPropertyChanged(Uno.IDisposable sub, string propertyName, object newValue) :83
void DataSubscription__FuseReactiveIPropertyObserverOnPropertyChanged_fn(DataSubscription* __this, uObject* sub, uString* propertyName, uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.DataSubscription", "Fuse.Reactive.IPropertyObserver.OnPropertyChanged(Uno.IDisposable,string,object)");

    if (sub != __this->_sub)
        return;

    if (::g::Uno::String::op_Inequality(propertyName, __this->_key))
        return;

    __this->ResolveInner(newValue);
}

// private bool Fuse.Reactive.IWriteable.TrySetExclusive(object newValue) :68
void DataSubscription__FuseReactiveIWriteableTrySetExclusive_fn(DataSubscription* __this, uObject* newValue, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.DataSubscription", "Fuse.Reactive.IWriteable.TrySetExclusive(object)");
    uObject* w = uAs<uObject*>(__this->_sub, ::TYPES[36/*Fuse.Reactive.IPropertySubscription*/]);

    if (w != NULL)
    {
        if (::g::Fuse::Reactive::IPropertySubscription::TrySetExclusive(uInterface(uPtr(w), ::TYPES[36/*Fuse.Reactive.IPropertySubscription*/]), __this->_key, newValue))
        {
            __this->_currentData = newValue;
            return *__retval = true, void();
        }
    }

    return *__retval = false, void();
}

// public DataSubscription New(Fuse.Reactive.IExpression source, Fuse.Node origin, string key, Fuse.Reactive.IListener listener) :15
void DataSubscription__New1_fn(uObject* source, ::g::Fuse::Node* origin, uString* key, uObject* listener, DataSubscription** __retval)
{
    *__retval = DataSubscription::New1(source, origin, key, listener);
}

// private void ResolveInner(object data) :90
void DataSubscription__ResolveInner_fn(DataSubscription* __this, uObject* data)
{
    __this->ResolveInner(data);
}

// public DataSubscription(Fuse.Reactive.IExpression source, Fuse.Node origin, string key, Fuse.Reactive.IListener listener) [instance] :15
void DataSubscription::ctor_(uObject* source, ::g::Fuse::Node* origin, uString* key, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.DataSubscription", ".ctor(Fuse.Reactive.IExpression,Fuse.Node,string,Fuse.Reactive.IListener)");
    _key = key;
    _source = source;
    _origin = origin;
    _listener = listener;
    _dataSub = uPtr(_origin)->SubscribeData(key, (uObject*)this);
    FindData();
}

// private void ClearDiagnostic() [instance] :120
void DataSubscription::ClearDiagnostic()
{
    uStackFrame __("Fuse.Reactive.DataSubscription", "ClearDiagnostic()");

    if (_diag != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_diag), ::TYPES[3/*Uno.IDisposable*/]));
        _diag = NULL;
    }
}

// public void Dispose() [instance] :101
void DataSubscription::Dispose()
{
    uStackFrame __("Fuse.Reactive.DataSubscription", "Dispose()");
    DisposeSubscription();
    ClearDiagnostic();
    _origin = NULL;
    _source = NULL;
    _listener = NULL;

    if (_dataSub != NULL)
    {
        uPtr(_dataSub)->Dispose();
        _dataSub = NULL;
    }
}

// private void DisposeSubscription() [instance] :59
void DataSubscription::DisposeSubscription()
{
    uStackFrame __("Fuse.Reactive.DataSubscription", "DisposeSubscription()");

    if (_sub != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_sub), ::TYPES[3/*Uno.IDisposable*/]));
        _sub = NULL;
    }
}

// private void FindData() [instance] :29
void DataSubscription::FindData()
{
    uStackFrame __("Fuse.Reactive.DataSubscription", "FindData()");

    if (_dataSub == NULL)
        return;

    ClearDiagnostic();
    DisposeSubscription();
    _isResolved = false;

    if (uPtr(_dataSub)->HasData())
    {
        uObject* obs = uAs<uObject*>(uPtr(_dataSub)->Provider(), ::TYPES[35/*Fuse.Reactive.IObservableObject*/]);

        if (obs != NULL)
            _sub = ::g::Fuse::Reactive::IObservableObject::Subscribe(uInterface(uPtr(obs), ::TYPES[35/*Fuse.Reactive.IObservableObject*/]), (uObject*)this);

        ResolveInner(uPtr(_dataSub)->Data());
    }
    else
    {
        _diag = ::g::Fuse::Diagnostics::ReportTemporalUserWarning(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::STRINGS[42/*"{"*/], _key), ::STRINGS[54/*"} not found...*/]), _origin);

        if (_hasData)
        {
            ::g::Fuse::Reactive::IListener::OnLostData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), _source);
            _hasData = false;
        }
    }
}

// private void ResolveInner(object data) [instance] :90
void DataSubscription::ResolveInner(uObject* data)
{
    uStackFrame __("Fuse.Reactive.DataSubscription", "ResolveInner(object)");
    _isResolved = true;

    if ((data != _currentData) || !_hasData)
    {
        _hasData = true;
        _currentData = data;
        ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), _source, data);
    }
}

// public DataSubscription New(Fuse.Reactive.IExpression source, Fuse.Node origin, string key, Fuse.Reactive.IListener listener) [static] :15
DataSubscription* DataSubscription::New1(uObject* source, ::g::Fuse::Node* origin, uString* key, uObject* listener)
{
    DataSubscription* obj1 = (DataSubscription*)uNew(DataSubscription_typeof());
    obj1->ctor_(source, origin, key, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\DataToResource.uno
// ------------------------------------------------------------------------------------------------------

// public sealed class DataToResource :33
// {
static void DataToResource_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->SetFields(0,
        ::g::Fuse::Reactive::Expression_typeof(), offsetof(DataToResource, _data), 0);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)DataToResource__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::Expression_type* DataToResource_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(DataToResource);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.DataToResource", options);
    type->fp_build_ = DataToResource_build;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))DataToResource__Subscribe_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))DataToResource__Subscribe_fn;
    return type;
}

// public DataToResource(Fuse.Reactive.Expression data) :37
void DataToResource__ctor_1_fn(DataToResource* __this, ::g::Fuse::Reactive::Expression* data)
{
    __this->ctor_1(data);
}

// public DataToResource New(Fuse.Reactive.Expression data) :37
void DataToResource__New1_fn(::g::Fuse::Reactive::Expression* data, DataToResource** __retval)
{
    *__retval = DataToResource::New1(data);
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :42
void DataToResource__Subscribe_fn(DataToResource* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.DataToResource", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    DataToResource__DataToResourceSubscription* dtr = DataToResource__DataToResourceSubscription::New1(__this, context, listener);
    dtr->Init(context);
    return *__retval = (uObject*)dtr, void();
}

// public DataToResource(Fuse.Reactive.Expression data) [instance] :37
void DataToResource::ctor_1(::g::Fuse::Reactive::Expression* data)
{
    ctor_();
    _data = data;
}

// public DataToResource New(Fuse.Reactive.Expression data) [static] :37
DataToResource* DataToResource::New1(::g::Fuse::Reactive::Expression* data)
{
    DataToResource* obj1 = (DataToResource*)uNew(DataToResource_typeof());
    obj1->ctor_1(data);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\DataToResource.uno
// ------------------------------------------------------------------------------------------------------

// private sealed class DataToResource.DataToResourceSubscription :49
// {
static void DataToResource__DataToResourceSubscription_build(uType* type)
{
    ::TYPES[10] = ::g::Fuse::Reactive::Expression_typeof()->Array();
    ::TYPES[27] = ::g::Fuse::Reactive::IContext_typeof();
    ::TYPES[1] = ::g::Uno::String_typeof();
    ::TYPES[37] = ::g::Uno::Action_typeof();
    type->SetDependencies(
        ::g::Fuse::Resources::ResourceRegistry_typeof());
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(::g::Fuse::Reactive::ExpressionListener_type, interface0),
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(::g::Fuse::Reactive::ExpressionListener_type, interface1));
    type->SetFields(9,
        ::g::Fuse::Node_typeof(), offsetof(DataToResource__DataToResourceSubscription, _node), 0,
        ::TYPES[1/*string*/], offsetof(DataToResource__DataToResourceSubscription, _key), 0);
}

::g::Fuse::Reactive::ExpressionListener_type* DataToResource__DataToResourceSubscription_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::ExpressionListener_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ExpressionListener_typeof();
    options.FieldCount = 11;
    options.InterfaceCount = 2;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(DataToResource__DataToResourceSubscription);
    options.TypeSize = sizeof(::g::Fuse::Reactive::ExpressionListener_type);
    type = (::g::Fuse::Reactive::ExpressionListener_type*)uClassType::New("Fuse.Reactive.DataToResource.DataToResourceSubscription", options);
    type->fp_build_ = DataToResource__DataToResourceSubscription_build;
    type->fp_Dispose = (void(*)(::g::Fuse::Reactive::InnerListener*))DataToResource__DataToResourceSubscription__Dispose_fn;
    type->fp_OnArguments = (void(*)(::g::Fuse::Reactive::ExpressionSubscriber*, uArray*))DataToResource__DataToResourceSubscription__OnArguments_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))DataToResource__DataToResourceSubscription__Dispose_fn;
    return type;
}

// public DataToResourceSubscription(Fuse.Reactive.DataToResource dtr, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :52
void DataToResource__DataToResourceSubscription__ctor_3_fn(DataToResource__DataToResourceSubscription* __this, ::g::Fuse::Reactive::DataToResource* dtr, uObject* context, uObject* listener)
{
    __this->ctor_3(dtr, context, listener);
}

// public override sealed void Dispose() :58
void DataToResource__DataToResourceSubscription__Dispose_fn(DataToResource__DataToResourceSubscription* __this)
{
    ::g::Fuse::Reactive::ExpressionListener__Dispose_fn(__this);
    __this->_node = NULL;
    __this->Unsubscribe();
}

// public DataToResourceSubscription New(Fuse.Reactive.DataToResource dtr, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :52
void DataToResource__DataToResourceSubscription__New1_fn(::g::Fuse::Reactive::DataToResource* dtr, uObject* context, uObject* listener, DataToResource__DataToResourceSubscription** __retval)
{
    *__retval = DataToResource__DataToResourceSubscription::New1(dtr, context, listener);
}

// protected override sealed void OnArguments(Fuse.Reactive.Expression.Argument[] args) :67
void DataToResource__DataToResourceSubscription__OnArguments_fn(DataToResource__DataToResourceSubscription* __this, uArray* args)
{
    uStackFrame __("Fuse.Reactive.DataToResource.DataToResourceSubscription", "OnArguments(Fuse.Reactive.Expression.Argument[])");
    __this->Unsubscribe();
    __this->_key = uAs<uString*>(uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(0))->Value(), ::TYPES[1/*string*/]);
    __this->Subscribe();
    __this->OnChanged();
}

// private void OnChanged() :87
void DataToResource__DataToResourceSubscription__OnChanged_fn(DataToResource__DataToResourceSubscription* __this)
{
    __this->OnChanged();
}

// private void Subscribe() :75
void DataToResource__DataToResourceSubscription__Subscribe_fn(DataToResource__DataToResourceSubscription* __this)
{
    __this->Subscribe();
}

// private void Unsubscribe() :81
void DataToResource__DataToResourceSubscription__Unsubscribe_fn(DataToResource__DataToResourceSubscription* __this)
{
    __this->Unsubscribe();
}

// public DataToResourceSubscription(Fuse.Reactive.DataToResource dtr, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) [instance] :52
void DataToResource__DataToResourceSubscription::ctor_3(::g::Fuse::Reactive::DataToResource* dtr, uObject* context, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.DataToResource.DataToResourceSubscription", ".ctor(Fuse.Reactive.DataToResource,Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    ctor_2(dtr, listener, uArray::Init< ::g::Fuse::Reactive::Expression*>(::TYPES[10/*Fuse.Reactive.Expression[]*/], 1, (::g::Fuse::Reactive::Expression*)uPtr(dtr)->_data), 0);
    _node = ::g::Fuse::Reactive::IContext::Node(uInterface(uPtr(context), ::TYPES[27/*Fuse.Reactive.IContext*/]));
}

// private void OnChanged() [instance] :87
void DataToResource__DataToResourceSubscription::OnChanged()
{
    uStackFrame __("Fuse.Reactive.DataToResource.DataToResourceSubscription", "OnChanged()");
    uObject* v = NULL;

    if ((::g::Uno::String::op_Inequality(_key, NULL) && (_node != NULL)) && uPtr(_node)->TryGetResource(_key, NULL, &v))
        SetData(v);
    else
        ClearData();
}

// private void Subscribe() [instance] :75
void DataToResource__DataToResourceSubscription::Subscribe()
{
    uStackFrame __("Fuse.Reactive.DataToResource.DataToResourceSubscription", "Subscribe()");

    if (::g::Uno::String::op_Inequality(_key, NULL))
        ::g::Fuse::Resources::ResourceRegistry::AddResourceChangedHandler(_key, uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)DataToResource__DataToResourceSubscription__OnChanged_fn, this));
}

// private void Unsubscribe() [instance] :81
void DataToResource__DataToResourceSubscription::Unsubscribe()
{
    uStackFrame __("Fuse.Reactive.DataToResource.DataToResourceSubscription", "Unsubscribe()");

    if (::g::Uno::String::op_Inequality(_key, NULL))
        ::g::Fuse::Resources::ResourceRegistry::RemoveResourceChangedHandler(_key, uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)DataToResource__DataToResourceSubscription__OnChanged_fn, this));
}

// public DataToResourceSubscription New(Fuse.Reactive.DataToResource dtr, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) [static] :52
DataToResource__DataToResourceSubscription* DataToResource__DataToResourceSubscription::New1(::g::Fuse::Reactive::DataToResource* dtr, uObject* context, uObject* listener)
{
    DataToResource__DataToResourceSubscription* obj1 = (DataToResource__DataToResourceSubscription*)uNew(DataToResource__DataToResourceSubscription_typeof());
    obj1->ctor_3(dtr, context, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Scripting.JavaScript\1.8.1\FuseJS\DebugLog.uno
// -------------------------------------------------------------------------------------------------------

// internal static class DebugLog :6
// {
static void DebugLog_build(uType* type)
{
    ::STRINGS[55] = uString::Const("debug_log");
    ::STRINGS[22] = uString::Const("null");
    ::STRINGS[21] = uString::Const("C:/Users/borde_000/AppData/Local/Fusetools/Packages/Fuse.Scripting.JavaScript/1.8.1/FuseJS/DebugLog.uno");
    ::TYPES[25] = ::g::Fuse::Scripting::Callback_typeof();
    type->SetDependencies(
        ::g::Uno::Diagnostics::Debug_typeof());
}

uClassType* DebugLog_typeof()
{
    static uSStrong<uClassType*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.DependencyCount = 1;
    options.TypeSize = sizeof(uClassType);
    type = uClassType::New("Fuse.Reactive.DebugLog", options);
    type->fp_build_ = DebugLog_build;
    return type;
}

// public static void Init(Fuse.Scripting.Context c) :8
void DebugLog__Init_fn(::g::Fuse::Scripting::Context* c)
{
    DebugLog::Init(c);
}

// private static object Log(Fuse.Scripting.Context context, object[] args) :13
void DebugLog__Log_fn(::g::Fuse::Scripting::Context* context, uArray* args, uObject** __retval)
{
    *__retval = DebugLog::Log(context, args);
}

// public static void Init(Fuse.Scripting.Context c) [static] :8
void DebugLog::Init(::g::Fuse::Scripting::Context* c)
{
    uStackFrame __("Fuse.Reactive.DebugLog", "Init(Fuse.Scripting.Context)");
    uPtr(uPtr(c)->GlobalObject())->Item(::STRINGS[55/*"debug_log"*/], uDelegate::New(::TYPES[25/*Fuse.Scripting.Callback*/], (void*)DebugLog__Log_fn));
}

// private static object Log(Fuse.Scripting.Context context, object[] args) [static] :13
uObject* DebugLog::Log(::g::Fuse::Scripting::Context* context, uArray* args)
{
    uStackFrame __("Fuse.Reactive.DebugLog", "Log(Fuse.Scripting.Context,object[])");

    for (int32_t i = 0; i < uPtr(args)->Length(); i++)
        ::g::Uno::Diagnostics::Debug::Log3((uPtr(args)->Strong<uObject*>(i) != NULL) ? (uString*)::g::Uno::Object::ToString(uPtr(uPtr(args)->Strong<uObject*>(i))) : ::STRINGS[22/*"null"*/], 0, ::STRINGS[21/*"C:/Users/bo...*/], 17);

    return NULL;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class DegreesToRadians :319
// {
static void DegreesToRadians_build(uType* type)
{
    ::STRINGS[56] = uString::Const("degreesToRadians");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)DegreesToRadians__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* DegreesToRadians_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(DegreesToRadians);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.DegreesToRadians", options);
    type->fp_build_ = DegreesToRadians_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public DegreesToRadians(Fuse.Reactive.Expression operand) :322
void DegreesToRadians__ctor_5_fn(DegreesToRadians* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public DegreesToRadians New(Fuse.Reactive.Expression operand) :322
void DegreesToRadians__New1_fn(::g::Fuse::Reactive::Expression* operand, DegreesToRadians** __retval)
{
    *__retval = DegreesToRadians::New1(operand);
}

// public DegreesToRadians(Fuse.Reactive.Expression operand) [instance] :322
void DegreesToRadians::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[56/*"degreesToRa...*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__DegreesToRadians_fn));
}

// public DegreesToRadians New(Fuse.Reactive.Expression operand) [static] :322
DegreesToRadians* DegreesToRadians::New1(::g::Fuse::Reactive::Expression* operand)
{
    DegreesToRadians* obj1 = (DegreesToRadians*)uNew(DegreesToRadians_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Scripting.JavaScript\1.8.1\JavaScript.Dependencies.uno
// ---------------------------------------------------------------------------------------------------------------

// public sealed class JavaScript.Dependency :12
// {
static void JavaScript__Dependency_build(uType* type)
{
    ::TYPES[38] = ::g::Fuse::Reactive::IExpression_typeof();
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(JavaScript__Dependency_type, interface0));
    type->SetFields(0,
        ::g::Fuse::Reactive::JavaScript_typeof(), offsetof(JavaScript__Dependency, _script), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(JavaScript__Dependency, _expSubscription), 0,
        ::g::Uno::Bool_typeof(), offsetof(JavaScript__Dependency, HasValue), 0,
        uObject_typeof(), offsetof(JavaScript__Dependency, Value), 0,
        ::TYPES[38/*Fuse.Reactive.IExpression*/], offsetof(JavaScript__Dependency, _Expression), 0,
        ::g::Uno::String_typeof(), offsetof(JavaScript__Dependency, _Name), 0);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)JavaScript__Dependency__New1_fn, 0, true, type, 2, ::g::Uno::String_typeof(), ::TYPES[38/*Fuse.Reactive.IExpression*/]));
}

JavaScript__Dependency_type* JavaScript__Dependency_typeof()
{
    static uSStrong<JavaScript__Dependency_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 6;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(JavaScript__Dependency);
    options.TypeSize = sizeof(JavaScript__Dependency_type);
    type = (JavaScript__Dependency_type*)uClassType::New("Fuse.Reactive.JavaScript.Dependency", options);
    type->fp_build_ = JavaScript__Dependency_build;
    type->interface0.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))JavaScript__Dependency__FuseReactiveIListenerOnNewData_fn;
    type->interface0.fp_OnLostData = (void(*)(uObject*, uObject*))JavaScript__Dependency__FuseReactiveIListenerOnLostData_fn;
    return type;
}

// public Dependency(string name, Fuse.Reactive.IExpression expression) :18
void JavaScript__Dependency__ctor__fn(JavaScript__Dependency* __this, uString* name, uObject* expression)
{
    __this->ctor_(name, expression);
}

// internal generated Fuse.Reactive.IExpression get_Expression() :15
void JavaScript__Dependency__get_Expression_fn(JavaScript__Dependency* __this, uObject** __retval)
{
    *__retval = __this->Expression();
}

// private generated void set_Expression(Fuse.Reactive.IExpression value) :15
void JavaScript__Dependency__set_Expression_fn(JavaScript__Dependency* __this, uObject* value)
{
    __this->Expression(value);
}

// private void Fuse.Reactive.IListener.OnLostData(Fuse.Reactive.IExpression source) :59
void JavaScript__Dependency__FuseReactiveIListenerOnLostData_fn(JavaScript__Dependency* __this, uObject* source)
{
}

// private void Fuse.Reactive.IListener.OnNewData(Fuse.Reactive.IExpression source, object data) :49
void JavaScript__Dependency__FuseReactiveIListenerOnNewData_fn(JavaScript__Dependency* __this, uObject* source, uObject* data)
{
    uStackFrame __("Fuse.Reactive.JavaScript.Dependency", "Fuse.Reactive.IListener.OnNewData(Fuse.Reactive.IExpression,object)");

    if (__this->_script == NULL)
        return;

    __this->Value = data;
    __this->HasValue = true;
    uPtr(__this->_script)->DispatchEvaluateIfDependenciesReady();
}

// internal generated string get_Name() :14
void JavaScript__Dependency__get_Name_fn(JavaScript__Dependency* __this, uString** __retval)
{
    *__retval = __this->Name();
}

// private generated void set_Name(string value) :14
void JavaScript__Dependency__set_Name_fn(JavaScript__Dependency* __this, uString* value)
{
    __this->Name(value);
}

// public Dependency New(string name, Fuse.Reactive.IExpression expression) :18
void JavaScript__Dependency__New1_fn(uString* name, uObject* expression, JavaScript__Dependency** __retval)
{
    *__retval = JavaScript__Dependency::New1(name, expression);
}

// internal void Subscribe(Fuse.Reactive.JavaScript script) :27
void JavaScript__Dependency__Subscribe_fn(JavaScript__Dependency* __this, ::g::Fuse::Reactive::JavaScript* script)
{
    __this->Subscribe(script);
}

// internal void Unsubscribe() :34
void JavaScript__Dependency__Unsubscribe_fn(JavaScript__Dependency* __this)
{
    __this->Unsubscribe();
}

// public Dependency(string name, Fuse.Reactive.IExpression expression) [instance] :18
void JavaScript__Dependency::ctor_(uString* name, uObject* expression)
{
    Name(name);
    Expression(expression);
}

// internal generated Fuse.Reactive.IExpression get_Expression() [instance] :15
uObject* JavaScript__Dependency::Expression()
{
    return _Expression;
}

// private generated void set_Expression(Fuse.Reactive.IExpression value) [instance] :15
void JavaScript__Dependency::Expression(uObject* value)
{
    _Expression = value;
}

// internal generated string get_Name() [instance] :14
uString* JavaScript__Dependency::Name()
{
    return _Name;
}

// private generated void set_Name(string value) [instance] :14
void JavaScript__Dependency::Name(uString* value)
{
    _Name = value;
}

// internal void Subscribe(Fuse.Reactive.JavaScript script) [instance] :27
void JavaScript__Dependency::Subscribe(::g::Fuse::Reactive::JavaScript* script)
{
    uStackFrame __("Fuse.Reactive.JavaScript.Dependency", "Subscribe(Fuse.Reactive.JavaScript)");
    Unsubscribe();
    _script = script;
    _expSubscription = ::g::Fuse::Reactive::IExpression::Subscribe(uInterface(uPtr(Expression()), ::TYPES[38/*Fuse.Reactive.IExpression*/]), (uObject*)script, (uObject*)this);
}

// internal void Unsubscribe() [instance] :34
void JavaScript__Dependency::Unsubscribe()
{
    uStackFrame __("Fuse.Reactive.JavaScript.Dependency", "Unsubscribe()");

    if (_expSubscription != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_expSubscription), ::TYPES[3/*Uno.IDisposable*/]));
        _expSubscription = NULL;
    }

    Value = NULL;
    HasValue = false;
    _script = NULL;
}

// public Dependency New(string name, Fuse.Reactive.IExpression expression) [static] :18
JavaScript__Dependency* JavaScript__Dependency::New1(uString* name, uObject* expression)
{
    JavaScript__Dependency* obj1 = (JavaScript__Dependency*)uNew(JavaScript__Dependency_typeof());
    obj1->ctor_(name, expression);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Device.uno
// ----------------------------------------------------------------------------------------------

// public sealed class DeviceCaps :114
// {
// static generated DeviceCaps() :114
static void DeviceCaps__cctor__fn(uType* __type)
{
    DeviceCaps::NameIsAndroid_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[57/*"isAndroid"*/]);
    DeviceCaps::NameIsIOS_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[58/*"isIOS"*/]);
    DeviceCaps::NameIsMac_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[59/*"isMac"*/]);
    DeviceCaps::NameIsWindows_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[60/*"isWindows"*/]);
    DeviceCaps::NameIsPreview_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[61/*"isPreview"*/]);
    DeviceCaps::NameOSVersion_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[62/*"osVersion"*/]);
    DeviceCaps::NameAPILevel_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[63/*"apiLevel"*/]);
    DeviceCaps::Device_ = DeviceCaps::New3();
}

static void DeviceCaps_build(uType* type)
{
    ::STRINGS[57] = uString::Const("isAndroid");
    ::STRINGS[58] = uString::Const("isIOS");
    ::STRINGS[59] = uString::Const("isMac");
    ::STRINGS[60] = uString::Const("isWindows");
    ::STRINGS[61] = uString::Const("isPreview");
    ::STRINGS[62] = uString::Const("osVersion");
    ::STRINGS[63] = uString::Const("apiLevel");
    type->SetDependencies(
        ::g::Fuse::Platform::SystemUI_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IObservableObject_typeof(), offsetof(::g::Fuse::Reactive::CapsObject_type, interface0),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(::g::Fuse::Reactive::CapsObject_type, interface1),
        ::g::Fuse::IObject_typeof(), offsetof(::g::Fuse::Reactive::CapsObject_type, interface2));
    type->SetFields(3,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&DeviceCaps::NameIsAndroid_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&DeviceCaps::NameIsIOS_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&DeviceCaps::NameIsMac_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&DeviceCaps::NameIsWindows_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&DeviceCaps::NameIsPreview_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&DeviceCaps::NameOSVersion_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&DeviceCaps::NameAPILevel_, uFieldFlagsStatic,
        type, (uintptr_t)&DeviceCaps::Device_, uFieldFlagsStatic);
    type->Reflection.SetFields(8,
        new uField("Device", 10),
        new uField("NameAPILevel", 9),
        new uField("NameIsAndroid", 3),
        new uField("NameIsIOS", 4),
        new uField("NameIsMac", 5),
        new uField("NameIsPreview", 7),
        new uField("NameIsWindows", 6),
        new uField("NameOSVersion", 8));
}

::g::Fuse::Reactive::CapsObject_type* DeviceCaps_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::CapsObject_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::CapsObject_typeof();
    options.FieldCount = 11;
    options.InterfaceCount = 3;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(DeviceCaps);
    options.TypeSize = sizeof(::g::Fuse::Reactive::CapsObject_type);
    type = (::g::Fuse::Reactive::CapsObject_type*)uClassType::New("Fuse.Reactive.DeviceCaps", options);
    type->fp_build_ = DeviceCaps_build;
    type->fp_ctor_ = (void*)DeviceCaps__New3_fn;
    type->fp_cctor_ = DeviceCaps__cctor__fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject**))::g::Fuse::Reactive::CapsObject__FuseReactiveIObservableObjectSubscribe_fn;
    type->interface1.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::CapsObject__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface2.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))::g::Fuse::Reactive::CapsObject__ContainsKey_fn;
    type->interface2.fp_get_Item = (void(*)(uObject*, uString*, uObject**))::g::Fuse::Reactive::CapsObject__get_Item_fn;
    type->interface2.fp_get_Keys = (void(*)(uObject*, uArray**))::g::Fuse::Reactive::CapsObject__get_Keys_fn;
    return type;
}

// private DeviceCaps() :127
void DeviceCaps__ctor_2_fn(DeviceCaps* __this)
{
    __this->ctor_2();
}

// private DeviceCaps New() :127
void DeviceCaps__New3_fn(DeviceCaps** __retval)
{
    *__retval = DeviceCaps::New3();
}

::g::Uno::UX::Selector DeviceCaps::NameIsAndroid_;
::g::Uno::UX::Selector DeviceCaps::NameIsIOS_;
::g::Uno::UX::Selector DeviceCaps::NameIsMac_;
::g::Uno::UX::Selector DeviceCaps::NameIsWindows_;
::g::Uno::UX::Selector DeviceCaps::NameIsPreview_;
::g::Uno::UX::Selector DeviceCaps::NameOSVersion_;
::g::Uno::UX::Selector DeviceCaps::NameAPILevel_;
uSStrong<DeviceCaps*> DeviceCaps::Device_;

// private DeviceCaps() [instance] :127
void DeviceCaps::ctor_2()
{
    uStackFrame __("Fuse.Reactive.DeviceCaps", ".ctor()");
    ctor_1();
    ::g::Uno::Collections::Dictionary__set_Item_fn(uPtr(Props()), ::g::Uno::UX::Selector__op_Implicit1(DeviceCaps::NameIsAndroid_), uBox(::TYPES[12/*bool*/], true));
    ::g::Uno::Collections::Dictionary__set_Item_fn(uPtr(Props()), ::g::Uno::UX::Selector__op_Implicit1(DeviceCaps::NameIsIOS_), uBox(::TYPES[12/*bool*/], false));
    ::g::Uno::Collections::Dictionary__set_Item_fn(uPtr(Props()), ::g::Uno::UX::Selector__op_Implicit1(DeviceCaps::NameIsMac_), uBox(::TYPES[12/*bool*/], false));
    ::g::Uno::Collections::Dictionary__set_Item_fn(uPtr(Props()), ::g::Uno::UX::Selector__op_Implicit1(DeviceCaps::NameIsWindows_), uBox(::TYPES[12/*bool*/], false));
    ::g::Uno::Collections::Dictionary__set_Item_fn(uPtr(Props()), ::g::Uno::UX::Selector__op_Implicit1(DeviceCaps::NameIsPreview_), uBox(::TYPES[12/*bool*/], true));
    ::g::Uno::Collections::Dictionary__set_Item_fn(uPtr(Props()), ::g::Uno::UX::Selector__op_Implicit1(DeviceCaps::NameOSVersion_), uBox(::g::Uno::Int3_typeof(), ::g::Fuse::Platform::SystemUI::OSVersion()));
    ::g::Uno::Collections::Dictionary__set_Item_fn(uPtr(Props()), ::g::Uno::UX::Selector__op_Implicit1(DeviceCaps::NameAPILevel_), uBox<int32_t>(::TYPES[20/*int*/], ::g::Fuse::Platform::SystemUI::APILevel()));
}

// private DeviceCaps New() [static] :127
DeviceCaps* DeviceCaps::New3()
{
    DeviceCaps* obj1 = (DeviceCaps*)uNew(DeviceCaps_typeof());
    obj1->ctor_2();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class Divide :87
// {
static void Divide_build(uType* type)
{
    ::STRINGS[64] = uString::Const("/");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Divide__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* Divide_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InfixOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(Divide);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.Divide", options);
    type->fp_build_ = Divide_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))Divide__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Divide(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :90
void Divide__ctor_6_fn(Divide* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_6(left, right);
}

// public Divide New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :90
void Divide__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, Divide** __retval)
{
    *__retval = Divide::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :92
void Divide__TryCompute1_fn(Divide* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    return *__retval = ::g::Fuse::Marshal::TryDivide(left, right, result), void();
}

// public Divide(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :90
void Divide::ctor_6(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    ctor_5(left, right, ::STRINGS[64/*"/"*/], 0);
}

// public Divide New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :90
Divide* Divide::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    Divide* obj1 = (Divide*)uNew(Divide_typeof());
    obj1->ctor_6(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Each.uno
// -----------------------------------------------------------------------------------------

// public sealed class Each :94
// {
// static generated Each() :94
static void Each__cctor_1_fn(uType* __type)
{
    ::g::Fuse::Properties_typeof()->Init();
    Each::_eachHandle_ = ::g::Fuse::Properties::CreateHandle();
}

static void Each_build(uType* type)
{
    ::TYPES[39] = ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Node_typeof(), NULL);
    ::TYPES[4] = uObject_typeof()->Array();
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::Instantiator_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::Instantiator_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::Instantiator_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::Instantiator_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::Instantiator_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::Instantiator_type, interface5),
        ::g::Fuse::Node__ISubtreeDataProvider_typeof(), offsetof(::g::Fuse::Reactive::Instantiator_type, interface6),
        ::g::Fuse::IDeferred_typeof(), offsetof(::g::Fuse::Reactive::Instantiator_type, interface7),
        ::g::Fuse::Reactive::ItemsWindowList__IListener_typeof()->MakeType(::g::Fuse::Reactive::WindowItem_typeof(), NULL), offsetof(::g::Fuse::Reactive::Instantiator_type, interface8));
    type->SetFields(37,
        ::g::Uno::Int_typeof(), offsetof(Each, _count), 0,
        ::g::Uno::Bool_typeof(), offsetof(Each, _hasCount), 0,
        ::g::Fuse::PropertyHandle_typeof(), (uintptr_t)&Each::_eachHandle_, uFieldFlagsStatic);
    type->Reflection.SetFunctions(13,
        new uFunction("get_Count", NULL, (void*)Each__get_Count_fn, 0, false, ::g::Uno::Int_typeof(), 0),
        new uFunction("set_Count", NULL, (void*)Each__set_Count_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::Int_typeof()),
        new uFunction("GetItems", NULL, (void*)Each__GetItems1_fn, 0, true, uObject_typeof(), 1, ::g::Fuse::Visual_typeof()),
        new uFunction("GetMatchKey", NULL, (void*)Each__GetMatchKey_fn, 0, true, ::g::Uno::String_typeof(), 1, ::g::Fuse::Visual_typeof()),
        new uFunction("get_Items", NULL, (void*)Each__get_Items_fn, 0, false, uObject_typeof(), 0),
        new uFunction("set_Items", NULL, (void*)Each__set_Items_fn, 0, false, uVoid_typeof(), 1, uObject_typeof()),
        new uFunction("get_Limit", NULL, (void*)Each__get_Limit1_fn, 0, false, ::g::Uno::Int_typeof(), 0),
        new uFunction("set_Limit", NULL, (void*)Each__set_Limit1_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::Int_typeof()),
        new uFunction(".ctor", NULL, (void*)Each__New4_fn, 0, true, type, 0),
        new uFunction("get_Offset", NULL, (void*)Each__get_Offset1_fn, 0, false, ::g::Uno::Int_typeof(), 0),
        new uFunction("set_Offset", NULL, (void*)Each__set_Offset1_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::Int_typeof()),
        new uFunction("SetItems", NULL, (void*)Each__SetItems1_fn, 0, true, uVoid_typeof(), 2, ::g::Fuse::Visual_typeof(), uObject_typeof()),
        new uFunction("SetMatchKey", NULL, (void*)Each__SetMatchKey_fn, 0, true, uVoid_typeof(), 2, ::g::Fuse::Visual_typeof(), ::g::Uno::String_typeof()));
}

::g::Fuse::Reactive::Instantiator_type* Each_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Instantiator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Instantiator_typeof();
    options.FieldCount = 40;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(Each);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Instantiator_type);
    type = (::g::Fuse::Reactive::Instantiator_type*)uClassType::New("Fuse.Reactive.Each", options);
    type->fp_build_ = Each_build;
    type->fp_ctor_ = (void*)Each__New4_fn;
    type->fp_cctor_ = Each__cctor_1_fn;
    type->interface8.fp_SetValid = (void(*)(uObject*))::g::Fuse::Reactive::Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerSetValid_fn;
    type->interface8.fp_SetFailed = (void(*)(uObject*, uString*))::g::Fuse::Reactive::Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerSetFailed_fn;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, ::g::Fuse::Node*, int32_t*, uObject**, int32_t*))::g::Fuse::Reactive::Instantiator__FuseNodeISubtreeDataProviderTryGetDataProvider_fn;
    type->interface8.fp_AddedWindowItem = (void(*)(uObject*, int32_t*, ::g::Fuse::Reactive::WindowListItem*))::g::Fuse::Reactive::Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerAddedWindowItem_fn;
    type->interface7.fp_Perform = (void(*)(uObject*, bool*))::g::Fuse::Reactive::Instantiator__FuseIDeferredPerform_fn;
    type->interface8.fp_RemovedWindowItem = (void(*)(uObject*, ::g::Fuse::Reactive::WindowListItem*))::g::Fuse::Reactive::Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerRemovedWindowItem_fn;
    type->interface8.fp_OnCurrentDataChanged = (void(*)(uObject*, ::g::Fuse::Reactive::WindowListItem*, uObject*))::g::Fuse::Reactive::Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerOnCurrentDataChanged_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public Each() :145
void Each__ctor_5_fn(Each* __this)
{
    __this->ctor_5();
}

// private Each(Uno.Collections.IList<Uno.UX.Template> templates) :144
void Each__ctor_6_fn(Each* __this, uObject* templates)
{
    __this->ctor_6(templates);
}

// public int get_Count() :174
void Each__get_Count_fn(Each* __this, int32_t* __retval)
{
    *__retval = __this->Count();
}

// public void set_Count(int value) :175
void Each__set_Count_fn(Each* __this, int32_t* value)
{
    __this->Count(*value);
}

// private static Fuse.Reactive.Each GetEach(Fuse.Visual container) :98
void Each__GetEach_fn(::g::Fuse::Visual* container, Each** __retval)
{
    *__retval = Each::GetEach(container);
}

// public static object GetItems(Fuse.Visual container) :126
void Each__GetItems1_fn(::g::Fuse::Visual* container, uObject** __retval)
{
    *__retval = Each::GetItems1(container);
}

// public static string GetMatchKey(Fuse.Visual container) :139
void Each__GetMatchKey_fn(::g::Fuse::Visual* container, uString** __retval)
{
    *__retval = Each::GetMatchKey(container);
}

// public object get_Items() :161
void Each__get_Items_fn(Each* __this, uObject** __retval)
{
    *__retval = __this->Items();
}

// public void set_Items(object value) :162
void Each__set_Items_fn(Each* __this, uObject* value)
{
    __this->Items(value);
}

// public new int get_Limit() :212
void Each__get_Limit1_fn(Each* __this, int32_t* __retval)
{
    *__retval = __this->Limit1();
}

// public new void set_Limit(int value) :213
void Each__set_Limit1_fn(Each* __this, int32_t* value)
{
    __this->Limit1(*value);
}

// public Each New() :145
void Each__New4_fn(Each** __retval)
{
    *__retval = Each::New4();
}

// private Each New(Uno.Collections.IList<Uno.UX.Template> templates) :144
void Each__New5_fn(uObject* templates, Each** __retval)
{
    *__retval = Each::New5(templates);
}

// public new int get_Offset() :199
void Each__get_Offset1_fn(Each* __this, int32_t* __retval)
{
    *__retval = __this->Offset1();
}

// public new void set_Offset(int value) :200
void Each__set_Offset1_fn(Each* __this, int32_t* value)
{
    __this->Offset1(*value);
}

// public static void SetItems(Fuse.Visual container, object items) :120
void Each__SetItems1_fn(::g::Fuse::Visual* container, uObject* items)
{
    Each::SetItems1(container, items);
}

// public static void SetMatchKey(Fuse.Visual container, string key) :133
void Each__SetMatchKey_fn(::g::Fuse::Visual* container, uString* key)
{
    Each::SetMatchKey(container, key);
}

uSStrong< ::g::Fuse::PropertyHandle*> Each::_eachHandle_;

// public Each() [instance] :145
void Each::ctor_5()
{
    uStackFrame __("Fuse.Reactive.Each", ".ctor()");
    ctor_3();
}

// private Each(Uno.Collections.IList<Uno.UX.Template> templates) [instance] :144
void Each::ctor_6(uObject* templates)
{
    uStackFrame __("Fuse.Reactive.Each", ".ctor(Uno.Collections.IList<Uno.UX.Template>)");
    ctor_4(templates);
}

// public int get_Count() [instance] :174
int32_t Each::Count()
{
    return _count;
}

// public void set_Count(int value) [instance] :175
void Each::Count(int32_t value)
{
    uStackFrame __("Fuse.Reactive.Each", "set_Count(int)");

    if (_hasCount && (_count == value))
        return;

    _count = value;
    _hasCount = true;
    uArray* items = uArray::New(::TYPES[4/*object[]*/], _count);

    for (int32_t i = 0; i < _count; ++i)
        uPtr(items)->Strong<uObject*>(i) = ::g::Fuse::Reactive::Instantiator__NoContextItem::New1();

    SetItems(items);
}

// public object get_Items() [instance] :161
uObject* Each::Items()
{
    uStackFrame __("Fuse.Reactive.Each", "get_Items()");
    return GetItems();
}

// public void set_Items(object value) [instance] :162
void Each::Items(uObject* value)
{
    uStackFrame __("Fuse.Reactive.Each", "set_Items(object)");

    if (GetItems() != value)
        SetItems(value);
}

// public new int get_Limit() [instance] :212
int32_t Each::Limit1()
{
    uStackFrame __("Fuse.Reactive.Each", "get_Limit()");
    return Limit();
}

// public new void set_Limit(int value) [instance] :213
void Each::Limit1(int32_t value)
{
    uStackFrame __("Fuse.Reactive.Each", "set_Limit(int)");
    Limit(value);
}

// public new int get_Offset() [instance] :199
int32_t Each::Offset1()
{
    uStackFrame __("Fuse.Reactive.Each", "get_Offset()");
    return Offset();
}

// public new void set_Offset(int value) [instance] :200
void Each::Offset1(int32_t value)
{
    uStackFrame __("Fuse.Reactive.Each", "set_Offset(int)");
    Offset(value);
}

// private static Fuse.Reactive.Each GetEach(Fuse.Visual container) [static] :98
Each* Each::GetEach(::g::Fuse::Visual* container)
{
    uStackFrame __("Fuse.Reactive.Each", "GetEach(Fuse.Visual)");
    Each_typeof()->Init();
    Each* each = uAs<Each*>(uPtr(uPtr(container)->Properties())->Get(Each::_eachHandle_), Each_typeof());

    if (each == NULL)
    {
        each = Each::New5(uPtr(container)->Templates());
        uPtr(container->Properties())->Set(Each::_eachHandle_, each);
        ::g::Uno::Collections::ICollection::Add_ex(uInterface(uPtr(container->Children()), ::TYPES[39/*Uno.Collections.ICollection<Fuse.Node>*/]), each);
    }

    return each;
}

// public static object GetItems(Fuse.Visual container) [static] :126
uObject* Each::GetItems1(::g::Fuse::Visual* container)
{
    uStackFrame __("Fuse.Reactive.Each", "GetItems(Fuse.Visual)");
    Each_typeof()->Init();
    return uPtr(Each::GetEach(container))->Items();
}

// public static string GetMatchKey(Fuse.Visual container) [static] :139
uString* Each::GetMatchKey(::g::Fuse::Visual* container)
{
    uStackFrame __("Fuse.Reactive.Each", "GetMatchKey(Fuse.Visual)");
    Each_typeof()->Init();
    return uPtr(Each::GetEach(container))->MatchKey();
}

// public Each New() [static] :145
Each* Each::New4()
{
    Each* obj2 = (Each*)uNew(Each_typeof());
    obj2->ctor_5();
    return obj2;
}

// private Each New(Uno.Collections.IList<Uno.UX.Template> templates) [static] :144
Each* Each::New5(uObject* templates)
{
    Each* obj1 = (Each*)uNew(Each_typeof());
    obj1->ctor_6(templates);
    return obj1;
}

// public static void SetItems(Fuse.Visual container, object items) [static] :120
void Each::SetItems1(::g::Fuse::Visual* container, uObject* items)
{
    uStackFrame __("Fuse.Reactive.Each", "SetItems(Fuse.Visual,object)");
    Each_typeof()->Init();
    uPtr(Each::GetEach(container))->Items(items);
}

// public static void SetMatchKey(Fuse.Visual container, string key) [static] :133
void Each::SetMatchKey(::g::Fuse::Visual* container, uString* key)
{
    uStackFrame __("Fuse.Reactive.Each", "SetMatchKey(Fuse.Visual,string)");
    Each_typeof()->Init();
    uPtr(Each::GetEach(container))->MatchKey(key);
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class Equal :174
// {
static void Equal_build(uType* type)
{
    ::STRINGS[65] = uString::Const("==");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Equal__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* Equal_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InfixOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(Equal);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.Equal", options);
    type->fp_build_ = Equal_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))Equal__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Equal(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :177
void Equal__ctor_6_fn(Equal* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_6(left, right);
}

// public Equal New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :177
void Equal__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, Equal** __retval)
{
    *__retval = Equal::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :179
void Equal__TryCompute1_fn(Equal* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    bool v = false;
    bool r = ::g::Fuse::Marshal::TryEqualTo(left, right, &v);
    *result = uBox(::TYPES[12/*bool*/], v);
    return *__retval = r, void();
}

// public Equal(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :177
void Equal::ctor_6(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    ctor_5(left, right, ::STRINGS[65/*"=="*/], 0);
}

// public Equal New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :177
Equal* Equal::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    Equal* obj1 = (Equal*)uNew(Equal_typeof());
    obj1->ctor_6(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Even :48
// {
static void Even_build(uType* type)
{
    ::STRINGS[66] = uString::Const("even");
    ::TYPES[2] = ::g::Fuse::Marshal_typeof()->MakeMethod(1/*TryToType<float>*/, ::g::Uno::Float_typeof(), NULL);
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Even__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Even_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Even);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Even", options);
    type->fp_build_ = Even_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::UnaryOperator*, uObject*, uObject**, bool*))Even__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Even(Fuse.Reactive.Expression operand) :51
void Even__ctor_4_fn(Even* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_4(operand);
}

// public Even New(Fuse.Reactive.Expression operand) :51
void Even__New1_fn(::g::Fuse::Reactive::Expression* operand, Even** __retval)
{
    *__retval = Even::New1(operand);
}

// protected override sealed bool TryCompute(object operand, object& result) :52
void Even__TryCompute1_fn(Even* __this, uObject* operand, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.Even", "TryCompute(object,object&)");
    bool ret2;
    *result = NULL;
    float v = 0.0f;

    if (!(::g::Fuse::Marshal__TryToType_fn(::TYPES[2/*Fuse.Marshal.TryToType<float>*/], operand, &v, &ret2), ret2))
        return *__retval = false, void();

    int32_t q = (int32_t)::g::Uno::Math::Round2(v);
    *result = uBox(::TYPES[12/*bool*/], (q % 2) == 0);
    return *__retval = true, void();
}

// public Even(Fuse.Reactive.Expression operand) [instance] :51
void Even::ctor_4(::g::Fuse::Reactive::Expression* operand)
{
    ctor_3(operand, ::STRINGS[66/*"even"*/], 0);
}

// public Even New(Fuse.Reactive.Expression operand) [static] :51
Even* Even::New1(::g::Fuse::Reactive::Expression* operand)
{
    Even* obj1 = (Even*)uNew(Even_typeof());
    obj1->ctor_4(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\EventBinding.uno
// -------------------------------------------------------------------------------------------------

// public sealed class EventBinding :26
// {
static void EventBinding_build(uType* type)
{
    ::TYPES[40] = ::g::Fuse::Reactive::IEventHandler_typeof();
    ::TYPES[41] = ::g::Fuse::Scripting::IScriptEvent_typeof();
    ::TYPES[42] = ::g::Fuse::Node_typeof();
    ::TYPES[43] = ::g::Uno::Collections::List_typeof()->MakeType(::g::Fuse::Reactive::EventRecord_typeof(), NULL);
    type->SetInterfaces(
        ::g::Fuse::Reactive::IContext_typeof(), offsetof(::g::Fuse::Reactive::ExpressionBinding_type, interface0),
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(::g::Fuse::Reactive::ExpressionBinding_type, interface1));
    type->SetFields(3,
        ::TYPES[40/*Fuse.Reactive.IEventHandler*/], offsetof(EventBinding, _eventHandler), 0,
        ::TYPES[43/*Uno.Collections.List<Fuse.Reactive.EventRecord>*/], offsetof(EventBinding, _queuedEvents), 0);
    type->Reflection.SetFunctions(2,
        new uFunction(".ctor", NULL, (void*)EventBinding__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::IExpression_typeof()),
        new uFunction("OnEvent", NULL, (void*)EventBinding__OnEvent_fn, 0, false, uVoid_typeof(), 2, uObject_typeof(), ::g::Uno::EventArgs_typeof()));
}

::g::Fuse::Reactive::ExpressionBinding_type* EventBinding_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::ExpressionBinding_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ExpressionBinding_typeof();
    options.FieldCount = 5;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(EventBinding);
    options.TypeSize = sizeof(::g::Fuse::Reactive::ExpressionBinding_type);
    type = (::g::Fuse::Reactive::ExpressionBinding_type*)uClassType::New("Fuse.Reactive.EventBinding", options);
    type->fp_build_ = EventBinding_build;
    type->fp_LostValue = (void(*)(::g::Fuse::Reactive::ExpressionBinding*))EventBinding__LostValue_fn;
    type->fp_NewValue = (void(*)(::g::Fuse::Reactive::ExpressionBinding*, uObject*))EventBinding__NewValue_fn;
    type->fp_OnUnrooted = (void(*)(::g::Fuse::Binding*))EventBinding__OnUnrooted_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIContextSubscribe_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_get_Node = (void(*)(uObject*, ::g::Fuse::Node**))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIContextget_Node_fn;
    type->interface0.fp_SubscribeResource = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))::g::Fuse::Reactive::ExpressionBinding__SubscribeResource_fn;
    return type;
}

// public EventBinding(Fuse.Reactive.IExpression key) :29
void EventBinding__ctor_2_fn(EventBinding* __this, uObject* key)
{
    __this->ctor_2(key);
}

// internal override sealed void LostValue() :55
void EventBinding__LostValue_fn(EventBinding* __this)
{
    __this->_eventHandler = NULL;
}

// public EventBinding New(Fuse.Reactive.IExpression key) :29
void EventBinding__New1_fn(uObject* key, EventBinding** __retval)
{
    *__retval = EventBinding::New1(key);
}

// internal override sealed void NewValue(object obj) :49
void EventBinding__NewValue_fn(EventBinding* __this, uObject* obj)
{
    uStackFrame __("Fuse.Reactive.EventBinding", "NewValue(object)");
    __this->_eventHandler = uAs<uObject*>(obj, ::TYPES[40/*Fuse.Reactive.IEventHandler*/]);
    __this->ProcessQueuedEvents();
}

// public void OnEvent(object sender, Uno.EventArgs args) :67
void EventBinding__OnEvent_fn(EventBinding* __this, uObject* sender, ::g::Uno::EventArgs* args)
{
    __this->OnEvent(sender, args);
}

// protected override sealed void OnUnrooted() :60
void EventBinding__OnUnrooted_fn(EventBinding* __this)
{
    uStackFrame __("Fuse.Reactive.EventBinding", "OnUnrooted()");
    ::g::Fuse::Reactive::ExpressionBinding__OnUnrooted_fn(__this);
    __this->_eventHandler = NULL;
    __this->_queuedEvents = NULL;
}

// private void ProcessQueuedEvents() :37
void EventBinding__ProcessQueuedEvents_fn(EventBinding* __this)
{
    __this->ProcessQueuedEvents();
}

// public EventBinding(Fuse.Reactive.IExpression key) [instance] :29
void EventBinding::ctor_2(uObject* key)
{
    ctor_1(key);
}

// public void OnEvent(object sender, Uno.EventArgs args) [instance] :67
void EventBinding::OnEvent(uObject* sender, ::g::Uno::EventArgs* args)
{
    uStackFrame __("Fuse.Reactive.EventBinding", "OnEvent(object,Uno.EventArgs)");

    if (Parent() == NULL)
        return;

    ::g::Fuse::Reactive::EventRecord* e = ::g::Fuse::Reactive::EventRecord::New1(uAs<uObject*>(args, ::TYPES[41/*Fuse.Scripting.IScriptEvent*/]), uAs< ::g::Fuse::Node*>(sender, ::TYPES[42/*Fuse.Node*/]));

    if (_eventHandler != NULL)
        ::g::Fuse::Reactive::IEventHandler::Dispatch(uInterface(uPtr(_eventHandler), ::TYPES[40/*Fuse.Reactive.IEventHandler*/]), (uObject*)e);
    else
    {
        if (_queuedEvents == NULL)
            _queuedEvents = ((::g::Uno::Collections::List*)::g::Uno::Collections::List::New1(::TYPES[43/*Uno.Collections.List<Fuse.Reactive.EventRecord>*/]));

        ::g::Uno::Collections::List__Add_fn(uPtr(_queuedEvents), e);
    }
}

// private void ProcessQueuedEvents() [instance] :37
void EventBinding::ProcessQueuedEvents()
{
    uStackFrame __("Fuse.Reactive.EventBinding", "ProcessQueuedEvents()");
    ::g::Fuse::Reactive::EventRecord* ret2;

    if ((_eventHandler != NULL) && (_queuedEvents != NULL))
    {
        ::g::Uno::Collections::List* events = _queuedEvents;
        _queuedEvents = NULL;

        for (int32_t i = 0; i < uPtr(events)->Count(); i++)
            ::g::Fuse::Reactive::IEventHandler::Dispatch(uInterface(uPtr(_eventHandler), ::TYPES[40/*Fuse.Reactive.IEventHandler*/]), (uObject*)(::g::Uno::Collections::List__get_Item_fn(uPtr(events), uCRef<int32_t>(i), &ret2), ret2));
    }
}

// public EventBinding New(Fuse.Reactive.IExpression key) [static] :29
EventBinding* EventBinding::New1(uObject* key)
{
    EventBinding* obj1 = (EventBinding*)uNew(EventBinding_typeof());
    obj1->ctor_2(key);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\EventRecord.uno
// ------------------------------------------------------------------------------------------------

// internal sealed class EventRecord :9
// {
static void EventRecord_build(uType* type)
{
    ::TYPES[42] = ::g::Fuse::Node_typeof();
    ::TYPES[41] = ::g::Fuse::Scripting::IScriptEvent_typeof();
    ::TYPES[5] = ::g::Uno::Collections::Dictionary_typeof()->MakeType(::g::Uno::String_typeof(), uObject_typeof(), NULL);
    type->SetInterfaces(
        ::g::Fuse::Reactive::IEventRecord_typeof(), offsetof(EventRecord_type, interface0),
        ::g::Fuse::Scripting::IEventSerializer_typeof(), offsetof(EventRecord_type, interface1));
    type->SetFields(0,
        ::TYPES[42/*Fuse.Node*/], offsetof(EventRecord, _node), 0,
        uObject_typeof(), offsetof(EventRecord, _data), 0,
        ::g::Uno::UX::Selector_typeof(), offsetof(EventRecord, _sender), 0,
        ::TYPES[5/*Uno.Collections.Dictionary<string, object>*/], offsetof(EventRecord, _args), 0);
}

EventRecord_type* EventRecord_typeof()
{
    static uSStrong<EventRecord_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 4;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(EventRecord);
    options.TypeSize = sizeof(EventRecord_type);
    type = (EventRecord_type*)uClassType::New("Fuse.Reactive.EventRecord", options);
    type->fp_build_ = EventRecord_build;
    type->interface1.fp_AddObject = (void(*)(uObject*, uString*, uObject*))EventRecord__FuseScriptingIEventSerializerAddObject_fn;
    type->interface1.fp_AddString = (void(*)(uObject*, uString*, uString*))EventRecord__FuseScriptingIEventSerializerAddString_fn;
    type->interface1.fp_AddInt = (void(*)(uObject*, uString*, int32_t*))EventRecord__FuseScriptingIEventSerializerAddInt_fn;
    type->interface1.fp_AddDouble = (void(*)(uObject*, uString*, double*))EventRecord__FuseScriptingIEventSerializerAddDouble_fn;
    type->interface1.fp_AddBool = (void(*)(uObject*, uString*, bool*))EventRecord__FuseScriptingIEventSerializerAddBool_fn;
    type->interface0.fp_get_Node = (void(*)(uObject*, ::g::Fuse::Node**))EventRecord__get_Node_fn;
    type->interface0.fp_get_Data = (void(*)(uObject*, uObject**))EventRecord__get_Data_fn;
    type->interface0.fp_get_Sender = (void(*)(uObject*, ::g::Uno::UX::Selector*))EventRecord__get_Sender_fn;
    type->interface0.fp_get_Args = (void(*)(uObject*, uObject**))EventRecord__get_Args_fn;
    return type;
}

// internal EventRecord(Fuse.Scripting.IScriptEvent args, object sender) :16
void EventRecord__ctor__fn(EventRecord* __this, uObject* args, uObject* sender)
{
    __this->ctor_(args, sender);
}

// private void AddObject(string key, object value) :36
void EventRecord__AddObject_fn(EventRecord* __this, uString* key, uObject* value)
{
    __this->AddObject(key, value);
}

// public Uno.Collections.IEnumerable<Uno.Collections.KeyValuePair<string, object>> get_Args() :34
void EventRecord__get_Args_fn(EventRecord* __this, uObject** __retval)
{
    *__retval = __this->Args();
}

// public object get_Data() :32
void EventRecord__get_Data_fn(EventRecord* __this, uObject** __retval)
{
    *__retval = __this->Data();
}

// private void Fuse.Scripting.IEventSerializer.AddBool(string key, bool value) :62
void EventRecord__FuseScriptingIEventSerializerAddBool_fn(EventRecord* __this, uString* key, bool* value)
{
    uStackFrame __("Fuse.Reactive.EventRecord", "Fuse.Scripting.IEventSerializer.AddBool(string,bool)");
    bool value_ = *value;
    __this->AddObject(key, uBox(::TYPES[12/*bool*/], value_));
}

// private void Fuse.Scripting.IEventSerializer.AddDouble(string key, double value) :57
void EventRecord__FuseScriptingIEventSerializerAddDouble_fn(EventRecord* __this, uString* key, double* value)
{
    uStackFrame __("Fuse.Reactive.EventRecord", "Fuse.Scripting.IEventSerializer.AddDouble(string,double)");
    double value_ = *value;
    __this->AddObject(key, uBox(::TYPES[14/*double*/], value_));
}

// private void Fuse.Scripting.IEventSerializer.AddInt(string key, int value) :52
void EventRecord__FuseScriptingIEventSerializerAddInt_fn(EventRecord* __this, uString* key, int32_t* value)
{
    uStackFrame __("Fuse.Reactive.EventRecord", "Fuse.Scripting.IEventSerializer.AddInt(string,int)");
    int32_t value_ = *value;
    __this->AddObject(key, uBox(::TYPES[14/*double*/], (double)value_));
}

// private void Fuse.Scripting.IEventSerializer.AddObject(string key, object value) :42
void EventRecord__FuseScriptingIEventSerializerAddObject_fn(EventRecord* __this, uString* key, uObject* value)
{
    uStackFrame __("Fuse.Reactive.EventRecord", "Fuse.Scripting.IEventSerializer.AddObject(string,object)");
    __this->AddObject(key, value);
}

// private void Fuse.Scripting.IEventSerializer.AddString(string key, string value) :47
void EventRecord__FuseScriptingIEventSerializerAddString_fn(EventRecord* __this, uString* key, uString* value)
{
    uStackFrame __("Fuse.Reactive.EventRecord", "Fuse.Scripting.IEventSerializer.AddString(string,string)");
    __this->AddObject(key, value);
}

// internal EventRecord New(Fuse.Scripting.IScriptEvent args, object sender) :16
void EventRecord__New1_fn(uObject* args, uObject* sender, EventRecord** __retval)
{
    *__retval = EventRecord::New1(args, sender);
}

// public Fuse.Node get_Node() :31
void EventRecord__get_Node_fn(EventRecord* __this, ::g::Fuse::Node** __retval)
{
    *__retval = __this->Node();
}

// public Uno.UX.Selector get_Sender() :33
void EventRecord__get_Sender_fn(EventRecord* __this, ::g::Uno::UX::Selector* __retval)
{
    *__retval = __this->Sender();
}

// internal EventRecord(Fuse.Scripting.IScriptEvent args, object sender) [instance] :16
void EventRecord::ctor_(uObject* args, uObject* sender)
{
    uStackFrame __("Fuse.Reactive.EventRecord", ".ctor(Fuse.Scripting.IScriptEvent,object)");
    _node = uAs< ::g::Fuse::Node*>(sender, ::TYPES[42/*Fuse.Node*/]);

    if (_node != NULL)
    {
        uPtr(_node)->TryGetPrimeDataContext(&_data);

        if (::g::Uno::String::op_Inequality(::g::Uno::UX::Selector__op_Implicit1(uPtr(_node)->Name()), NULL))
            _sender = uPtr(_node)->Name();
    }

    if (args != NULL)
        ::g::Fuse::Scripting::IScriptEvent::Serialize(uInterface(uPtr(args), ::TYPES[41/*Fuse.Scripting.IScriptEvent*/]), (uObject*)this);
}

// private void AddObject(string key, object value) [instance] :36
void EventRecord::AddObject(uString* key, uObject* value)
{
    uStackFrame __("Fuse.Reactive.EventRecord", "AddObject(string,object)");

    if (_args == NULL)
        _args = ((::g::Uno::Collections::Dictionary*)::g::Uno::Collections::Dictionary::New1(::TYPES[5/*Uno.Collections.Dictionary<string, object>*/]));

    ::g::Uno::Collections::Dictionary__Add_fn(uPtr(_args), key, value);
}

// public Uno.Collections.IEnumerable<Uno.Collections.KeyValuePair<string, object>> get_Args() [instance] :34
uObject* EventRecord::Args()
{
    uStackFrame __("Fuse.Reactive.EventRecord", "get_Args()");
    return (uObject*)_args;
}

// public object get_Data() [instance] :32
uObject* EventRecord::Data()
{
    return _data;
}

// public Fuse.Node get_Node() [instance] :31
::g::Fuse::Node* EventRecord::Node()
{
    return _node;
}

// public Uno.UX.Selector get_Sender() [instance] :33
::g::Uno::UX::Selector EventRecord::Sender()
{
    return _sender;
}

// internal EventRecord New(Fuse.Scripting.IScriptEvent args, object sender) [static] :16
EventRecord* EventRecord::New1(uObject* args, uObject* sender)
{
    EventRecord* obj1 = (EventRecord*)uNew(EventRecord_typeof());
    obj1->ctor_(args, sender);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Exp :335
// {
static void Exp_build(uType* type)
{
    ::STRINGS[67] = uString::Const("exp");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Exp__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Exp_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Exp);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Exp", options);
    type->fp_build_ = Exp_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Exp(Fuse.Reactive.Expression operand) :338
void Exp__ctor_5_fn(Exp* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Exp New(Fuse.Reactive.Expression operand) :338
void Exp__New1_fn(::g::Fuse::Reactive::Expression* operand, Exp** __retval)
{
    *__retval = Exp::New1(operand);
}

// public Exp(Fuse.Reactive.Expression operand) [instance] :338
void Exp::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[67/*"exp"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Exp_fn));
}

// public Exp New(Fuse.Reactive.Expression operand) [static] :338
Exp* Exp::New1(::g::Fuse::Reactive::Expression* operand)
{
    Exp* obj1 = (Exp*)uNew(Exp_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Exp2 :343
// {
static void Exp2_build(uType* type)
{
    ::STRINGS[68] = uString::Const("exp2");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Exp2__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Exp2_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Exp2);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Exp2", options);
    type->fp_build_ = Exp2_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Exp2(Fuse.Reactive.Expression operand) :346
void Exp2__ctor_5_fn(Exp2* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Exp2 New(Fuse.Reactive.Expression operand) :346
void Exp2__New1_fn(::g::Fuse::Reactive::Expression* operand, Exp2** __retval)
{
    *__retval = Exp2::New1(operand);
}

// public Exp2(Fuse.Reactive.Expression operand) [instance] :346
void Exp2::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[68/*"exp2"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Exp21_fn));
}

// public Exp2 New(Fuse.Reactive.Expression operand) [static] :346
Exp2* Exp2::New1(::g::Fuse::Reactive::Expression* operand)
{
    Exp2* obj1 = (Exp2*)uNew(Exp2_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Expression.uno
// --------------------------------------------------------------------------------------------------

// public abstract class Expression :7
// {
static void Expression_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(Expression_type, interface0));
    type->Reflection.SetFunctions(1,
        new uFunction("Subscribe", NULL, NULL, offsetof(Expression_type, fp_Subscribe), false, ::g::Uno::IDisposable_typeof(), 2, ::g::Fuse::Reactive::IContext_typeof(), ::g::Fuse::Reactive::IListener_typeof()));
}

Expression_type* Expression_typeof()
{
    static uSStrong<Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Expression);
    options.TypeSize = sizeof(Expression_type);
    type = (Expression_type*)uClassType::New("Fuse.Reactive.Expression", options);
    type->fp_build_ = Expression_build;
    return type;
}

// protected generated Expression() :7
void Expression__ctor__fn(Expression* __this)
{
    __this->ctor_();
}

// protected generated Expression() [instance] :7
void Expression::ctor_()
{
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\ExpressionBinding.uno
// ------------------------------------------------------------------------------------------------------

// public abstract class ExpressionBinding :6
// {
static void ExpressionBinding_build(uType* type)
{
    ::STRINGS[69] = uString::Const("The binding type does not support resource subscriptions");
    ::TYPES[38] = ::g::Fuse::Reactive::IExpression_typeof();
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    ::TYPES[44] = ::g::Fuse::Reactive::IWriteable_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IContext_typeof(), offsetof(ExpressionBinding_type, interface0),
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(ExpressionBinding_type, interface1));
    type->SetFields(1,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(ExpressionBinding, _expressionSub), 0,
        ::TYPES[38/*Fuse.Reactive.IExpression*/], offsetof(ExpressionBinding, _Key), 0);
    type->Reflection.SetFunctions(2,
        new uFunction("get_Key", NULL, (void*)ExpressionBinding__get_Key_fn, 0, false, ::TYPES[38/*Fuse.Reactive.IExpression*/], 0),
        new uFunction("SubscribeResource", NULL, NULL, offsetof(ExpressionBinding_type, fp_SubscribeResource), false, ::TYPES[3/*Uno.IDisposable*/], 3, ::TYPES[38/*Fuse.Reactive.IExpression*/], ::g::Uno::String_typeof(), ::g::Fuse::Reactive::IListener_typeof()));
}

ExpressionBinding_type* ExpressionBinding_typeof()
{
    static uSStrong<ExpressionBinding_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Binding_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(ExpressionBinding);
    options.TypeSize = sizeof(ExpressionBinding_type);
    type = (ExpressionBinding_type*)uClassType::New("Fuse.Reactive.ExpressionBinding", options);
    type->fp_build_ = ExpressionBinding_build;
    type->fp_OnRooted = (void(*)(::g::Fuse::Binding*))ExpressionBinding__OnRooted_fn;
    type->fp_OnUnrooted = (void(*)(::g::Fuse::Binding*))ExpressionBinding__OnUnrooted_fn;
    type->fp_SubscribeResource = ExpressionBinding__SubscribeResource_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))ExpressionBinding__FuseReactiveIContextSubscribe_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))ExpressionBinding__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))ExpressionBinding__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_get_Node = (void(*)(uObject*, ::g::Fuse::Node**))ExpressionBinding__FuseReactiveIContextget_Node_fn;
    type->interface0.fp_SubscribeResource = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))ExpressionBinding__SubscribeResource_fn;
    return type;
}

// protected ExpressionBinding(Fuse.Reactive.IExpression key) :10
void ExpressionBinding__ctor_1_fn(ExpressionBinding* __this, uObject* key)
{
    __this->ctor_1(key);
}

// protected internal bool get_CanWriteBack() :17
void ExpressionBinding__get_CanWriteBack_fn(ExpressionBinding* __this, bool* __retval)
{
    *__retval = __this->CanWriteBack();
}

// private Fuse.Node Fuse.Reactive.IContext.get_Node() :31
void ExpressionBinding__FuseReactiveIContextget_Node_fn(ExpressionBinding* __this, ::g::Fuse::Node** __retval)
{
    return *__retval = __this->Parent(), void();
}

// private Uno.IDisposable Fuse.Reactive.IContext.Subscribe(Fuse.Reactive.IExpression source, string key, Fuse.Reactive.IListener listener) :26
void ExpressionBinding__FuseReactiveIContextSubscribe_fn(ExpressionBinding* __this, uObject* source, uString* key, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.ExpressionBinding", "Fuse.Reactive.IContext.Subscribe(Fuse.Reactive.IExpression,string,Fuse.Reactive.IListener)");
    return *__retval = (uObject*)::g::Fuse::Reactive::DataSubscription::New1(source, __this->Parent(), key, listener), void();
}

// private void Fuse.Reactive.IListener.OnLostData(Fuse.Reactive.IExpression source) :49
void ExpressionBinding__FuseReactiveIListenerOnLostData_fn(ExpressionBinding* __this, uObject* source)
{
    uStackFrame __("Fuse.Reactive.ExpressionBinding", "Fuse.Reactive.IListener.OnLostData(Fuse.Reactive.IExpression)");
    __this->LostValue();
}

// private void Fuse.Reactive.IListener.OnNewData(Fuse.Reactive.IExpression source, object obj) :48
void ExpressionBinding__FuseReactiveIListenerOnNewData_fn(ExpressionBinding* __this, uObject* source, uObject* obj)
{
    uStackFrame __("Fuse.Reactive.ExpressionBinding", "Fuse.Reactive.IListener.OnNewData(Fuse.Reactive.IExpression,object)");
    __this->NewValue(obj);
}

// public generated Fuse.Reactive.IExpression get_Key() :8
void ExpressionBinding__get_Key_fn(ExpressionBinding* __this, uObject** __retval)
{
    *__retval = __this->Key();
}

// private generated void set_Key(Fuse.Reactive.IExpression value) :8
void ExpressionBinding__set_Key_fn(ExpressionBinding* __this, uObject* value)
{
    __this->Key(value);
}

// protected override void OnRooted() :20
void ExpressionBinding__OnRooted_fn(ExpressionBinding* __this)
{
    uStackFrame __("Fuse.Reactive.ExpressionBinding", "OnRooted()");
    ::g::Fuse::Binding__OnRooted_fn(__this);
    __this->_expressionSub = ::g::Fuse::Reactive::IExpression::Subscribe(uInterface(uPtr(__this->Key()), ::TYPES[38/*Fuse.Reactive.IExpression*/]), (uObject*)__this, (uObject*)__this);
}

// protected override void OnUnrooted() :38
void ExpressionBinding__OnUnrooted_fn(ExpressionBinding* __this)
{
    uStackFrame __("Fuse.Reactive.ExpressionBinding", "OnUnrooted()");

    if (__this->_expressionSub != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(__this->_expressionSub), ::TYPES[3/*Uno.IDisposable*/]));
        __this->_expressionSub = NULL;
    }

    ::g::Fuse::Binding__OnUnrooted_fn(__this);
}

// public virtual Uno.IDisposable SubscribeResource(Fuse.Reactive.IExpression source, string key, Fuse.Reactive.IListener listener) :33
void ExpressionBinding__SubscribeResource_fn(ExpressionBinding* __this, uObject* source, uString* key, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.ExpressionBinding", "SubscribeResource(Fuse.Reactive.IExpression,string,Fuse.Reactive.IListener)");
    U_THROW(::g::Uno::Exception::New2(::STRINGS[69/*"The binding...*/]));
}

// protected internal void WriteBack(object value) :18
void ExpressionBinding__WriteBack_fn(ExpressionBinding* __this, uObject* value)
{
    __this->WriteBack(value);
}

// protected ExpressionBinding(Fuse.Reactive.IExpression key) [instance] :10
void ExpressionBinding::ctor_1(uObject* key)
{
    ctor_();
    Key(key);
}

// protected internal bool get_CanWriteBack() [instance] :17
bool ExpressionBinding::CanWriteBack()
{
    return uIs((uObject*)_expressionSub, ::TYPES[44/*Fuse.Reactive.IWriteable*/]);
}

// public generated Fuse.Reactive.IExpression get_Key() [instance] :8
uObject* ExpressionBinding::Key()
{
    return _Key;
}

// private generated void set_Key(Fuse.Reactive.IExpression value) [instance] :8
void ExpressionBinding::Key(uObject* value)
{
    _Key = value;
}

// protected internal void WriteBack(object value) [instance] :18
void ExpressionBinding::WriteBack(uObject* value)
{
    uStackFrame __("Fuse.Reactive.ExpressionBinding", "WriteBack(object)");
    ::g::Fuse::Reactive::IWriteable::TrySetExclusive(uInterface(uPtr(_expressionSub), ::TYPES[44/*Fuse.Reactive.IWriteable*/]), value);
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\ExpressionListener.uno
// ----------------------------------------------------------------------------------------------------------

// public abstract class ExpressionListener :152
// {
static void ExpressionListener_build(uType* type)
{
    ::STRINGS[70] = uString::Const("May not be null: listener");
    ::STRINGS[71] = uString::Const("May not be null: source");
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(ExpressionListener_type, interface0),
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(ExpressionListener_type, interface1));
    type->SetFields(5,
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(ExpressionListener, _listener), 0,
        ::g::Uno::Bool_typeof(), offsetof(ExpressionListener, _hasData), 0,
        uObject_typeof(), offsetof(ExpressionListener, _curData), 0,
        ::g::Fuse::Reactive::Expression_typeof(), offsetof(ExpressionListener, _source1), 0);
}

ExpressionListener_type* ExpressionListener_typeof()
{
    static uSStrong<ExpressionListener_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ExpressionSubscriber_typeof();
    options.FieldCount = 9;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(ExpressionListener);
    options.TypeSize = sizeof(ExpressionListener_type);
    type = (ExpressionListener_type*)uClassType::New("Fuse.Reactive.ExpressionListener", options);
    type->fp_build_ = ExpressionListener_build;
    type->fp_Dispose = (void(*)(::g::Fuse::Reactive::InnerListener*))ExpressionListener__Dispose_fn;
    type->fp_OnClearData = (void(*)(::g::Fuse::Reactive::ExpressionSubscriber*))ExpressionListener__OnClearData_fn;
    type->fp_OnDataCleared = ExpressionListener__OnDataCleared_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))ExpressionListener__Dispose_fn;
    return type;
}

// protected ExpressionListener(Fuse.Reactive.Expression source, Fuse.Reactive.IListener listener, Fuse.Reactive.Expression[] args, [Fuse.Reactive.ExpressionSubscriber.Flags flags]) :162
void ExpressionListener__ctor_2_fn(ExpressionListener* __this, ::g::Fuse::Reactive::Expression* source, uObject* listener, uArray* args, int32_t* flags)
{
    __this->ctor_2(source, listener, args, *flags);
}

// protected void ClearData() :190
void ExpressionListener__ClearData_fn(ExpressionListener* __this)
{
    __this->ClearData();
}

// public override void Dispose() :174
void ExpressionListener__Dispose_fn(ExpressionListener* __this)
{
    uStackFrame __("Fuse.Reactive.ExpressionListener", "Dispose()");
    __this->_listener = NULL;
    __this->_hasData = false;
    __this->_curData = NULL;
    ::g::Fuse::Reactive::ExpressionSubscriber__Dispose_fn(__this);
}

// internal Fuse.Reactive.IListener get_Listener() :160
void ExpressionListener__get_Listener_fn(ExpressionListener* __this, uObject** __retval)
{
    *__retval = __this->Listener();
}

// internal override void OnClearData() :185
void ExpressionListener__OnClearData_fn(ExpressionListener* __this)
{
    uStackFrame __("Fuse.Reactive.ExpressionListener", "OnClearData()");
    __this->ClearData();
}

// protected virtual void OnDataCleared() :202
void ExpressionListener__OnDataCleared_fn(ExpressionListener* __this)
{
}

// protected void SetData(object value) :205
void ExpressionListener__SetData_fn(ExpressionListener* __this, uObject* value)
{
    __this->SetData(value);
}

// protected ExpressionListener(Fuse.Reactive.Expression source, Fuse.Reactive.IListener listener, Fuse.Reactive.Expression[] args, [Fuse.Reactive.ExpressionSubscriber.Flags flags]) [instance] :162
void ExpressionListener::ctor_2(::g::Fuse::Reactive::Expression* source, uObject* listener, uArray* args, int32_t flags)
{
    uStackFrame __("Fuse.Reactive.ExpressionListener", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.IListener,Fuse.Reactive.Expression[],[Fuse.Reactive.ExpressionSubscriber.Flags])");
    ctor_1(args, flags, source);

    if (listener == NULL)
        U_THROW(::g::Uno::Exception::New2(::STRINGS[70/*"May not be ...*/]));

    if (source == NULL)
        U_THROW(::g::Uno::Exception::New2(::STRINGS[71/*"May not be ...*/]));

    _listener = listener;
    _source1 = source;
}

// protected void ClearData() [instance] :190
void ExpressionListener::ClearData()
{
    uStackFrame __("Fuse.Reactive.ExpressionListener", "ClearData()");

    if (_hasData && (_listener != NULL))
    {
        _hasData = false;
        _curData = NULL;
        ::g::Fuse::Reactive::IListener::OnLostData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_source1);
    }

    OnDataCleared();
}

// internal Fuse.Reactive.IListener get_Listener() [instance] :160
uObject* ExpressionListener::Listener()
{
    return _listener;
}

// protected void SetData(object value) [instance] :205
void ExpressionListener::SetData(uObject* value)
{
    uStackFrame __("Fuse.Reactive.ExpressionListener", "SetData(object)");

    if (!_hasData || (value != _curData))
    {
        _hasData = true;
        _curData = value;
        ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_source1, value);
    }
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\ExpressionListener.uno
// ----------------------------------------------------------------------------------------------------------

// public abstract class ExpressionSubscriber :14
// {
static void ExpressionSubscriber_build(uType* type)
{
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(ExpressionSubscriber_type, interface0),
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(ExpressionSubscriber_type, interface1));
    type->SetFields(2,
        uObject_typeof(), offsetof(ExpressionSubscriber, _source), 0,
        ExpressionSubscriber__Flags_typeof(), offsetof(ExpressionSubscriber, _flags), 0,
        ::g::Fuse::Reactive::Expression__Argument_typeof()->Array(), offsetof(ExpressionSubscriber, _args), 0);
    type->Reflection.SetFunctions(1,
        new uFunction("Init", NULL, (void*)ExpressionSubscriber__Init_fn, 0, false, uVoid_typeof(), 1, ::g::Fuse::Reactive::IContext_typeof()));
}

ExpressionSubscriber_type* ExpressionSubscriber_typeof()
{
    static uSStrong<ExpressionSubscriber_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InnerListener_typeof();
    options.FieldCount = 5;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(ExpressionSubscriber);
    options.TypeSize = sizeof(ExpressionSubscriber_type);
    type = (ExpressionSubscriber_type*)uClassType::New("Fuse.Reactive.ExpressionSubscriber", options);
    type->fp_build_ = ExpressionSubscriber_build;
    type->fp_Dispose = (void(*)(::g::Fuse::Reactive::InnerListener*))ExpressionSubscriber__Dispose_fn;
    type->fp_OnLostData = (void(*)(::g::Fuse::Reactive::InnerListener*, uObject*))ExpressionSubscriber__OnLostData_fn;
    type->fp_OnNewData = (void(*)(::g::Fuse::Reactive::InnerListener*, uObject*, uObject*))ExpressionSubscriber__OnNewData_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))ExpressionSubscriber__Dispose_fn;
    return type;
}

// internal ExpressionSubscriber(Fuse.Reactive.Expression[] args, Fuse.Reactive.ExpressionSubscriber.Flags flags, [object source]) :32
void ExpressionSubscriber__ctor_1_fn(ExpressionSubscriber* __this, uArray* args, int32_t* flags, uObject* source)
{
    __this->ctor_1(args, *flags, source);
}

// public override void Dispose() :125
void ExpressionSubscriber__Dispose_fn(ExpressionSubscriber* __this)
{
    uStackFrame __("Fuse.Reactive.ExpressionSubscriber", "Dispose()");

    for (int32_t i = 0; i < uPtr(__this->_args)->Length(); ++i)
        uPtr(uPtr(__this->_args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->Dispose();

    __this->_source = NULL;
    ::g::Fuse::Reactive::InnerListener__Dispose_fn(__this);
}

// public void Init(Fuse.Reactive.IContext context) :48
void ExpressionSubscriber__Init_fn(ExpressionSubscriber* __this, uObject* context)
{
    __this->Init(context);
}

// private bool IsOptional(int index) :82
void ExpressionSubscriber__IsOptional_fn(ExpressionSubscriber* __this, int32_t* index, bool* __retval)
{
    *__retval = __this->IsOptional(*index);
}

// protected override sealed void OnLostData(Fuse.Reactive.IExpression source) :68
void ExpressionSubscriber__OnLostData_fn(ExpressionSubscriber* __this, uObject* source)
{
    uStackFrame __("Fuse.Reactive.ExpressionSubscriber", "OnLostData(Fuse.Reactive.IExpression)");

    for (int32_t i = 0; i < uPtr(__this->_args)->Length(); ++i)
        if (uPtr(uPtr(__this->_args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->Source == source)
        {
            uPtr(uPtr(__this->_args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->Value(NULL);
            uPtr(uPtr(__this->_args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->HasValue(false);
        }

    __this->UpdateOperands();
}

// protected override sealed void OnNewData(Fuse.Reactive.IExpression source, object value) :55
void ExpressionSubscriber__OnNewData_fn(ExpressionSubscriber* __this, uObject* source, uObject* value)
{
    uStackFrame __("Fuse.Reactive.ExpressionSubscriber", "OnNewData(Fuse.Reactive.IExpression,object)");

    for (int32_t i = 0; i < uPtr(__this->_args)->Length(); ++i)
        if (uPtr(uPtr(__this->_args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->Source == source)
        {
            uPtr(uPtr(__this->_args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->Value(value);
            uPtr(uPtr(__this->_args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->HasValue(true);
        }

    __this->UpdateOperands();
}

// private void UpdateOperands() :97
void ExpressionSubscriber__UpdateOperands_fn(ExpressionSubscriber* __this)
{
    __this->UpdateOperands();
}

// internal ExpressionSubscriber(Fuse.Reactive.Expression[] args, Fuse.Reactive.ExpressionSubscriber.Flags flags, [object source]) [instance] :32
void ExpressionSubscriber::ctor_1(uArray* args, int32_t flags, uObject* source)
{
    uStackFrame __("Fuse.Reactive.ExpressionSubscriber", ".ctor(Fuse.Reactive.Expression[],Fuse.Reactive.ExpressionSubscriber.Flags,[object])");
    ::g::Fuse::Reactive::Expression__Argument* collection1;
    ctor_();
    _flags = flags;
    _source = ((source != NULL) ? source : this);
    _args = uArray::New(::g::Fuse::Reactive::Expression__Argument_typeof()->Array(), uPtr(args)->Length());

    for (int32_t i = 0; i < args->Length(); ++i)
    {
        if (uPtr(args)->Strong< ::g::Fuse::Reactive::Expression*>(i) == NULL)
            U_THROW(::g::Uno::Exception::New2(uString::Const("May not contain null: args")));

        uPtr(_args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i) = (collection1 = ::g::Fuse::Reactive::Expression__Argument::New1(), uPtr(collection1)->Source = (uObject*)uPtr(args)->Strong< ::g::Fuse::Reactive::Expression*>(i), collection1);
    }
}

// public void Init(Fuse.Reactive.IContext context) [instance] :48
void ExpressionSubscriber::Init(uObject* context)
{
    uStackFrame __("Fuse.Reactive.ExpressionSubscriber", "Init(Fuse.Reactive.IContext)");

    for (int32_t i = 0; i < uPtr(_args)->Length(); ++i)
        uPtr(uPtr(_args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->Subscription = ::g::Fuse::Reactive::IExpression::Subscribe(uInterface(uPtr(uPtr(uPtr(_args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->Source), ::TYPES[38/*Fuse.Reactive.IExpression*/]), context, (uObject*)this);

    UpdateOperands();
}

// private bool IsOptional(int index) [instance] :82
bool ExpressionSubscriber::IsOptional(int32_t index)
{
    if ((_flags & 1024) == 1024)
        return true;

    if (index == 0)
        return (_flags & 1) == 1;

    if (index == 1)
        return (_flags & 2) == 2;

    if (index == 2)
        return (_flags & 4) == 4;

    if (index == 3)
        return (_flags & 8) == 8;

    return false;
}

// private void UpdateOperands() [instance] :97
void ExpressionSubscriber::UpdateOperands()
{
    uStackFrame __("Fuse.Reactive.ExpressionSubscriber", "UpdateOperands()");
    ClearDiagnostic();

    try
    {
        {
            bool okay = true;

            for (int32_t i = 0; i < uPtr(_args)->Length(); ++i)
                if (!uPtr(uPtr(_args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->HasValue() && !IsOptional(i))
                {
                    okay = false;
                    break;
                }

            if (okay)
                OnArguments(_args);
            else
                OnClearData();
        }
    }

    catch (const uThrowable& __t)
    {
        if (uIs(__t.Exception, ::TYPES[49/*Fuse.MarshalException*/]))
        {
            ::g::Fuse::MarshalException* me = (::g::Fuse::MarshalException*)__t.Exception;
            OnClearData();
            SetDiagnostic(uPtr(me)->Message(), _source);
        }
        else         throw __t;
    }
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\ExpressionListener.uno
// ----------------------------------------------------------------------------------------------------------

// public enum ComputeExpression.Flags :226
uEnumType* ComputeExpression__Flags_typeof()
{
    static uSStrong<uEnumType*> type;
    if (type != NULL) return type;

    type = uEnumType::New("Fuse.Reactive.ComputeExpression.Flags", ::g::Uno::Int_typeof(), 9);
    type->SetLiterals(
        "None", 0LL,
        "Optional0", 1LL,
        "Optional1", 2LL,
        "Optional2", 4LL,
        "Optional3", 8LL,
        "AllOptional", 16LL,
        "OmitComputeWarning", 32LL,
        "DeprecatedVirtualFlags", 1024LL,
        "DeprecatedVirtualUnary", 2048LL);
    return type;
}

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\ExpressionListener.uno
// ----------------------------------------------------------------------------------------------------------

// public enum ExpressionSubscriber.Flags :17
uEnumType* ExpressionSubscriber__Flags_typeof()
{
    static uSStrong<uEnumType*> type;
    if (type != NULL) return type;

    type = uEnumType::New("Fuse.Reactive.ExpressionSubscriber.Flags", ::g::Uno::Int_typeof(), 6);
    type->SetLiterals(
        "None", 0LL,
        "Optional0", 1LL,
        "Optional1", 2LL,
        "Optional2", 4LL,
        "Optional3", 8LL,
        "AllOptional", 1024LL);
    return type;
}

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// internal delegate double UnaryFloatOperator.FloatOp(double value) :131
uDelegateType* UnaryFloatOperator__FloatOp_typeof()
{
    static uSStrong<uDelegateType*> type;
    if (type != NULL) return type;

    type = uDelegateType::New("Fuse.Reactive.UnaryFloatOperator.FloatOp", 1, 0);
    type->SetSignature(::g::Uno::Double_typeof(),
        ::g::Uno::Double_typeof());
    return type;
}

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// internal delegate double BinaryFloatOperator.FloatOp(double a, double b) :171
uDelegateType* BinaryFloatOperator__FloatOp_typeof()
{
    static uSStrong<uDelegateType*> type;
    if (type != NULL) return type;

    type = uDelegateType::New("Fuse.Reactive.BinaryFloatOperator.FloatOp", 2, 0);
    type->SetSignature(::g::Uno::Double_typeof(),
        ::g::Uno::Double_typeof(),
        ::g::Uno::Double_typeof());
    return type;
}

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Floor :311
// {
static void Floor_build(uType* type)
{
    ::STRINGS[72] = uString::Const("floor");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Floor__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Floor_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Floor);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Floor", options);
    type->fp_build_ = Floor_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Floor(Fuse.Reactive.Expression operand) :314
void Floor__ctor_5_fn(Floor* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Floor New(Fuse.Reactive.Expression operand) :314
void Floor__New1_fn(::g::Fuse::Reactive::Expression* operand, Floor** __retval)
{
    *__retval = Floor::New1(operand);
}

// public Floor(Fuse.Reactive.Expression operand) [instance] :314
void Floor::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[72/*"floor"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Floor_fn));
}

// public Floor New(Fuse.Reactive.Expression operand) [static] :314
Floor* Floor::New1(::g::Fuse::Reactive::Expression* operand)
{
    Floor* obj1 = (Floor*)uNew(Floor_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Fract :351
// {
static void Fract_build(uType* type)
{
    ::STRINGS[73] = uString::Const("fract");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Fract__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Fract_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Fract);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Fract", options);
    type->fp_build_ = Fract_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Fract(Fuse.Reactive.Expression operand) :354
void Fract__ctor_5_fn(Fract* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Fract New(Fuse.Reactive.Expression operand) :354
void Fract__New1_fn(::g::Fuse::Reactive::Expression* operand, Fract** __retval)
{
    *__retval = Fract::New1(operand);
}

// public Fract(Fuse.Reactive.Expression operand) [instance] :354
void Fract::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[73/*"fract"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Fract_fn));
}

// public Fract New(Fuse.Reactive.Expression operand) [static] :354
Fract* Fract::New1(::g::Fuse::Reactive::Expression* operand)
{
    Fract* obj1 = (Fract*)uNew(Fract_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class GreaterOrEqual :146
// {
static void GreaterOrEqual_build(uType* type)
{
    ::STRINGS[74] = uString::Const(">=");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)GreaterOrEqual__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* GreaterOrEqual_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InfixOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(GreaterOrEqual);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.GreaterOrEqual", options);
    type->fp_build_ = GreaterOrEqual_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))GreaterOrEqual__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public GreaterOrEqual(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :149
void GreaterOrEqual__ctor_6_fn(GreaterOrEqual* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_6(left, right);
}

// public GreaterOrEqual New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :149
void GreaterOrEqual__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, GreaterOrEqual** __retval)
{
    *__retval = GreaterOrEqual::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :151
void GreaterOrEqual__TryCompute1_fn(GreaterOrEqual* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    bool v = false;
    bool r = ::g::Fuse::Marshal::TryGreaterOrEqual(left, right, &v);
    *result = uBox(::TYPES[12/*bool*/], v);
    return *__retval = r, void();
}

// public GreaterOrEqual(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :149
void GreaterOrEqual::ctor_6(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    ctor_5(left, right, ::STRINGS[74/*">="*/], 0);
}

// public GreaterOrEqual New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :149
GreaterOrEqual* GreaterOrEqual::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    GreaterOrEqual* obj1 = (GreaterOrEqual*)uNew(GreaterOrEqual_typeof());
    obj1->ctor_6(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class GreaterThan :132
// {
static void GreaterThan_build(uType* type)
{
    ::STRINGS[75] = uString::Const(">");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)GreaterThan__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* GreaterThan_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InfixOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(GreaterThan);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.GreaterThan", options);
    type->fp_build_ = GreaterThan_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))GreaterThan__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public GreaterThan(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :135
void GreaterThan__ctor_6_fn(GreaterThan* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_6(left, right);
}

// public GreaterThan New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :135
void GreaterThan__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, GreaterThan** __retval)
{
    *__retval = GreaterThan::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :137
void GreaterThan__TryCompute1_fn(GreaterThan* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    bool v = false;
    bool r = ::g::Fuse::Marshal::TryGreaterThan(left, right, &v);
    *result = uBox(::TYPES[12/*bool*/], v);
    return *__retval = r, void();
}

// public GreaterThan(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :135
void GreaterThan::ctor_6(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    ctor_5(left, right, ::STRINGS[75/*">"*/], 0);
}

// public GreaterThan New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :135
GreaterThan* GreaterThan::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    GreaterThan* obj1 = (GreaterThan*)uNew(GreaterThan_typeof());
    obj1->ctor_6(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\IExpression.uno
// ---------------------------------------------------------------------------------------

// public abstract interface IContext :20
// {
uInterfaceType* IContext_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.IContext", 0, 0);
    type->Reflection.SetFunctions(3,
        new uFunction("get_Node", NULL, NULL, offsetof(IContext, fp_get_Node), false, ::g::Fuse::Node_typeof(), 0),
        new uFunction("Subscribe", NULL, NULL, offsetof(IContext, fp_Subscribe), false, ::g::Uno::IDisposable_typeof(), 3, ::g::Fuse::Reactive::IExpression_typeof(), ::g::Uno::String_typeof(), ::g::Fuse::Reactive::IListener_typeof()),
        new uFunction("SubscribeResource", NULL, NULL, offsetof(IContext, fp_SubscribeResource), false, ::g::Uno::IDisposable_typeof(), 3, ::g::Fuse::Reactive::IExpression_typeof(), ::g::Uno::String_typeof(), ::g::Fuse::Reactive::IListener_typeof()));
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\WindowList.uno
// -----------------------------------------------------------------------------------------------

// public abstract interface WindowListItem.IDataWatcher :13
// {
uInterfaceType* WindowListItem__IDataWatcher_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.WindowListItem.IDataWatcher", 0, 0);
    type->Reflection.SetFunctions(1,
        new uFunction("OnCurrentDataChanged", NULL, NULL, offsetof(WindowListItem__IDataWatcher, fp_OnCurrentDataChanged), false, uVoid_typeof(), 2, ::g::Fuse::Reactive::WindowListItem_typeof(), uObject_typeof()));
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\IEventHandler.uno
// -----------------------------------------------------------------------------------------

// public abstract interface IEventHandler :16
// {
uInterfaceType* IEventHandler_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.IEventHandler", 0, 0);
    type->Reflection.SetFunctions(1,
        new uFunction("Dispatch", NULL, NULL, offsetof(IEventHandler, fp_Dispatch), false, uVoid_typeof(), 1, ::g::Fuse::Reactive::IEventRecord_typeof()));
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\IEventHandler.uno
// -----------------------------------------------------------------------------------------

// public abstract interface IEventRecord :8
// {
uInterfaceType* IEventRecord_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.IEventRecord", 0, 0);
    type->Reflection.SetFunctions(4,
        new uFunction("get_Args", NULL, NULL, offsetof(IEventRecord, fp_get_Args), false, ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Uno::Collections::KeyValuePair_typeof()->MakeType(::g::Uno::String_typeof(), uObject_typeof(), NULL), NULL), 0),
        new uFunction("get_Data", NULL, NULL, offsetof(IEventRecord, fp_get_Data), false, uObject_typeof(), 0),
        new uFunction("get_Node", NULL, NULL, offsetof(IEventRecord, fp_get_Node), false, ::g::Fuse::Node_typeof(), 0),
        new uFunction("get_Sender", NULL, NULL, offsetof(IEventRecord, fp_get_Sender), false, ::g::Uno::UX::Selector_typeof(), 0));
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\IExpression.uno
// ---------------------------------------------------------------------------------------

// public abstract interface IExpression :45
// {
uInterfaceType* IExpression_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.IExpression", 0, 0);
    type->Reflection.SetFunctions(1,
        new uFunction("Subscribe", NULL, NULL, offsetof(IExpression, fp_Subscribe), false, ::g::Uno::IDisposable_typeof(), 2, ::g::Fuse::Reactive::IContext_typeof(), ::g::Fuse::Reactive::IListener_typeof()));
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\ItemsWindowList.uno
// ----------------------------------------------------------------------------------------------------

// public abstract interface ItemsWindowList<T>.IListener :15
// {
uInterfaceType* ItemsWindowList__IListener_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.ItemsWindowList`1.IListener", 1, 0);
    type->Reflection.SetFunctions(5,
        new uFunction("AddedWindowItem", NULL, NULL, offsetof(ItemsWindowList__IListener, fp_AddedWindowItem), false, uVoid_typeof(), 2, ::g::Uno::Int_typeof(), type->T(0)),
        new uFunction("OnCurrentDataChanged", NULL, NULL, offsetof(ItemsWindowList__IListener, fp_OnCurrentDataChanged), false, uVoid_typeof(), 2, type->T(0), uObject_typeof()),
        new uFunction("RemovedWindowItem", NULL, NULL, offsetof(ItemsWindowList__IListener, fp_RemovedWindowItem), false, uVoid_typeof(), 1, type->T(0)),
        new uFunction("SetFailed", NULL, NULL, offsetof(ItemsWindowList__IListener, fp_SetFailed), false, uVoid_typeof(), 1, ::g::Uno::String_typeof()),
        new uFunction("SetValid", NULL, NULL, offsetof(ItemsWindowList__IListener, fp_SetValid), false, uVoid_typeof(), 0));
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\IExpression.uno
// ---------------------------------------------------------------------------------------

// public abstract interface IListener :8
// {
uInterfaceType* IListener_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.IListener", 0, 0);
    type->Reflection.SetFunctions(2,
        new uFunction("OnLostData", NULL, NULL, offsetof(IListener, fp_OnLostData), false, uVoid_typeof(), 1, ::g::Fuse::Reactive::IExpression_typeof()),
        new uFunction("OnNewData", NULL, NULL, offsetof(IListener, fp_OnNewData), false, uVoid_typeof(), 2, ::g::Fuse::Reactive::IExpression_typeof(), uObject_typeof()));
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\InstantiatorFunction.uno
// ---------------------------------------------------------------------------------------------------------

// public sealed class IndexFunction :171
// {
static void IndexFunction_build(uType* type)
{
    type->SetDependencies(
        ::g::Fuse::Reactive::InstantiatorFunction_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->SetFields(2);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)IndexFunction__New1_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::Expression_type* IndexFunction_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InstantiatorFunction_typeof();
    options.FieldCount = 2;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(IndexFunction);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.IndexFunction", options);
    type->fp_build_ = IndexFunction_build;
    type->fp_ctor_ = (void*)IndexFunction__New1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::InstantiatorFunction__Subscribe_fn;
    return type;
}

// public IndexFunction() :174
void IndexFunction__ctor_3_fn(IndexFunction* __this)
{
    __this->ctor_3();
}

// public IndexFunction New() :174
void IndexFunction__New1_fn(IndexFunction** __retval)
{
    *__retval = IndexFunction::New1();
}

// public IndexFunction() [instance] :174
void IndexFunction::ctor_3()
{
    ctor_2(::g::Fuse::Reactive::InstantiatorFunction::DataIndexName());
}

// public IndexFunction New() [static] :174
IndexFunction* IndexFunction::New1()
{
    IndexFunction* obj1 = (IndexFunction*)uNew(IndexFunction_typeof());
    obj1->ctor_3();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public abstract class InfixOperator :7
// {
static void InfixOperator_build(uType* type)
{
    ::STRINGS[4] = uString::Const("(");
    ::STRINGS[30] = uString::Const(" ");
    ::STRINGS[6] = uString::Const(")");
    ::STRINGS[26] = uString::Const("");
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction("get_Symbol", NULL, (void*)InfixOperator__get_Symbol_fn, 0, false, ::g::Uno::String_typeof(), 0));
}

::g::Fuse::Reactive::BinaryOperator_type* InfixOperator_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::BinaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(InfixOperator);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.InfixOperator", options);
    type->fp_build_ = InfixOperator_build;
    type->fp_ToString = (void(*)(uObject*, uString**))InfixOperator__ToString_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// protected InfixOperator(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :11
void InfixOperator__ctor_4_fn(InfixOperator* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_4(left, right);
}

// protected InfixOperator(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right, string symbol, [Fuse.Reactive.ComputeExpression.Flags flags]) :13
void InfixOperator__ctor_5_fn(InfixOperator* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, uString* symbol, int32_t* flags)
{
    __this->ctor_5(left, right, symbol, *flags);
}

// public string get_Symbol() :18
void InfixOperator__get_Symbol_fn(InfixOperator* __this, uString** __retval)
{
    *__retval = __this->Symbol();
}

// public override sealed string ToString() :20
void InfixOperator__ToString_fn(InfixOperator* __this, uString** __retval)
{
    uStackFrame __("Fuse.Reactive.InfixOperator", "ToString()");
    uString* ind1;
    return *__retval = ::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::STRINGS[4/*"("*/], __this->Left()), ::STRINGS[30/*" "*/]), (ind1 = __this->Name(), (ind1 != NULL) ? ind1 : (uString*)__this->Symbol())), ::STRINGS[30/*" "*/]), __this->Right()), ::STRINGS[6/*")"*/]), void();
}

// protected InfixOperator(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :11
void InfixOperator::ctor_4(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    uStackFrame __("Fuse.Reactive.InfixOperator", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression)");
    ctor_2(left, right, 1024);
}

// protected InfixOperator(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right, string symbol, [Fuse.Reactive.ComputeExpression.Flags flags]) [instance] :13
void InfixOperator::ctor_5(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, uString* symbol, int32_t flags)
{
    uStackFrame __("Fuse.Reactive.InfixOperator", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression,string,[Fuse.Reactive.ComputeExpression.Flags])");
    ctor_3(left, right, symbol, flags);
}

// public string get_Symbol() [instance] :18
uString* InfixOperator::Symbol()
{
    return ::STRINGS[26/*""*/];
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Subscription.uno
// ----------------------------------------------------------------------------------------------------

// public abstract class InnerListener :19
// {
static void InnerListener_build(uType* type)
{
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(InnerListener_type, interface0),
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(InnerListener_type, interface1));
    type->SetFields(0,
        ::g::Uno::IDisposable_typeof(), offsetof(InnerListener, _diag), 0,
        ::g::Uno::Collections::Dictionary_typeof()->MakeType(::g::Fuse::Reactive::IExpression_typeof(), InnerListener__ObservableSubscription_typeof(), NULL), offsetof(InnerListener, _obsSubs), 0);
    type->Reflection.SetFunctions(3,
        new uFunction("ClearDiagnostic", NULL, (void*)InnerListener__ClearDiagnostic_fn, 0, false, uVoid_typeof(), 0),
        new uFunction("Dispose", NULL, NULL, offsetof(InnerListener_type, fp_Dispose), false, uVoid_typeof(), 0),
        new uFunction("SetDiagnostic", NULL, (void*)InnerListener__SetDiagnostic_fn, 0, false, uVoid_typeof(), 2, ::g::Uno::String_typeof(), uObject_typeof()));
}

InnerListener_type* InnerListener_typeof()
{
    static uSStrong<InnerListener_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 2;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(InnerListener);
    options.TypeSize = sizeof(InnerListener_type);
    type = (InnerListener_type*)uClassType::New("Fuse.Reactive.InnerListener", options);
    type->fp_build_ = InnerListener_build;
    type->fp_Dispose = InnerListener__Dispose_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))InnerListener__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))InnerListener__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))InnerListener__Dispose_fn;
    return type;
}

// protected generated InnerListener() :19
void InnerListener__ctor__fn(InnerListener* __this)
{
    __this->ctor_();
}

// public void ClearDiagnostic() :32
void InnerListener__ClearDiagnostic_fn(InnerListener* __this)
{
    __this->ClearDiagnostic();
}

// public virtual void Dispose() :41
void InnerListener__Dispose_fn(InnerListener* __this)
{
    uStackFrame __("Fuse.Reactive.InnerListener", "Dispose()");
    ::g::Uno::Collections::Dictionary__ValueCollection__Enumerator<uStrong<InnerListener__ObservableSubscription*> > ret2;
    __this->ClearDiagnostic();

    if (__this->_obsSubs != NULL)
    {
        ::g::Uno::Collections::Dictionary__ValueCollection__Enumerator<uStrong<InnerListener__ObservableSubscription*> > enum1 = (::g::Uno::Collections::Dictionary__ValueCollection__GetEnumerator_fn(uPtr((::g::Uno::Collections::Dictionary__ValueCollection*)uPtr(__this->_obsSubs)->Values()), &ret2), ret2);

        {
            try
            {
                {
                    while (enum1.MoveNext(::g::Uno::Collections::Dictionary__ValueCollection__Enumerator_typeof()->MakeType(::TYPES[38/*Fuse.Reactive.IExpression*/], InnerListener__ObservableSubscription_typeof(), NULL)))
                    {
                        InnerListener__ObservableSubscription* k = enum1.Current(::g::Uno::Collections::Dictionary__ValueCollection__Enumerator_typeof()->MakeType(::TYPES[38/*Fuse.Reactive.IExpression*/], InnerListener__ObservableSubscription_typeof(), NULL));
                        uPtr(k)->Dispose();
                    }
                }
            }

            catch (const uThrowable& __t)
            {
                {
                    enum1.Dispose(::g::Uno::Collections::Dictionary__ValueCollection__Enumerator_typeof()->MakeType(::TYPES[38/*Fuse.Reactive.IExpression*/], InnerListener__ObservableSubscription_typeof(), NULL));
                }
                                throw __t;
                goto __after_finally_0;
            }

            {
                enum1.Dispose(::g::Uno::Collections::Dictionary__ValueCollection__Enumerator_typeof()->MakeType(::TYPES[38/*Fuse.Reactive.IExpression*/], InnerListener__ObservableSubscription_typeof(), NULL));
            }
            __after_finally_0:;
        }

        uPtr(__this->_obsSubs)->Clear();
        __this->_obsSubs = NULL;
    }
}

// private void Fuse.Reactive.IListener.OnLostData(Fuse.Reactive.IExpression source) :77
void InnerListener__FuseReactiveIListenerOnLostData_fn(InnerListener* __this, uObject* source)
{
    uStackFrame __("Fuse.Reactive.InnerListener", "Fuse.Reactive.IListener.OnLostData(Fuse.Reactive.IExpression)");
    __this->OnLostData(source);
}

// private void Fuse.Reactive.IListener.OnNewData(Fuse.Reactive.IExpression source, object value) :55
void InnerListener__FuseReactiveIListenerOnNewData_fn(InnerListener* __this, uObject* source, uObject* value)
{
    uStackFrame __("Fuse.Reactive.InnerListener", "Fuse.Reactive.IListener.OnNewData(Fuse.Reactive.IExpression,object)");
    bool ret3;
    bool ret4;
    InnerListener__ObservableSubscription* obsSub = NULL;

    if ((__this->_obsSubs != NULL) && (::g::Uno::Collections::Dictionary__TryGetValue_fn(uPtr(__this->_obsSubs), source, (void**)(&obsSub), &ret3), ret3))
    {
        uPtr(obsSub)->Dispose();
        ::g::Uno::Collections::Dictionary__Remove_fn(uPtr(__this->_obsSubs), source, &ret4);
    }

    uObject* obs = uAs<uObject*>(value, ::TYPES[46/*Fuse.Reactive.IObservable*/]);

    if (obs != NULL)
    {
        if (__this->_obsSubs == NULL)
            __this->_obsSubs = ((::g::Uno::Collections::Dictionary*)::g::Uno::Collections::Dictionary::New1(::g::Uno::Collections::Dictionary_typeof()->MakeType(::TYPES[38/*Fuse.Reactive.IExpression*/], InnerListener__ObservableSubscription_typeof(), NULL)));

        ::g::Uno::Collections::Dictionary__Add_fn(uPtr(__this->_obsSubs), source, InnerListener__ObservableSubscription::New1(source, obs, __this));
    }
    else
        __this->OnNewData(source, value);
}

// public void SetDiagnostic(string message, object source) :26
void InnerListener__SetDiagnostic_fn(InnerListener* __this, uString* message, uObject* source)
{
    __this->SetDiagnostic(message, source);
}

// protected generated InnerListener() [instance] :19
void InnerListener::ctor_()
{
}

// public void ClearDiagnostic() [instance] :32
void InnerListener::ClearDiagnostic()
{
    uStackFrame __("Fuse.Reactive.InnerListener", "ClearDiagnostic()");

    if (_diag != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_diag), ::TYPES[3/*Uno.IDisposable*/]));
        _diag = NULL;
    }
}

// public void SetDiagnostic(string message, object source) [instance] :26
void InnerListener::SetDiagnostic(uString* message, uObject* source)
{
    uStackFrame __("Fuse.Reactive.InnerListener", "SetDiagnostic(string,object)");
    ClearDiagnostic();
    _diag = ::g::Fuse::Diagnostics::ReportTemporalUserWarning(message, source);
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Instance.uno
// ---------------------------------------------------------------------------------------------

// public sealed class Instance :12
// {
static void Instance_build(uType* type)
{
    ::TYPES[4] = uObject_typeof()->Array();
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::Instantiator_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::Instantiator_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::Instantiator_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::Instantiator_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::Instantiator_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::Instantiator_type, interface5),
        ::g::Fuse::Node__ISubtreeDataProvider_typeof(), offsetof(::g::Fuse::Reactive::Instantiator_type, interface6),
        ::g::Fuse::IDeferred_typeof(), offsetof(::g::Fuse::Reactive::Instantiator_type, interface7),
        ::g::Fuse::Reactive::ItemsWindowList__IListener_typeof()->MakeType(::g::Fuse::Reactive::WindowItem_typeof(), NULL), offsetof(::g::Fuse::Reactive::Instantiator_type, interface8));
    type->SetFields(37,
        uObject_typeof(), offsetof(Instance, _item), 0,
        ::g::Uno::Bool_typeof(), offsetof(Instance, _isEnabled), 0);
    type->Reflection.SetFunctions(5,
        new uFunction("get_IsEnabled", NULL, (void*)Instance__get_IsEnabled_fn, 0, false, ::g::Uno::Bool_typeof(), 0),
        new uFunction("set_IsEnabled", NULL, (void*)Instance__set_IsEnabled_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::Bool_typeof()),
        new uFunction("get_Item", NULL, (void*)Instance__get_Item_fn, 0, false, uObject_typeof(), 0),
        new uFunction("set_Item", NULL, (void*)Instance__set_Item_fn, 0, false, uVoid_typeof(), 1, uObject_typeof()),
        new uFunction(".ctor", NULL, (void*)Instance__New4_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::Instantiator_type* Instance_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Instantiator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Instantiator_typeof();
    options.FieldCount = 39;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(Instance);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Instantiator_type);
    type = (::g::Fuse::Reactive::Instantiator_type*)uClassType::New("Fuse.Reactive.Instance", options);
    type->fp_build_ = Instance_build;
    type->fp_ctor_ = (void*)Instance__New4_fn;
    type->interface8.fp_SetValid = (void(*)(uObject*))::g::Fuse::Reactive::Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerSetValid_fn;
    type->interface8.fp_SetFailed = (void(*)(uObject*, uString*))::g::Fuse::Reactive::Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerSetFailed_fn;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, ::g::Fuse::Node*, int32_t*, uObject**, int32_t*))::g::Fuse::Reactive::Instantiator__FuseNodeISubtreeDataProviderTryGetDataProvider_fn;
    type->interface8.fp_AddedWindowItem = (void(*)(uObject*, int32_t*, ::g::Fuse::Reactive::WindowListItem*))::g::Fuse::Reactive::Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerAddedWindowItem_fn;
    type->interface7.fp_Perform = (void(*)(uObject*, bool*))::g::Fuse::Reactive::Instantiator__FuseIDeferredPerform_fn;
    type->interface8.fp_RemovedWindowItem = (void(*)(uObject*, ::g::Fuse::Reactive::WindowListItem*))::g::Fuse::Reactive::Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerRemovedWindowItem_fn;
    type->interface8.fp_OnCurrentDataChanged = (void(*)(uObject*, ::g::Fuse::Reactive::WindowListItem*, uObject*))::g::Fuse::Reactive::Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerOnCurrentDataChanged_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public Instance() :14
void Instance__ctor_5_fn(Instance* __this)
{
    __this->ctor_5();
}

// public bool get_IsEnabled() :65
void Instance__get_IsEnabled_fn(Instance* __this, bool* __retval)
{
    *__retval = __this->IsEnabled();
}

// public void set_IsEnabled(bool value) :66
void Instance__set_IsEnabled_fn(Instance* __this, bool* value)
{
    __this->IsEnabled(*value);
}

// public object get_Item() :35
void Instance__get_Item_fn(Instance* __this, uObject** __retval)
{
    *__retval = __this->Item();
}

// public void set_Item(object value) :36
void Instance__set_Item_fn(Instance* __this, uObject* value)
{
    __this->Item(value);
}

// public Instance New() :14
void Instance__New4_fn(Instance** __retval)
{
    *__retval = Instance::New4();
}

// private void UpdateItems() :45
void Instance__UpdateItems_fn(Instance* __this)
{
    __this->UpdateItems();
}

// public Instance() [instance] :14
void Instance::ctor_5()
{
    uStackFrame __("Fuse.Reactive.Instance", ".ctor()");
    _isEnabled = true;
    ctor_3();
    Item(::g::Fuse::Reactive::Instantiator__NoContextItem::New1());
}

// public bool get_IsEnabled() [instance] :65
bool Instance::IsEnabled()
{
    return _isEnabled;
}

// public void set_IsEnabled(bool value) [instance] :66
void Instance::IsEnabled(bool value)
{
    uStackFrame __("Fuse.Reactive.Instance", "set_IsEnabled(bool)");

    if (_isEnabled == value)
        return;

    _isEnabled = value;
    UpdateItems();
}

// public object get_Item() [instance] :35
uObject* Instance::Item()
{
    return _item;
}

// public void set_Item(object value) [instance] :36
void Instance::Item(uObject* value)
{
    uStackFrame __("Fuse.Reactive.Instance", "set_Item(object)");

    if (_item == value)
        return;

    _item = value;
    UpdateItems();
}

// private void UpdateItems() [instance] :45
void Instance::UpdateItems()
{
    uStackFrame __("Fuse.Reactive.Instance", "UpdateItems()");

    if (IsEnabled())
        SetItems(uArray::Init<uObject*>(::TYPES[4/*object[]*/], 1, (uObject*)_item));
    else
        SetItems(uArray::Init<uObject*>(::TYPES[4/*object[]*/], 0));
}

// public Instance New() [static] :14
Instance* Instance::New4()
{
    Instance* obj1 = (Instance*)uNew(Instance_typeof());
    obj1->ctor_5();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Instantiator.uno
// -------------------------------------------------------------------------------------------------

// public enum InstanceDefaults :58
uEnumType* InstanceDefaults_typeof()
{
    static uSStrong<uEnumType*> type;
    if (type != NULL) return type;

    type = uEnumType::New("Fuse.Reactive.InstanceDefaults", ::g::Uno::Int_typeof(), 3);
    type->SetLiterals(
        "Standard", 0LL,
        "Default", 1LL,
        "None", 2LL);
    return type;
}

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Instantiator.uno
// -------------------------------------------------------------------------------------------------

// public enum InstanceDefer :15
uEnumType* InstanceDefer_typeof()
{
    static uSStrong<uEnumType*> type;
    if (type != NULL) return type;

    type = uEnumType::New("Fuse.Reactive.InstanceDefer", ::g::Uno::Int_typeof(), 3);
    type->SetLiterals(
        "Immediate", 0LL,
        "Frame", 1LL,
        "Deferred", 2LL);
    return type;
}

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Instantiator.uno
// -------------------------------------------------------------------------------------------------

// public enum InstanceIdentity :43
uEnumType* InstanceIdentity_typeof()
{
    static uSStrong<uEnumType*> type;
    if (type != NULL) return type;

    type = uEnumType::New("Fuse.Reactive.InstanceIdentity", ::g::Uno::Int_typeof(), 3);
    type->SetLiterals(
        "None", 0LL,
        "Key", 1LL,
        "Object", 2LL);
    return type;
}

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Instantiator.uno
// -------------------------------------------------------------------------------------------------

// public enum InstanceReuse :30
uEnumType* InstanceReuse_typeof()
{
    static uSStrong<uEnumType*> type;
    if (type != NULL) return type;

    type = uEnumType::New("Fuse.Reactive.InstanceReuse", ::g::Uno::Int_typeof(), 2);
    type->SetLiterals(
        "None", 0LL,
        "Frame", 1LL);
    return type;
}

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Instantiator.uno
// -------------------------------------------------------------------------------------------------

// public partial class Instantiator :116
// {
static void Instantiator_build(uType* type)
{
    type->SetDependencies(
        ::g::Fuse::Triggers::BusyTask_typeof(),
        ::g::Fuse::DeferredManager_typeof(),
        ::g::Fuse::UpdateManager_typeof());
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(Instantiator_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(Instantiator_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(Instantiator_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(Instantiator_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(Instantiator_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(Instantiator_type, interface5),
        ::g::Fuse::Node__ISubtreeDataProvider_typeof(), offsetof(Instantiator_type, interface6),
        ::g::Fuse::IDeferred_typeof(), offsetof(Instantiator_type, interface7),
        ::g::Fuse::Reactive::ItemsWindowList__IListener_typeof()->MakeType(::g::Fuse::Reactive::WindowItem_typeof(), NULL), offsetof(Instantiator_type, interface8));
    type->SetFields(16,
        ::g::Fuse::Triggers::BusyTask_typeof(), offsetof(Instantiator, _busyTask), 0,
        ::g::Uno::Action1_typeof()->MakeType(::g::Fuse::Node_typeof(), NULL), offsetof(Instantiator, _completedRemove), 0,
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Uno::UX::Template_typeof(), NULL), offsetof(Instantiator, _templates), 0,
        ::g::Uno::Collections::RootableList_typeof()->MakeType(::g::Uno::UX::Template_typeof(), NULL), offsetof(Instantiator, _rootTemplates), 0,
        ::g::Fuse::Reactive::InstanceDefer_typeof(), offsetof(Instantiator, _defer), 0,
        ::g::Fuse::Reactive::InstanceReuse_typeof(), offsetof(Instantiator, _reuse), 0,
        ::g::Uno::Float_typeof(), offsetof(Instantiator, _deferredPriority), 0,
        ::g::Fuse::ITemplateSource_typeof(), offsetof(Instantiator, _weakTemplateSource), uFieldFlagsWeak,
        ::g::Fuse::ITemplateSource_typeof(), offsetof(Instantiator, _templateSource), 0,
        ::g::Uno::String_typeof(), offsetof(Instantiator, _templateKey), 0,
        ::g::Uno::String_typeof(), offsetof(Instantiator, _matchKey), 0,
        ::g::Uno::String_typeof(), offsetof(Instantiator, _match), 0,
        ::g::Fuse::Reactive::InstanceDefaults_typeof(), offsetof(Instantiator, _defaults), 0,
        ::g::Uno::Collections::Dictionary_typeof()->MakeType(::g::Fuse::Node_typeof(), ::g::Fuse::Reactive::WindowItem_typeof(), NULL), offsetof(Instantiator, _dataMap), 0,
        ::g::Uno::Bool_typeof(), offsetof(Instantiator, _pendingNew), 0,
        ::g::Uno::Collections::Dictionary_typeof()->MakeType(uObject_typeof(), ::g::Fuse::Reactive::WindowItem_typeof(), NULL), offsetof(Instantiator, _availableItemsById), 0,
        ::g::Fuse::Internal::ObjectList_typeof()->MakeType(::g::Fuse::Reactive::WindowItem_typeof(), NULL), offsetof(Instantiator, _availableItems), 0,
        ::g::Uno::Bool_typeof(), offsetof(Instantiator, _pendingAvailableItems), 0,
        ::g::Fuse::Reactive::ItemsWindowList_typeof()->MakeType(::g::Fuse::Reactive::WindowItem_typeof(), NULL), offsetof(Instantiator, _watcher), 0,
        ::g::Uno::Bool_typeof(), offsetof(Instantiator, _pendingUpdateWindowItems), 0,
        ::g::Uno::Action_typeof(), offsetof(Instantiator, UpdatedWindowItems1), 0);
    type->Reflection.SetFunctions(21,
        new uFunction("get_Defaults", NULL, (void*)Instantiator__get_Defaults_fn, 0, false, ::g::Fuse::Reactive::InstanceDefaults_typeof(), 0),
        new uFunction("set_Defaults", NULL, (void*)Instantiator__set_Defaults_fn, 0, false, uVoid_typeof(), 1, ::g::Fuse::Reactive::InstanceDefaults_typeof()),
        new uFunction("get_Defer", NULL, (void*)Instantiator__get_Defer_fn, 0, false, ::g::Fuse::Reactive::InstanceDefer_typeof(), 0),
        new uFunction("set_Defer", NULL, (void*)Instantiator__set_Defer_fn, 0, false, uVoid_typeof(), 1, ::g::Fuse::Reactive::InstanceDefer_typeof()),
        new uFunction("get_DeferredPriority", NULL, (void*)Instantiator__get_DeferredPriority_fn, 0, false, ::g::Uno::Float_typeof(), 0),
        new uFunction("set_DeferredPriority", NULL, (void*)Instantiator__set_DeferredPriority_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::Float_typeof()),
        new uFunction("get_Identity", NULL, (void*)Instantiator__get_Identity_fn, 0, false, ::g::Fuse::Reactive::InstanceIdentity_typeof(), 0),
        new uFunction("set_Identity", NULL, (void*)Instantiator__set_Identity_fn, 0, false, uVoid_typeof(), 1, ::g::Fuse::Reactive::InstanceIdentity_typeof()),
        new uFunction("get_IdentityKey", NULL, (void*)Instantiator__get_IdentityKey_fn, 0, false, ::g::Uno::String_typeof(), 0),
        new uFunction("set_IdentityKey", NULL, (void*)Instantiator__set_IdentityKey_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::String_typeof()),
        new uFunction("get_Match", NULL, (void*)Instantiator__get_Match_fn, 0, false, ::g::Uno::String_typeof(), 0),
        new uFunction("set_Match", NULL, (void*)Instantiator__set_Match_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::String_typeof()),
        new uFunction("get_MatchKey", NULL, (void*)Instantiator__get_MatchKey_fn, 0, false, ::g::Uno::String_typeof(), 0),
        new uFunction("set_MatchKey", NULL, (void*)Instantiator__set_MatchKey_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::String_typeof()),
        new uFunction("get_Reuse", NULL, (void*)Instantiator__get_Reuse_fn, 0, false, ::g::Fuse::Reactive::InstanceReuse_typeof(), 0),
        new uFunction("set_Reuse", NULL, (void*)Instantiator__set_Reuse_fn, 0, false, uVoid_typeof(), 1, ::g::Fuse::Reactive::InstanceReuse_typeof()),
        new uFunction("get_TemplateKey", NULL, (void*)Instantiator__get_TemplateKey_fn, 0, false, ::g::Uno::String_typeof(), 0),
        new uFunction("set_TemplateKey", NULL, (void*)Instantiator__set_TemplateKey_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::String_typeof()),
        new uFunction("get_Templates", NULL, (void*)Instantiator__get_Templates_fn, 0, false, ::g::Uno::Collections::IList_typeof()->MakeType(::g::Uno::UX::Template_typeof(), NULL), 0),
        new uFunction("get_TemplateSource", NULL, (void*)Instantiator__get_TemplateSource_fn, 0, false, ::g::Fuse::ITemplateSource_typeof(), 0),
        new uFunction("set_TemplateSource", NULL, (void*)Instantiator__set_TemplateSource_fn, 0, false, uVoid_typeof(), 1, ::g::Fuse::ITemplateSource_typeof()));
}

Instantiator_type* Instantiator_typeof()
{
    static uSStrong<Instantiator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Behavior_typeof();
    options.FieldCount = 37;
    options.InterfaceCount = 9;
    options.DependencyCount = 3;
    options.ObjectSize = sizeof(Instantiator);
    options.TypeSize = sizeof(Instantiator_type);
    type = (Instantiator_type*)uClassType::New("Fuse.Reactive.Instantiator", options);
    type->fp_build_ = Instantiator_build;
    type->fp_ctor_ = (void*)Instantiator__New2_fn;
    type->fp_GetLastNodeInGroup = (void(*)(::g::Fuse::Node*, ::g::Fuse::Node**))Instantiator__GetLastNodeInGroup_fn;
    type->fp_OnRooted = (void(*)(::g::Fuse::Node*))Instantiator__OnRooted_fn;
    type->fp_OnUnrooted = (void(*)(::g::Fuse::Node*))Instantiator__OnUnrooted_fn;
    type->interface8.fp_SetValid = (void(*)(uObject*))Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerSetValid_fn;
    type->interface8.fp_SetFailed = (void(*)(uObject*, uString*))Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerSetFailed_fn;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, ::g::Fuse::Node*, int32_t*, uObject**, int32_t*))Instantiator__FuseNodeISubtreeDataProviderTryGetDataProvider_fn;
    type->interface8.fp_AddedWindowItem = (void(*)(uObject*, int32_t*, ::g::Fuse::Reactive::WindowListItem*))Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerAddedWindowItem_fn;
    type->interface7.fp_Perform = (void(*)(uObject*, bool*))Instantiator__FuseIDeferredPerform_fn;
    type->interface8.fp_RemovedWindowItem = (void(*)(uObject*, ::g::Fuse::Reactive::WindowListItem*))Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerRemovedWindowItem_fn;
    type->interface8.fp_OnCurrentDataChanged = (void(*)(uObject*, ::g::Fuse::Reactive::WindowListItem*, uObject*))Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerOnCurrentDataChanged_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// protected internal Instantiator() :127
void Instantiator__ctor_3_fn(Instantiator* __this)
{
    __this->ctor_3();
}

// protected internal Instantiator(Uno.Collections.IList<Uno.UX.Template> templates) :120
void Instantiator__ctor_4_fn(Instantiator* __this, uObject* templates)
{
    __this->ctor_4(templates);
}

// private bool AddMatchingTemplates(Fuse.Reactive.WindowItem item, Fuse.Reactive.TemplateMatch f) :690
void Instantiator__AddMatchingTemplates_fn(Instantiator* __this, ::g::Fuse::Reactive::WindowItem* item, ::g::Fuse::Reactive::TemplateMatch* f, bool* __retval)
{
    *__retval = __this->AddMatchingTemplates(item, *f);
}

// private void AddTemplate(Fuse.Reactive.WindowItem item, Uno.UX.Template f) :736
void Instantiator__AddTemplate_fn(Instantiator* __this, ::g::Fuse::Reactive::WindowItem* item, ::g::Uno::UX::Template* f)
{
    __this->AddTemplate(item, f);
}

// private void BroadcastDataChange(Fuse.Reactive.WindowItem wi, object oldData) :914
void Instantiator__BroadcastDataChange1_fn(Instantiator* __this, ::g::Fuse::Reactive::WindowItem* wi, uObject* oldData)
{
    __this->BroadcastDataChange1(wi, oldData);
}

// private void CleanupWindowItem(Fuse.Reactive.WindowItem wi) :843
void Instantiator__CleanupWindowItem_fn(Instantiator* __this, ::g::Fuse::Reactive::WindowItem* wi)
{
    __this->CleanupWindowItem(wi);
}

// private void CompletedRemove(Fuse.Node n) :184
void Instantiator__CompletedRemove_fn(Instantiator* __this, ::g::Fuse::Node* n)
{
    __this->CompletedRemove(n);
}

// private void CompleteWindowItem(Fuse.Reactive.WindowItem wi, int windowIndex) :664
void Instantiator__CompleteWindowItem_fn(Instantiator* __this, ::g::Fuse::Reactive::WindowItem* wi, int32_t* windowIndex)
{
    __this->CompleteWindowItem(wi, *windowIndex);
}

// private bool CompleteWindowItems(bool one) :592
void Instantiator__CompleteWindowItems_fn(Instantiator* __this, bool* one, bool* __retval)
{
    *__retval = __this->CompleteWindowItems(*one);
}

// private void CompleteWindowItemsAction() :586
void Instantiator__CompleteWindowItemsAction_fn(Instantiator* __this)
{
    __this->CompleteWindowItemsAction();
}

// internal int get_DataCount() :517
void Instantiator__get_DataCount_fn(Instantiator* __this, int32_t* __retval)
{
    *__retval = __this->DataCount();
}

// internal int DataIndexOfChild(Fuse.Node child) :499
void Instantiator__DataIndexOfChild_fn(Instantiator* __this, ::g::Fuse::Node* child, int32_t* __retval)
{
    *__retval = __this->DataIndexOfChild(child);
}

// public Fuse.Reactive.InstanceDefaults get_Defaults() :486
void Instantiator__get_Defaults_fn(Instantiator* __this, int32_t* __retval)
{
    *__retval = __this->Defaults();
}

// public void set_Defaults(Fuse.Reactive.InstanceDefaults value) :487
void Instantiator__set_Defaults_fn(Instantiator* __this, int32_t* value)
{
    __this->Defaults(*value);
}

// public Fuse.Reactive.InstanceDefer get_Defer() :231
void Instantiator__get_Defer_fn(Instantiator* __this, int32_t* __retval)
{
    *__retval = __this->Defer();
}

// public void set_Defer(Fuse.Reactive.InstanceDefer value) :232
void Instantiator__set_Defer_fn(Instantiator* __this, int32_t* value)
{
    __this->Defer(*value);
}

// public float get_DeferredPriority() :296
void Instantiator__get_DeferredPriority_fn(Instantiator* __this, float* __retval)
{
    *__retval = __this->DeferredPriority();
}

// public void set_DeferredPriority(float value) :297
void Instantiator__set_DeferredPriority_fn(Instantiator* __this, float* value)
{
    __this->DeferredPriority(*value);
}

// private void DisposeWindowItem(Fuse.Reactive.WindowItem wi) :837
void Instantiator__DisposeWindowItem_fn(Instantiator* __this, ::g::Fuse::Reactive::WindowItem* wi)
{
    __this->DisposeWindowItem(wi);
}

// private bool Fuse.IDeferred.Perform() :580
void Instantiator__FuseIDeferredPerform_fn(Instantiator* __this, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "Fuse.IDeferred.Perform()");
    __this->_pendingNew = __this->CompleteWindowItems(true);
    return *__retval = !__this->_pendingNew, void();
}

// private Fuse.Node.ContextDataResult Fuse.Node.ISubtreeDataProvider.TryGetDataProvider(Fuse.Node n, Fuse.Node.DataType type, object& provider) :519
void Instantiator__FuseNodeISubtreeDataProviderTryGetDataProvider_fn(Instantiator* __this, ::g::Fuse::Node* n, int32_t* type, uObject** provider, int32_t* __retval)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "Fuse.Node.ISubtreeDataProvider.TryGetDataProvider(Fuse.Node,Fuse.Node.DataType,object&)");
    bool ret15;
    int32_t type_ = *type;
    *provider = NULL;
    ::g::Fuse::Reactive::WindowItem* v;

    if ((::g::Uno::Collections::Dictionary__TryGetValue_fn(uPtr(__this->_dataMap), n, (void**)(&v), &ret15), ret15))
    {
        if (uIs((uObject*)uPtr(v)->Data(), Instantiator__NoContextItem_typeof()))
            return *__retval = 0, void();

        *provider = uPtr(v)->CurrentData();
        return *__retval = (type_ == 1) ? 2 : 0, void();
    }

    return *__retval = 0, void();
}

// private void Fuse.Reactive.ItemsWindowList<Fuse.Reactive.WindowItem>.IListener.AddedWindowItem(int windowIndex, Fuse.Reactive.WindowItem wi) :558
void Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerAddedWindowItem_fn(Instantiator* __this, int32_t* windowIndex, ::g::Fuse::Reactive::WindowItem* wi)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "Fuse.Reactive.ItemsWindowList<Fuse.Reactive.WindowItem>.IListener.AddedWindowItem(int,Fuse.Reactive.WindowItem)");
    int32_t windowIndex_ = *windowIndex;
    __this->PrepareWindowItem(windowIndex_, wi);
    __this->OnUpdatedWindowItems();
}

// private void Fuse.Reactive.ItemsWindowList<Fuse.Reactive.WindowItem>.IListener.OnCurrentDataChanged(Fuse.Reactive.WindowItem wi, object oldData) :894
void Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerOnCurrentDataChanged_fn(Instantiator* __this, ::g::Fuse::Reactive::WindowItem* wi, uObject* oldData)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "Fuse.Reactive.ItemsWindowList<Fuse.Reactive.WindowItem>.IListener.OnCurrentDataChanged(Fuse.Reactive.WindowItem,object)");
    ::g::Fuse::Reactive::TemplateMatch tpl = __this->GetDataTemplate(uPtr(wi)->CurrentData());

    if (!tpl.Matches(wi->Template))
    {
        int32_t index = uPtr(__this->_watcher)->GetWindowItemIndex(wi);

        if (index == -1)
        {
            ::g::Fuse::Diagnostics::InternalError(uString::Const("Invalid WindowItem updated"), __this, uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Bindings\\1.8.1\\Instantiator.uno"), 903, uString::Const("Fuse.Reactive.ItemsWindowList<Fuse.Reactive.WindowItem>.IListener.OnCurrentDataChanged"));
            return;
        }

        __this->CleanupWindowItem(wi);
        __this->PrepareWindowItem(index, wi);
        return;
    }

    __this->BroadcastDataChange1(wi, oldData);
}

// private void Fuse.Reactive.ItemsWindowList<Fuse.Reactive.WindowItem>.IListener.RemovedWindowItem(Fuse.Reactive.WindowItem wi) :854
void Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerRemovedWindowItem_fn(Instantiator* __this, ::g::Fuse::Reactive::WindowItem* wi)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "Fuse.Reactive.ItemsWindowList<Fuse.Reactive.WindowItem>.IListener.RemovedWindowItem(Fuse.Reactive.WindowItem)");
    bool ret16;

    if ((uPtr(wi)->Nodes == NULL) || (uPtr(uPtr(wi)->Nodes)->Count() == 0))
        return;

    bool generic = uPtr(wi)->Id() == NULL;

    if (wi->Id() != NULL)
    {
        if (__this->_availableItemsById == NULL)
            __this->_availableItemsById = ((::g::Uno::Collections::Dictionary*)::g::Uno::Collections::Dictionary::New1(::g::Uno::Collections::Dictionary_typeof()->MakeType(uObject_typeof(), ::g::Fuse::Reactive::WindowItem_typeof(), NULL)));

        if ((::g::Uno::Collections::Dictionary__ContainsKey_fn(uPtr(__this->_availableItemsById), uPtr(wi)->Id(), &ret16), ret16))
            generic = true;
        else
            ::g::Uno::Collections::Dictionary__set_Item_fn(uPtr(__this->_availableItemsById), uPtr(wi)->Id(), wi);
    }

    if (generic)
    {
        if (__this->_availableItems == NULL)
            __this->_availableItems = ((::g::Fuse::Internal::ObjectList*)::g::Fuse::Internal::ObjectList::New1(::TYPES[70/*Fuse.Internal.ObjectList`1*/]->MakeType(::g::Fuse::Reactive::WindowItem_typeof(), NULL), 0));

        uPtr(__this->_availableItems)->Add(wi);
    }

    __this->ScheduleRemoveAvailableItems();
    __this->OnUpdatedWindowItems();
}

// private void Fuse.Reactive.ItemsWindowList<Fuse.Reactive.WindowItem>.IListener.SetFailed(string message) :169
void Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerSetFailed_fn(Instantiator* __this, uString* message)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "Fuse.Reactive.ItemsWindowList<Fuse.Reactive.WindowItem>.IListener.SetFailed(string)");

    if (__this->Parent() != NULL)
        ::g::Fuse::Triggers::BusyTask::SetBusy(__this->Parent(), &__this->_busyTask, 16, message);
}

// private void Fuse.Reactive.ItemsWindowList<Fuse.Reactive.WindowItem>.IListener.SetValid() :163
void Instantiator__FuseReactiveItemsWindowListFuseReactiveWindowItemIListenerSetValid_fn(Instantiator* __this)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "Fuse.Reactive.ItemsWindowList<Fuse.Reactive.WindowItem>.IListener.SetValid()");

    if (__this->Parent() != NULL)
        ::g::Fuse::Triggers::BusyTask::SetBusy(__this->Parent(), &__this->_busyTask, 0, ::STRINGS[26/*""*/]);
}

// private Fuse.Reactive.WindowItem GetAvailableNodes(Fuse.Reactive.TemplateMatch f, object id) :755
void Instantiator__GetAvailableNodes_fn(Instantiator* __this, ::g::Fuse::Reactive::TemplateMatch* f, uObject* id, ::g::Fuse::Reactive::WindowItem** __retval)
{
    *__retval = __this->GetAvailableNodes(*f, id);
}

// private Fuse.Reactive.TemplateMatch GetDataTemplate(object data) :618
void Instantiator__GetDataTemplate_fn(Instantiator* __this, uObject* data, ::g::Fuse::Reactive::TemplateMatch* __retval)
{
    *__retval = __this->GetDataTemplate(data);
}

// protected object GetItems() :391
void Instantiator__GetItems_fn(Instantiator* __this, uObject** __retval)
{
    *__retval = __this->GetItems();
}

// private Fuse.Node GetLastNodeFromIndex(int windowIndex) :538
void Instantiator__GetLastNodeFromIndex_fn(Instantiator* __this, int32_t* windowIndex, ::g::Fuse::Node** __retval)
{
    *__retval = __this->GetLastNodeFromIndex(*windowIndex);
}

// internal override sealed Fuse.Node GetLastNodeInGroup() :190
void Instantiator__GetLastNodeInGroup_fn(Instantiator* __this, ::g::Fuse::Node** __retval)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "GetLastNodeInGroup()");
    return *__retval = __this->GetLastNodeFromIndex(uPtr(__this->_watcher)->WindowItemCount() - 1), void();
}

// internal bool get_HasLimit() :388
void Instantiator__get_HasLimit_fn(Instantiator* __this, bool* __retval)
{
    *__retval = __this->HasLimit();
}

// public Fuse.Reactive.InstanceIdentity get_Identity() :266
void Instantiator__get_Identity_fn(Instantiator* __this, int32_t* __retval)
{
    *__retval = __this->Identity();
}

// public void set_Identity(Fuse.Reactive.InstanceIdentity value) :267
void Instantiator__set_Identity_fn(Instantiator* __this, int32_t* value)
{
    __this->Identity(*value);
}

// public string get_IdentityKey() :284
void Instantiator__get_IdentityKey_fn(Instantiator* __this, uString** __retval)
{
    *__retval = __this->IdentityKey();
}

// public void set_IdentityKey(string value) :285
void Instantiator__set_IdentityKey_fn(Instantiator* __this, uString* value)
{
    __this->IdentityKey(value);
}

// internal int get_Limit() :384
void Instantiator__get_Limit_fn(Instantiator* __this, int32_t* __retval)
{
    *__retval = __this->Limit();
}

// internal void set_Limit(int value) :385
void Instantiator__set_Limit_fn(Instantiator* __this, int32_t* value)
{
    __this->Limit(*value);
}

// public string get_Match() :457
void Instantiator__get_Match_fn(Instantiator* __this, uString** __retval)
{
    *__retval = __this->Match();
}

// public void set_Match(string value) :458
void Instantiator__set_Match_fn(Instantiator* __this, uString* value)
{
    __this->Match(value);
}

// public string get_MatchKey() :429
void Instantiator__get_MatchKey_fn(Instantiator* __this, uString** __retval)
{
    *__retval = __this->MatchKey();
}

// public void set_MatchKey(string value) :430
void Instantiator__set_MatchKey_fn(Instantiator* __this, uString* value)
{
    __this->MatchKey(value);
}

// protected internal Instantiator New() :127
void Instantiator__New2_fn(Instantiator** __retval)
{
    *__retval = Instantiator::New2();
}

// protected internal Instantiator New(Uno.Collections.IList<Uno.UX.Template> templates) :120
void Instantiator__New3_fn(uObject* templates, Instantiator** __retval)
{
    *__retval = Instantiator::New3(templates);
}

// internal int get_Offset() :378
void Instantiator__get_Offset_fn(Instantiator* __this, int32_t* __retval)
{
    *__retval = __this->Offset();
}

// internal void set_Offset(int value) :379
void Instantiator__set_Offset_fn(Instantiator* __this, int32_t* value)
{
    __this->Offset(*value);
}

// protected override sealed void OnRooted() :138
void Instantiator__OnRooted_fn(Instantiator* __this)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "OnRooted()");
    ::g::Fuse::Node__OnRooted_fn(__this);
    uPtr(__this->_watcher)->Rooted();

    if (__this->_rootTemplates != NULL)
        uPtr(__this->_rootTemplates)->Subscribe(uDelegate::New(::TYPES[11/*Uno.Action<Uno.UX.Template>*/], (void*)Instantiator__OnTemplatesChanged_fn, __this), uDelegate::New(::TYPES[11/*Uno.Action<Uno.UX.Template>*/], (void*)Instantiator__OnTemplatesChanged_fn, __this));

    __this->_templateSource = __this->_weakTemplateSource;
}

// private void OnTemplatesChanged(Uno.UX.Template factory) :132
void Instantiator__OnTemplatesChanged_fn(Instantiator* __this, ::g::Uno::UX::Template* factory)
{
    __this->OnTemplatesChanged(factory);
}

// protected override sealed void OnUnrooted() :149
void Instantiator__OnUnrooted_fn(Instantiator* __this)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "OnUnrooted()");
    uPtr(__this->_watcher)->Unrooted();
    __this->RemoveAvailableItems();

    if (__this->_rootTemplates != NULL)
        uPtr(__this->_rootTemplates)->Unsubscribe();

    __this->_templateSource = NULL;
    __this->_completedRemove = NULL;
    ::g::Fuse::Node__OnUnrooted_fn(__this);
}

// private void OnUpdatedWindowItems() :927
void Instantiator__OnUpdatedWindowItems_fn(Instantiator* __this)
{
    __this->OnUpdatedWindowItems();
}

// private void PostUpdatedWindowItems() :937
void Instantiator__PostUpdatedWindowItems_fn(Instantiator* __this)
{
    __this->PostUpdatedWindowItems();
}

// private void PrepareDataContext(Fuse.Reactive.WindowItem wi) :726
void Instantiator__PrepareDataContext_fn(Instantiator* __this, ::g::Fuse::Reactive::WindowItem* wi)
{
    __this->PrepareDataContext(wi);
}

// private void PrepareWindowItem(int windowIndex, Fuse.Reactive.WindowItem wi) :564
void Instantiator__PrepareWindowItem_fn(Instantiator* __this, int32_t* windowIndex, ::g::Fuse::Reactive::WindowItem* wi)
{
    __this->PrepareWindowItem(*windowIndex, wi);
}

// private void RecreateTemplates() :883
void Instantiator__RecreateTemplates_fn(Instantiator* __this)
{
    __this->RecreateTemplates();
}

// private void RemoveAvailableItems() :818
void Instantiator__RemoveAvailableItems_fn(Instantiator* __this)
{
    __this->RemoveAvailableItems();
}

// private void RemoveAvailableItemsAction() :810
void Instantiator__RemoveAvailableItemsAction_fn(Instantiator* __this)
{
    __this->RemoveAvailableItemsAction();
}

// private void RemoveFromParent(Fuse.Node n) :177
void Instantiator__RemoveFromParent_fn(Instantiator* __this, ::g::Fuse::Node* n)
{
    __this->RemoveFromParent(n);
}

// public Fuse.Reactive.InstanceReuse get_Reuse() :251
void Instantiator__get_Reuse_fn(Instantiator* __this, int32_t* __retval)
{
    *__retval = __this->Reuse();
}

// public void set_Reuse(Fuse.Reactive.InstanceReuse value) :252
void Instantiator__set_Reuse_fn(Instantiator* __this, int32_t* value)
{
    __this->Reuse(*value);
}

// private void ScheduleRemoveAvailableItems() :793
void Instantiator__ScheduleRemoveAvailableItems_fn(Instantiator* __this)
{
    __this->ScheduleRemoveAvailableItems();
}

// protected void SetItems(object value) :393
void Instantiator__SetItems_fn(Instantiator* __this, uObject* value)
{
    __this->SetItems(value);
}

// public string get_TemplateKey() :365
void Instantiator__get_TemplateKey_fn(Instantiator* __this, uString** __retval)
{
    *__retval = __this->TemplateKey();
}

// public void set_TemplateKey(string value) :366
void Instantiator__set_TemplateKey_fn(Instantiator* __this, uString* value)
{
    __this->TemplateKey(value);
}

// public Uno.Collections.IList<Uno.UX.Template> get_Templates() :211
void Instantiator__get_Templates_fn(Instantiator* __this, uObject** __retval)
{
    *__retval = __this->Templates();
}

// public Fuse.ITemplateSource get_TemplateSource() :339
void Instantiator__get_TemplateSource_fn(Instantiator* __this, uObject** __retval)
{
    *__retval = __this->TemplateSource();
}

// public void set_TemplateSource(Fuse.ITemplateSource value) :340
void Instantiator__set_TemplateSource_fn(Instantiator* __this, uObject* value)
{
    __this->TemplateSource(value);
}

// internal generated void add_UpdatedWindowItems(Uno.Action value) :925
void Instantiator__add_UpdatedWindowItems_fn(Instantiator* __this, uDelegate* value)
{
    __this->add_UpdatedWindowItems(value);
}

// internal generated void remove_UpdatedWindowItems(Uno.Action value) :925
void Instantiator__remove_UpdatedWindowItems_fn(Instantiator* __this, uDelegate* value)
{
    __this->remove_UpdatedWindowItems(value);
}

// protected internal Instantiator() [instance] :127
void Instantiator::ctor_3()
{
    uStackFrame __("Fuse.Reactive.Instantiator", ".ctor()");
    _defer = 1;
    _deferredPriority = 0.0f;
    _dataMap = ((::g::Uno::Collections::Dictionary*)::g::Uno::Collections::Dictionary::New1(::g::Uno::Collections::Dictionary_typeof()->MakeType(::TYPES[42/*Fuse.Node*/], ::g::Fuse::Reactive::WindowItem_typeof(), NULL)));
    _availableItemsById = ((::g::Uno::Collections::Dictionary*)::g::Uno::Collections::Dictionary::New1(::g::Uno::Collections::Dictionary_typeof()->MakeType(uObject_typeof(), ::g::Fuse::Reactive::WindowItem_typeof(), NULL)));
    _availableItems = ((::g::Fuse::Internal::ObjectList*)::g::Fuse::Internal::ObjectList::New1(::TYPES[70/*Fuse.Internal.ObjectList`1*/]->MakeType(::g::Fuse::Reactive::WindowItem_typeof(), NULL), 0));
    ctor_2();
    _watcher = ((::g::Fuse::Reactive::ItemsWindowList*)::g::Fuse::Reactive::ItemsWindowList::New1(::g::Fuse::Reactive::ItemsWindowList_typeof()->MakeType(::g::Fuse::Reactive::WindowItem_typeof(), NULL), (uObject*)this));
}

// protected internal Instantiator(Uno.Collections.IList<Uno.UX.Template> templates) [instance] :120
void Instantiator::ctor_4(uObject* templates)
{
    uStackFrame __("Fuse.Reactive.Instantiator", ".ctor(Uno.Collections.IList<Uno.UX.Template>)");
    _defer = 1;
    _deferredPriority = 0.0f;
    _dataMap = ((::g::Uno::Collections::Dictionary*)::g::Uno::Collections::Dictionary::New1(::g::Uno::Collections::Dictionary_typeof()->MakeType(::TYPES[42/*Fuse.Node*/], ::g::Fuse::Reactive::WindowItem_typeof(), NULL)));
    _availableItemsById = ((::g::Uno::Collections::Dictionary*)::g::Uno::Collections::Dictionary::New1(::g::Uno::Collections::Dictionary_typeof()->MakeType(uObject_typeof(), ::g::Fuse::Reactive::WindowItem_typeof(), NULL)));
    _availableItems = ((::g::Fuse::Internal::ObjectList*)::g::Fuse::Internal::ObjectList::New1(::TYPES[70/*Fuse.Internal.ObjectList`1*/]->MakeType(::g::Fuse::Reactive::WindowItem_typeof(), NULL), 0));
    ctor_2();
    _templates = templates;
    _watcher = ((::g::Fuse::Reactive::ItemsWindowList*)::g::Fuse::Reactive::ItemsWindowList::New1(::g::Fuse::Reactive::ItemsWindowList_typeof()->MakeType(::g::Fuse::Reactive::WindowItem_typeof(), NULL), (uObject*)this));
}

// private bool AddMatchingTemplates(Fuse.Reactive.WindowItem item, Fuse.Reactive.TemplateMatch f) [instance] :690
bool Instantiator::AddMatchingTemplates(::g::Fuse::Reactive::WindowItem* item, ::g::Fuse::Reactive::TemplateMatch f)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "AddMatchingTemplates(Fuse.Reactive.WindowItem,Fuse.Reactive.TemplateMatch)");
    ::g::Uno::UX::Template* ret8;
    bool reuse = false;
    uObject* oldData = NULL;
    ::g::Fuse::Reactive::WindowItem* av = GetAvailableNodes(f, uPtr(item)->Id());

    if (av != NULL)
    {
        uPtr(item)->Nodes = uPtr(av)->Nodes;
        oldData = av->CurrentData();
        av->Nodes = NULL;
        reuse = true;
    }
    else if (f.All)
    {
        uPtr(item)->Nodes = ((::g::Uno::Collections::List*)::g::Uno::Collections::List::New1(::TYPES[51/*Uno.Collections.List<Fuse.Node>*/]));

        for (int32_t i = 0; i < ::g::Uno::Collections::ICollection::Count(uInterface(uPtr(Templates()), ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Uno::UX::Template_typeof(), NULL))); ++i)
            AddTemplate(item, (::g::Uno::Collections::IList::get_Item_ex(uInterface(uPtr(Templates()), ::g::Uno::Collections::IList_typeof()->MakeType(::g::Uno::UX::Template_typeof(), NULL)), uCRef<int32_t>(i), &ret8), ret8));
    }
    else if (f.Template == NULL)
        uPtr(item)->Nodes = ((::g::Uno::Collections::List*)::g::Uno::Collections::List::New1(::TYPES[51/*Uno.Collections.List<Fuse.Node>*/]));
    else
    {
        uPtr(item)->Nodes = ((::g::Uno::Collections::List*)::g::Uno::Collections::List::New1(::TYPES[51/*Uno.Collections.List<Fuse.Node>*/]));
        AddTemplate(item, f.Template);
    }

    PrepareDataContext(item);
    BroadcastDataChange1(item, oldData);
    item->Template = f;
    return reuse;
}

// private void AddTemplate(Fuse.Reactive.WindowItem item, Uno.UX.Template f) [instance] :736
void Instantiator::AddTemplate(::g::Fuse::Reactive::WindowItem* item, ::g::Uno::UX::Template* f)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "AddTemplate(Fuse.Reactive.WindowItem,Uno.UX.Template)");
    ::g::Fuse::Node* elm = uAs< ::g::Fuse::Node*>(uPtr(f)->New1(), ::TYPES[42/*Fuse.Node*/]);

    if (elm == NULL)
    {
        ::g::Fuse::Diagnostics::InternalError(uString::Const("Template contains a non-Node"), this, uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Bindings\\1.8.1\\Instantiator.uno"), 741, uString::Const("AddTemplate"));
        return;
    }

    ::g::Uno::Collections::List__Add_fn(uPtr(uPtr(item)->Nodes), elm);
}

// private void BroadcastDataChange(Fuse.Reactive.WindowItem wi, object oldData) [instance] :914
void Instantiator::BroadcastDataChange1(::g::Fuse::Reactive::WindowItem* wi, uObject* oldData)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "BroadcastDataChange(Fuse.Reactive.WindowItem,object)");
    ::g::Fuse::Node* ret9;

    if (uPtr(wi)->Nodes == NULL)
        return;

    for (int32_t i = 0; i < uPtr(uPtr(wi)->Nodes)->Count(); ++i)
        uPtr((::g::Uno::Collections::List__get_Item_fn(uPtr(uPtr(wi)->Nodes), uCRef<int32_t>(i), &ret9), ret9))->BroadcastDataChange(oldData, uPtr(wi)->CurrentData());
}

// private void CleanupWindowItem(Fuse.Reactive.WindowItem wi) [instance] :843
void Instantiator::CleanupWindowItem(::g::Fuse::Reactive::WindowItem* wi)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "CleanupWindowItem(Fuse.Reactive.WindowItem)");
    ::g::Fuse::Node* ret10;

    if (uPtr(wi)->Nodes != NULL)
    {
        for (int32_t n = 0; n < uPtr(uPtr(wi)->Nodes)->Count(); ++n)
            RemoveFromParent((::g::Uno::Collections::List__get_Item_fn(uPtr(uPtr(wi)->Nodes), uCRef<int32_t>(n), &ret10), ret10));

        uPtr(wi)->Nodes = NULL;
    }
}

// private void CompletedRemove(Fuse.Node n) [instance] :184
void Instantiator::CompletedRemove(::g::Fuse::Node* n)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "CompletedRemove(Fuse.Node)");
    bool ret11;
    uPtr(n)->OverrideContextParent = NULL;
    ::g::Uno::Collections::Dictionary__Remove_fn(uPtr(_dataMap), n, &ret11);
}

// private void CompleteWindowItem(Fuse.Reactive.WindowItem wi, int windowIndex) [instance] :664
void Instantiator::CompleteWindowItem(::g::Fuse::Reactive::WindowItem* wi, int32_t windowIndex)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "CompleteWindowItem(Fuse.Reactive.WindowItem,int)");
    ::g::Uno::Collections::List__Enumerator<uStrong< ::g::Fuse::Node*> > ret12;
    ::g::Uno::Collections::List__Enumerator<uStrong< ::g::Fuse::Node*> > ret13;
    ::g::Fuse::Reactive::TemplateMatch match = GetDataTemplate(uPtr(wi)->CurrentData());
    bool reuse = AddMatchingTemplates(wi, match);

    if ((wi->Template.All && (::g::Uno::Collections::ICollection::Count(uInterface(uPtr(Templates()), ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Uno::UX::Template_typeof(), NULL))) != uPtr(wi->Nodes)->Count())) || ((wi->Template.Template != NULL) && (uPtr(wi->Nodes)->Count() != 1)))
        ::g::Fuse::Diagnostics::InternalError(uString::Const("inconsistent instance state"), this, uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Bindings\\1.8.1\\Instantiator.uno"), 672, uString::Const("CompleteWindowItem"));

    ::g::Fuse::Node* lastNode = GetLastNodeFromIndex(windowIndex - 1);

    if (reuse)
        uPtr(Parent())->InsertOrMoveNodesAfter(lastNode, uBox(::TYPES[57/*Uno.Collections.List<Fuse.Node>.Enumerator*/], (::g::Uno::Collections::List__GetEnumerator_fn(uPtr(uPtr(wi)->Nodes), &ret12), ret12)));
    else
        uPtr(Parent())->InsertNodesAfter(lastNode, uBox(::TYPES[57/*Uno.Collections.List<Fuse.Node>.Enumerator*/], (::g::Uno::Collections::List__GetEnumerator_fn(uPtr(uPtr(wi)->Nodes), &ret13), ret13)));
}

// private bool CompleteWindowItems(bool one) [instance] :592
bool Instantiator::CompleteWindowItems(bool one)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "CompleteWindowItems(bool)");

    if (!IsRootingStarted())
        return false;

    bool first = true;

    for (int32_t i = 0; i < uPtr(_watcher)->WindowItemCount(); ++i)
    {
        ::g::Fuse::Reactive::WindowItem* wi = (::g::Fuse::Reactive::WindowItem*)uPtr(_watcher)->GetWindowItem(i);

        if (uPtr(wi)->Nodes == NULL)
        {
            if (!first && one)
                return true;

            CompleteWindowItem(wi, i);
            first = false;
        }
    }

    RemoveAvailableItems();
    return false;
}

// private void CompleteWindowItemsAction() [instance] :586
void Instantiator::CompleteWindowItemsAction()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "CompleteWindowItemsAction()");
    CompleteWindowItems(false);
    _pendingNew = false;
}

// internal int get_DataCount() [instance] :517
int32_t Instantiator::DataCount()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "get_DataCount()");
    return uPtr(_watcher)->GetDataCount();
}

// internal int DataIndexOfChild(Fuse.Node child) [instance] :499
int32_t Instantiator::DataIndexOfChild(::g::Fuse::Node* child)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "DataIndexOfChild(Fuse.Node)");
    ::g::Fuse::Node* ret14;

    for (int32_t i = 0; i < uPtr(_watcher)->WindowItemCount(); i++)
    {
        ::g::Fuse::Reactive::WindowItem* wi = (::g::Fuse::Reactive::WindowItem*)uPtr(_watcher)->GetWindowItem(i);
        ::g::Uno::Collections::List* list = uPtr(wi)->Nodes;

        if (list == NULL)
            continue;

        for (int32_t n = 0; n < uPtr(list)->Count(); n++)
            if ((::g::Uno::Collections::List__get_Item_fn(uPtr(list), uCRef<int32_t>(n), &ret14), ret14) == child)
                return i + Offset();
    }

    return -1;
}

// public Fuse.Reactive.InstanceDefaults get_Defaults() [instance] :486
int32_t Instantiator::Defaults()
{
    return _defaults;
}

// public void set_Defaults(Fuse.Reactive.InstanceDefaults value) [instance] :487
void Instantiator::Defaults(int32_t value)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "set_Defaults(Fuse.Reactive.InstanceDefaults)");

    if (_defaults != value)
    {
        _defaults = value;
        RecreateTemplates();
    }
}

// public Fuse.Reactive.InstanceDefer get_Defer() [instance] :231
int32_t Instantiator::Defer()
{
    return _defer;
}

// public void set_Defer(Fuse.Reactive.InstanceDefer value) [instance] :232
void Instantiator::Defer(int32_t value)
{
    _defer = value;
}

// public float get_DeferredPriority() [instance] :296
float Instantiator::DeferredPriority()
{
    return _deferredPriority;
}

// public void set_DeferredPriority(float value) [instance] :297
void Instantiator::DeferredPriority(float value)
{
    _deferredPriority = value;
}

// private void DisposeWindowItem(Fuse.Reactive.WindowItem wi) [instance] :837
void Instantiator::DisposeWindowItem(::g::Fuse::Reactive::WindowItem* wi)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "DisposeWindowItem(Fuse.Reactive.WindowItem)");
    CleanupWindowItem(wi);
    uPtr(wi)->Dispose();
}

// private Fuse.Reactive.WindowItem GetAvailableNodes(Fuse.Reactive.TemplateMatch f, object id) [instance] :755
::g::Fuse::Reactive::WindowItem* Instantiator::GetAvailableNodes(::g::Fuse::Reactive::TemplateMatch f, uObject* id)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "GetAvailableNodes(Fuse.Reactive.TemplateMatch,object)");
    bool ret17;
    bool ret18;

    if ((id != NULL) && (_availableItemsById != NULL))
    {
        ::g::Fuse::Reactive::WindowItem* item;

        if ((::g::Uno::Collections::Dictionary__TryGetValue_fn(uPtr(_availableItemsById), id, (void**)(&item), &ret17), ret17) && f.Matches(uPtr(item)->Template))
        {
            ::g::Uno::Collections::Dictionary__Remove_fn(uPtr(_availableItemsById), id, &ret18);
            return item;
        }
    }

    if ((Reuse() != 0) && (_availableItems != NULL))

        for (int32_t i = 0; i < uPtr(_availableItems)->Count(); ++i)
        {
            ::g::Fuse::Reactive::WindowItem* av = (::g::Fuse::Reactive::WindowItem*)uPtr(_availableItems)->Item(i);

            if (f.Matches(uPtr(av)->Template))
            {
                uPtr(_availableItems)->RemoveAt(i);
                return av;
            }
        }

    return NULL;
}

// private Fuse.Reactive.TemplateMatch GetDataTemplate(object data) [instance] :618
::g::Fuse::Reactive::TemplateMatch Instantiator::GetDataTemplate(uObject* data)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "GetDataTemplate(object)");
    ::g::Fuse::Reactive::TemplateMatch collection1;
    uString* ind5;
    ::g::Fuse::Reactive::TemplateMatch collection2;
    ::g::Fuse::Reactive::TemplateMatch collection3;
    ::g::Uno::UX::Template* ret19;

    if (data == NULL)
    {
        collection1 = uDefault< ::g::Fuse::Reactive::TemplateMatch>();
        collection1.All = false;
        collection1.Template = NULL;
        return collection1;
    }

    ::g::Uno::UX::Template* useTemplate = NULL;
    ::g::Uno::UX::Template* defaultTemplate = NULL;

    if ((_templateSource != NULL) && ::g::Uno::String::op_Inequality(TemplateKey(), NULL))
    {
        ::g::Uno::UX::Template* t = ::g::Fuse::ITemplateSource::FindTemplate(uInterface(uPtr(_templateSource), ::g::Fuse::ITemplateSource_typeof()), TemplateKey());

        if (t != NULL)
            useTemplate = t;
    }

    if (useTemplate == NULL)
    {
        ind5 = Match();
        uString* key = (ind5 != NULL) ? ind5 : uAs<uString*>(uPtr(_watcher)->GetDataKey(data, MatchKey()), ::TYPES[1/*string*/]);

        for (int32_t i = ::g::Uno::Collections::ICollection::Count(uInterface(uPtr(Templates()), ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Uno::UX::Template_typeof(), NULL))) - 1; i >= 0; --i)
        {
            ::g::Uno::UX::Template* f = (::g::Uno::Collections::IList::get_Item_ex(uInterface(uPtr(Templates()), ::g::Uno::Collections::IList_typeof()->MakeType(::g::Uno::UX::Template_typeof(), NULL)), uCRef<int32_t>(i), &ret19), ret19);

            if (uPtr(f)->IsDefault())
                defaultTemplate = f;

            if (::g::Uno::String::op_Inequality(key, NULL) && ::g::Uno::String::op_Equality(uPtr(f)->Key(), key))
                useTemplate = f;
        }
    }

    if ((useTemplate == NULL) && (Defaults() != 2))
    {
        if (Defaults() == 1)
            useTemplate = defaultTemplate;
        else if ((::g::Uno::String::op_Inequality(MatchKey(), NULL) || ::g::Uno::String::op_Inequality(Match(), NULL)) || (defaultTemplate != NULL))
            useTemplate = defaultTemplate;
        else
        {
            collection2 = uDefault< ::g::Fuse::Reactive::TemplateMatch>();
            collection2.All = true;
            collection2.Template = NULL;
            return collection2;
        }
    }

    collection3 = uDefault< ::g::Fuse::Reactive::TemplateMatch>();
    collection3.All = false;
    collection3.Template = useTemplate;
    return collection3;
}

// protected object GetItems() [instance] :391
uObject* Instantiator::GetItems()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "GetItems()");
    return uPtr(_watcher)->GetItems();
}

// private Fuse.Node GetLastNodeFromIndex(int windowIndex) [instance] :538
::g::Fuse::Node* Instantiator::GetLastNodeFromIndex(int32_t windowIndex)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "GetLastNodeFromIndex(int)");
    ::g::Fuse::Node* ret20;

    if (windowIndex >= uPtr(_watcher)->WindowItemCount())
        windowIndex = uPtr(_watcher)->WindowItemCount() - 1;

    while (windowIndex >= 0)
    {
        ::g::Uno::Collections::List* lastList = uPtr((::g::Fuse::Reactive::WindowItem*)uPtr(_watcher)->GetWindowItem(windowIndex))->Nodes;

        if ((lastList != NULL) && (uPtr(lastList)->Count() != 0))
            return uPtr((::g::Uno::Collections::List__get_Item_fn(uPtr(lastList), uCRef<int32_t>(uPtr(lastList)->Count() - 1), &ret20), ret20))->GetLastNodeInGroup();

        windowIndex--;
    }

    return this;
}

// internal bool get_HasLimit() [instance] :388
bool Instantiator::HasLimit()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "get_HasLimit()");
    return uPtr(_watcher)->HasLimit();
}

// public Fuse.Reactive.InstanceIdentity get_Identity() [instance] :266
int32_t Instantiator::Identity()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "get_Identity()");
    return uPtr(_watcher)->Identity;
}

// public void set_Identity(Fuse.Reactive.InstanceIdentity value) [instance] :267
void Instantiator::Identity(int32_t value)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "set_Identity(Fuse.Reactive.InstanceIdentity)");
    uPtr(_watcher)->Identity = value;
}

// public string get_IdentityKey() [instance] :284
uString* Instantiator::IdentityKey()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "get_IdentityKey()");
    return uPtr(_watcher)->IdentityKey();
}

// public void set_IdentityKey(string value) [instance] :285
void Instantiator::IdentityKey(uString* value)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "set_IdentityKey(string)");
    uPtr(_watcher)->IdentityKey(value);
}

// internal int get_Limit() [instance] :384
int32_t Instantiator::Limit()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "get_Limit()");
    return uPtr(_watcher)->Limit();
}

// internal void set_Limit(int value) [instance] :385
void Instantiator::Limit(int32_t value)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "set_Limit(int)");
    uPtr(_watcher)->Limit(value);
}

// public string get_Match() [instance] :457
uString* Instantiator::Match()
{
    return _match;
}

// public void set_Match(string value) [instance] :458
void Instantiator::Match(uString* value)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "set_Match(string)");

    if (::g::Uno::String::op_Inequality(_match, value))
    {
        _match = value;
        RecreateTemplates();
    }
}

// public string get_MatchKey() [instance] :429
uString* Instantiator::MatchKey()
{
    return _matchKey;
}

// public void set_MatchKey(string value) [instance] :430
void Instantiator::MatchKey(uString* value)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "set_MatchKey(string)");

    if (::g::Uno::String::op_Inequality(_matchKey, value))
    {
        _matchKey = value;
        RecreateTemplates();
    }
}

// internal int get_Offset() [instance] :378
int32_t Instantiator::Offset()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "get_Offset()");
    return uPtr(_watcher)->Offset();
}

// internal void set_Offset(int value) [instance] :379
void Instantiator::Offset(int32_t value)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "set_Offset(int)");
    uPtr(_watcher)->Offset(value);
}

// private void OnTemplatesChanged(Uno.UX.Template factory) [instance] :132
void Instantiator::OnTemplatesChanged(::g::Uno::UX::Template* factory)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "OnTemplatesChanged(Uno.UX.Template)");

    if (!IsRootingCompleted())
        return;

    RecreateTemplates();
}

// private void OnUpdatedWindowItems() [instance] :927
void Instantiator::OnUpdatedWindowItems()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "OnUpdatedWindowItems()");

    if (::g::Uno::Delegate::op_Equality(UpdatedWindowItems1, NULL) || _pendingUpdateWindowItems)
        return;

    _pendingUpdateWindowItems = true;
    ::g::Fuse::UpdateManager::AddDeferredAction2(uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)Instantiator__PostUpdatedWindowItems_fn, this), -1, 2);
}

// private void PostUpdatedWindowItems() [instance] :937
void Instantiator::PostUpdatedWindowItems()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "PostUpdatedWindowItems()");

    if (::g::Uno::Delegate::op_Inequality(UpdatedWindowItems1, NULL))
        uPtr(UpdatedWindowItems1)->InvokeVoid();

    _pendingUpdateWindowItems = false;
}

// private void PrepareDataContext(Fuse.Reactive.WindowItem wi) [instance] :726
void Instantiator::PrepareDataContext(::g::Fuse::Reactive::WindowItem* wi)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "PrepareDataContext(Fuse.Reactive.WindowItem)");
    ::g::Fuse::Node* ret21;

    for (int32_t i = 0; i < uPtr(uPtr(wi)->Nodes)->Count(); ++i)
    {
        ::g::Fuse::Node* n = (::g::Uno::Collections::List__get_Item_fn(uPtr(uPtr(wi)->Nodes), uCRef<int32_t>(i), &ret21), ret21);
        uPtr(n)->OverrideContextParent = this;
        ::g::Uno::Collections::Dictionary__set_Item_fn(uPtr(_dataMap), n, wi);
    }
}

// private void PrepareWindowItem(int windowIndex, Fuse.Reactive.WindowItem wi) [instance] :564
void Instantiator::PrepareWindowItem(int32_t windowIndex, ::g::Fuse::Reactive::WindowItem* wi)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "PrepareWindowItem(int,Fuse.Reactive.WindowItem)");

    if (Defer() == 0)
        CompleteWindowItem(wi, windowIndex);
    else if (!_pendingNew)
    {
        if (Defer() == 2)
            ::g::Fuse::DeferredManager::AddPending((uObject*)this, ::g::Uno::Float2__New2(DeferredPriority(), (float)NodeDepth()));
        else
            ::g::Fuse::UpdateManager::AddDeferredAction2(uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)Instantiator__CompleteWindowItemsAction_fn, this), -1, 2);

        _pendingNew = true;
    }
}

// private void RecreateTemplates() [instance] :883
void Instantiator::RecreateTemplates()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "RecreateTemplates()");

    for (int32_t i = 0; i < uPtr(_watcher)->WindowItemCount(); i++)
        CleanupWindowItem((::g::Fuse::Reactive::WindowItem*)uPtr(_watcher)->GetWindowItem(i));

    for (int32_t i1 = 0; i1 < uPtr(_watcher)->WindowItemCount(); i1++)
        PrepareWindowItem(i1, (::g::Fuse::Reactive::WindowItem*)uPtr(_watcher)->GetWindowItem(i1));

    ScheduleRemoveAvailableItems();
}

// private void RemoveAvailableItems() [instance] :818
void Instantiator::RemoveAvailableItems()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "RemoveAvailableItems()");
    ::g::Uno::Collections::Dictionary__Enumerator<uStrong<uObject*>, uStrong< ::g::Fuse::Reactive::WindowItem*> > ret22;

    if (_availableItems != NULL)
    {
        for (int32_t i = 0; i < uPtr(_availableItems)->Count(); ++i)
            DisposeWindowItem((::g::Fuse::Reactive::WindowItem*)uPtr(_availableItems)->Item(i));

        uPtr(_availableItems)->Clear();
    }

    if (_availableItemsById != NULL)
    {
        ::g::Uno::Collections::Dictionary__Enumerator<uStrong<uObject*>, uStrong< ::g::Fuse::Reactive::WindowItem*> > enum4 = (::g::Uno::Collections::Dictionary__GetEnumerator_fn(uPtr(_availableItemsById), &ret22), ret22);

        {
            try
            {
                {
                    while (enum4.MoveNext(::g::Uno::Collections::Dictionary__Enumerator_typeof()->MakeType(uObject_typeof(), ::g::Fuse::Reactive::WindowItem_typeof(), NULL)))
                    {
                        ::g::Uno::Collections::KeyValuePair<uStrong<uObject*>, uStrong< ::g::Fuse::Reactive::WindowItem*> > kvp = enum4.Current(::g::Uno::Collections::Dictionary__Enumerator_typeof()->MakeType(uObject_typeof(), ::g::Fuse::Reactive::WindowItem_typeof(), NULL));
                        DisposeWindowItem(kvp.Value(::g::Uno::Collections::KeyValuePair_typeof()->MakeType(uObject_typeof(), ::g::Fuse::Reactive::WindowItem_typeof(), NULL)));
                    }
                }
            }

            catch (const uThrowable& __t)
            {
                {
                    enum4.Dispose(::g::Uno::Collections::Dictionary__Enumerator_typeof()->MakeType(uObject_typeof(), ::g::Fuse::Reactive::WindowItem_typeof(), NULL));
                }
                                throw __t;
                goto __after_finally_1;
            }

            {
                enum4.Dispose(::g::Uno::Collections::Dictionary__Enumerator_typeof()->MakeType(uObject_typeof(), ::g::Fuse::Reactive::WindowItem_typeof(), NULL));
            }
            __after_finally_1:;
        }

        uPtr(_availableItemsById)->Clear();
    }

    _pendingNew = false;
}

// private void RemoveAvailableItemsAction() [instance] :810
void Instantiator::RemoveAvailableItemsAction()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "RemoveAvailableItemsAction()");

    if (!_pendingNew)
        RemoveAvailableItems();

    _pendingAvailableItems = false;
}

// private void RemoveFromParent(Fuse.Node n) [instance] :177
void Instantiator::RemoveFromParent(::g::Fuse::Node* n)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "RemoveFromParent(Fuse.Node)");

    if (::g::Uno::Delegate::op_Equality(_completedRemove, NULL))
        _completedRemove = uDelegate::New(::g::Uno::Action1_typeof()->MakeType(::TYPES[42/*Fuse.Node*/], NULL), (void*)Instantiator__CompletedRemove_fn, this);

    uPtr(Parent())->BeginRemoveChild(n, _completedRemove);
}

// public Fuse.Reactive.InstanceReuse get_Reuse() [instance] :251
int32_t Instantiator::Reuse()
{
    return _reuse;
}

// public void set_Reuse(Fuse.Reactive.InstanceReuse value) [instance] :252
void Instantiator::Reuse(int32_t value)
{
    _reuse = value;
}

// private void ScheduleRemoveAvailableItems() [instance] :793
void Instantiator::ScheduleRemoveAvailableItems()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "ScheduleRemoveAvailableItems()");

    if (Reuse() == 1)
    {
        if (!_pendingAvailableItems)
        {
            ::g::Fuse::UpdateManager::AddDeferredAction2(uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)Instantiator__RemoveAvailableItemsAction_fn, this), -1, 2);
            _pendingAvailableItems = true;
        }
    }
    else if (!_pendingNew)
        RemoveAvailableItems();
}

// protected void SetItems(object value) [instance] :393
void Instantiator::SetItems(uObject* value)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "SetItems(object)");
    uPtr(_watcher)->SetItems(value);
}

// public string get_TemplateKey() [instance] :365
uString* Instantiator::TemplateKey()
{
    return _templateKey;
}

// public void set_TemplateKey(string value) [instance] :366
void Instantiator::TemplateKey(uString* value)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "set_TemplateKey(string)");

    if (::g::Uno::String::op_Inequality(_templateKey, value))
    {
        _templateKey = value;
        RecreateTemplates();
    }
}

// public Uno.Collections.IList<Uno.UX.Template> get_Templates() [instance] :211
uObject* Instantiator::Templates()
{
    uStackFrame __("Fuse.Reactive.Instantiator", "get_Templates()");

    if (_templates != NULL)
        return _templates;

    _rootTemplates = ((::g::Uno::Collections::RootableList*)::g::Uno::Collections::RootableList::New1(::TYPES[13/*Uno.Collections.RootableList<Uno.UX.Template>*/]));

    if (IsRootingCompleted())
        uPtr(_rootTemplates)->Subscribe(uDelegate::New(::TYPES[11/*Uno.Action<Uno.UX.Template>*/], (void*)Instantiator__OnTemplatesChanged_fn, this), uDelegate::New(::TYPES[11/*Uno.Action<Uno.UX.Template>*/], (void*)Instantiator__OnTemplatesChanged_fn, this));

    _templates = (uObject*)_rootTemplates;
    return _templates;
}

// public Fuse.ITemplateSource get_TemplateSource() [instance] :339
uObject* Instantiator::TemplateSource()
{
    return _weakTemplateSource;
}

// public void set_TemplateSource(Fuse.ITemplateSource value) [instance] :340
void Instantiator::TemplateSource(uObject* value)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "set_TemplateSource(Fuse.ITemplateSource)");
    _weakTemplateSource = value;

    if (IsRootingCompleted())
    {
        _templateSource = _weakTemplateSource;
        RecreateTemplates();
    }
}

// internal generated void add_UpdatedWindowItems(Uno.Action value) [instance] :925
void Instantiator::add_UpdatedWindowItems(uDelegate* value)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "add_UpdatedWindowItems(Uno.Action)");
    UpdatedWindowItems1 = uCast<uDelegate*>(::g::Uno::Delegate::Combine(UpdatedWindowItems1, value), ::TYPES[37/*Uno.Action*/]);
}

// internal generated void remove_UpdatedWindowItems(Uno.Action value) [instance] :925
void Instantiator::remove_UpdatedWindowItems(uDelegate* value)
{
    uStackFrame __("Fuse.Reactive.Instantiator", "remove_UpdatedWindowItems(Uno.Action)");
    UpdatedWindowItems1 = uCast<uDelegate*>(::g::Uno::Delegate::Remove(UpdatedWindowItems1, value), ::TYPES[37/*Uno.Action*/]);
}

// protected internal Instantiator New() [static] :127
Instantiator* Instantiator::New2()
{
    Instantiator* obj7 = (Instantiator*)uNew(Instantiator_typeof());
    obj7->ctor_3();
    return obj7;
}

// protected internal Instantiator New(Uno.Collections.IList<Uno.UX.Template> templates) [static] :120
Instantiator* Instantiator::New3(uObject* templates)
{
    Instantiator* obj6 = (Instantiator*)uNew(Instantiator_typeof());
    obj6->ctor_4(templates);
    return obj6;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\InstantiatorFunction.uno
// ---------------------------------------------------------------------------------------------------------

// public abstract class InstantiatorFunction :12
// {
// static generated InstantiatorFunction() :12
static void InstantiatorFunction__cctor__fn(uType* __type)
{
    InstantiatorFunction::DataIndexName_ = ::g::Uno::UX::Selector__op_Implicit(uString::Const("index"));
    InstantiatorFunction::OffsetIndexName_ = ::g::Uno::UX::Selector__op_Implicit(uString::Const("offsetIndex"));
}

static void InstantiatorFunction_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->SetFields(1,
        ::g::Uno::UX::Selector_typeof(), offsetof(InstantiatorFunction, _item), 0,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&InstantiatorFunction::DataIndexName_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&InstantiatorFunction::OffsetIndexName_, uFieldFlagsStatic);
}

::g::Fuse::Reactive::Expression_type* InstantiatorFunction_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::VarArgFunction_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(InstantiatorFunction);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.InstantiatorFunction", options);
    type->fp_build_ = InstantiatorFunction_build;
    type->fp_cctor_ = InstantiatorFunction__cctor__fn;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))InstantiatorFunction__Subscribe_fn;
    type->fp_ToString = (void(*)(uObject*, uString**))InstantiatorFunction__ToString_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))InstantiatorFunction__Subscribe_fn;
    return type;
}

// internal InstantiatorFunction(Uno.UX.Selector item) :19
void InstantiatorFunction__ctor_2_fn(InstantiatorFunction* __this, ::g::Uno::UX::Selector* item)
{
    __this->ctor_2(*item);
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :30
void InstantiatorFunction__Subscribe_fn(InstantiatorFunction* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.InstantiatorFunction", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    ::g::Fuse::Reactive::Expression* ret1;

    if (::g::Uno::Collections::ICollection::Count(uInterface(uPtr(__this->Arguments()), ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Reactive::Expression_typeof(), NULL))) > 1)
    {
        ::g::Fuse::Diagnostics::UserError(::g::Uno::String::op_Addition2(uString::Const("too many parameters for "), ::g::Uno::UX::Selector__op_Implicit1(__this->_item)), __this, ::STRINGS[77/*"C:\\Users\\...*/], 34, uString::Const("Subscribe"), NULL);
        return *__retval = NULL, void();
    }

    ::g::Fuse::Reactive::Expression* node = (::g::Uno::Collections::ICollection::Count(uInterface(uPtr(__this->Arguments()), ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Reactive::Expression_typeof(), NULL))) > 0) ? (::g::Uno::Collections::IList::get_Item_ex(uInterface(uPtr(__this->Arguments()), ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Reactive::Expression_typeof(), NULL)), uCRef<int32_t>(0), &ret1), ret1) : NULL;
    InstantiatorFunction__InstantiatorSubscription* ins = InstantiatorFunction__InstantiatorSubscription::New1(__this, __this->_item, listener, context, (uObject*)node);
    ins->Init(context);
    return *__retval = (uObject*)ins, void();
}

// public override sealed string ToString() :25
void InstantiatorFunction__ToString_fn(InstantiatorFunction* __this, uString** __retval)
{
    uStackFrame __("Fuse.Reactive.InstantiatorFunction", "ToString()");
    return *__retval = __this->FormatString(::g::Uno::UX::Selector__op_Implicit1(__this->_item)), void();
}

::g::Uno::UX::Selector InstantiatorFunction::DataIndexName_;
::g::Uno::UX::Selector InstantiatorFunction::OffsetIndexName_;

// internal InstantiatorFunction(Uno.UX.Selector item) [instance] :19
void InstantiatorFunction::ctor_2(::g::Uno::UX::Selector item)
{
    ctor_1();
    _item = item;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\InstantiatorFunction.uno
// ---------------------------------------------------------------------------------------------------------

// private sealed class InstantiatorFunction.InstantiatorSubscription :44
// {
static void InstantiatorFunction__InstantiatorSubscription_build(uType* type)
{
    ::STRINGS[76] = uString::Const("invalid search node for InstantiatorFunction");
    ::STRINGS[77] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Bindings\\1.8.1\\InstantiatorFunction.uno");
    ::STRINGS[78] = uString::Const("OnNewNode");
    ::STRINGS[79] = uString::Const("Could not find an Instantiator");
    ::STRINGS[80] = uString::Const("Unable to resolve Instantiator node");
    ::TYPES[37] = ::g::Uno::Action_typeof();
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    ::TYPES[38] = ::g::Fuse::Reactive::IExpression_typeof();
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    ::TYPES[42] = ::g::Fuse::Node_typeof();
    ::TYPES[27] = ::g::Fuse::Reactive::IContext_typeof();
    ::TYPES[45] = ::TYPES[42/*Fuse.Node*/]->MakeMethod(0/*FindBehavior<Fuse.Reactive.Instantiator>*/, ::g::Fuse::Reactive::Instantiator_typeof(), NULL);
    type->SetDependencies(
        ::g::Fuse::Reactive::InstantiatorFunction_typeof());
    type->SetInterfaces(
        ::TYPES[3/*Uno.IDisposable*/], offsetof(::g::Fuse::Reactive::InnerListener_type, interface0),
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(::g::Fuse::Reactive::InnerListener_type, interface1));
    type->SetFields(2,
        ::g::Fuse::Reactive::InstantiatorFunction_typeof(), offsetof(InstantiatorFunction__InstantiatorSubscription, _expr), 0,
        ::g::Uno::UX::Selector_typeof(), offsetof(InstantiatorFunction__InstantiatorSubscription, _item), 0,
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(InstantiatorFunction__InstantiatorSubscription, _listener), 0,
        ::TYPES[27/*Fuse.Reactive.IContext*/], offsetof(InstantiatorFunction__InstantiatorSubscription, _context), 0,
        ::TYPES[38/*Fuse.Reactive.IExpression*/], offsetof(InstantiatorFunction__InstantiatorSubscription, _node), 0,
        ::g::Fuse::Reactive::Instantiator_typeof(), offsetof(InstantiatorFunction__InstantiatorSubscription, _instantiator), 0,
        ::TYPES[42/*Fuse.Node*/], offsetof(InstantiatorFunction__InstantiatorSubscription, _instance), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(InstantiatorFunction__InstantiatorSubscription, _nodeSub), 0);
}

::g::Fuse::Reactive::InnerListener_type* InstantiatorFunction__InstantiatorSubscription_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::InnerListener_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InnerListener_typeof();
    options.FieldCount = 10;
    options.InterfaceCount = 2;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(InstantiatorFunction__InstantiatorSubscription);
    options.TypeSize = sizeof(::g::Fuse::Reactive::InnerListener_type);
    type = (::g::Fuse::Reactive::InnerListener_type*)uClassType::New("Fuse.Reactive.InstantiatorFunction.InstantiatorSubscription", options);
    type->fp_build_ = InstantiatorFunction__InstantiatorSubscription_build;
    type->fp_Dispose = (void(*)(::g::Fuse::Reactive::InnerListener*))InstantiatorFunction__InstantiatorSubscription__Dispose_fn;
    type->fp_OnLostData = (void(*)(::g::Fuse::Reactive::InnerListener*, uObject*))InstantiatorFunction__InstantiatorSubscription__OnLostData_fn;
    type->fp_OnNewData = (void(*)(::g::Fuse::Reactive::InnerListener*, uObject*, uObject*))InstantiatorFunction__InstantiatorSubscription__OnNewData_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))InstantiatorFunction__InstantiatorSubscription__Dispose_fn;
    return type;
}

// public InstantiatorSubscription(Fuse.Reactive.InstantiatorFunction expr, Uno.UX.Selector item, Fuse.Reactive.IListener listener, Fuse.Reactive.IContext context, Fuse.Reactive.IExpression node) :59
void InstantiatorFunction__InstantiatorSubscription__ctor_1_fn(InstantiatorFunction__InstantiatorSubscription* __this, ::g::Fuse::Reactive::InstantiatorFunction* expr, ::g::Uno::UX::Selector* item, uObject* listener, uObject* context, uObject* node)
{
    __this->ctor_1(expr, *item, listener, context, node);
}

// public override sealed void Dispose() :135
void InstantiatorFunction__InstantiatorSubscription__Dispose_fn(InstantiatorFunction__InstantiatorSubscription* __this)
{
    uStackFrame __("Fuse.Reactive.InstantiatorFunction.InstantiatorSubscription", "Dispose()");
    ::g::Fuse::Reactive::InnerListener__Dispose_fn(__this);
    __this->_expr = NULL;
    __this->_listener = NULL;

    if (__this->_instantiator != NULL)
        uPtr(__this->_instantiator)->remove_UpdatedWindowItems(uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)InstantiatorFunction__InstantiatorSubscription__OnUpdatedWindowItems_fn, __this));

    __this->_instantiator = NULL;

    if (__this->_nodeSub != NULL)
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(__this->_nodeSub), ::TYPES[3/*Uno.IDisposable*/]));

    __this->_nodeSub = NULL;
    __this->_node = NULL;
}

// public void Init(Fuse.Reactive.IContext context) :70
void InstantiatorFunction__InstantiatorSubscription__Init_fn(InstantiatorFunction__InstantiatorSubscription* __this, uObject* context)
{
    __this->Init(context);
}

// public InstantiatorSubscription New(Fuse.Reactive.InstantiatorFunction expr, Uno.UX.Selector item, Fuse.Reactive.IListener listener, Fuse.Reactive.IContext context, Fuse.Reactive.IExpression node) :59
void InstantiatorFunction__InstantiatorSubscription__New1_fn(::g::Fuse::Reactive::InstantiatorFunction* expr, ::g::Uno::UX::Selector* item, uObject* listener, uObject* context, uObject* node, InstantiatorFunction__InstantiatorSubscription** __retval)
{
    *__retval = InstantiatorFunction__InstantiatorSubscription::New1(expr, *item, listener, context, node);
}

// protected override sealed void OnLostData(Fuse.Reactive.IExpression source) :84
void InstantiatorFunction__InstantiatorSubscription__OnLostData_fn(InstantiatorFunction__InstantiatorSubscription* __this, uObject* source)
{
    uStackFrame __("Fuse.Reactive.InstantiatorFunction.InstantiatorSubscription", "OnLostData(Fuse.Reactive.IExpression)");

    if (source == __this->_node)
        ::g::Fuse::Reactive::IListener::OnLostData(uInterface(uPtr(__this->_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)__this->_expr);
}

// protected override sealed void OnNewData(Fuse.Reactive.IExpression source, object value) :78
void InstantiatorFunction__InstantiatorSubscription__OnNewData_fn(InstantiatorFunction__InstantiatorSubscription* __this, uObject* source, uObject* value)
{
    uStackFrame __("Fuse.Reactive.InstantiatorFunction.InstantiatorSubscription", "OnNewData(Fuse.Reactive.IExpression,object)");

    if (source == __this->_node)
        __this->OnNewNode(value);
}

// private void OnNewNode(object obj) :90
void InstantiatorFunction__InstantiatorSubscription__OnNewNode_fn(InstantiatorFunction__InstantiatorSubscription* __this, uObject* obj)
{
    __this->OnNewNode(obj);
}

// private void OnUpdatedWindowItems() :163
void InstantiatorFunction__InstantiatorSubscription__OnUpdatedWindowItems_fn(InstantiatorFunction__InstantiatorSubscription* __this)
{
    __this->OnUpdatedWindowItems();
}

// private void PushValue() :149
void InstantiatorFunction__InstantiatorSubscription__PushValue_fn(InstantiatorFunction__InstantiatorSubscription* __this)
{
    __this->PushValue();
}

// public InstantiatorSubscription(Fuse.Reactive.InstantiatorFunction expr, Uno.UX.Selector item, Fuse.Reactive.IListener listener, Fuse.Reactive.IContext context, Fuse.Reactive.IExpression node) [instance] :59
void InstantiatorFunction__InstantiatorSubscription::ctor_1(::g::Fuse::Reactive::InstantiatorFunction* expr, ::g::Uno::UX::Selector item, uObject* listener, uObject* context, uObject* node)
{
    ctor_();
    _node = node;
    _expr = expr;
    _item = item;
    _listener = listener;
    _context = context;
}

// public void Init(Fuse.Reactive.IContext context) [instance] :70
void InstantiatorFunction__InstantiatorSubscription::Init(uObject* context)
{
    uStackFrame __("Fuse.Reactive.InstantiatorFunction.InstantiatorSubscription", "Init(Fuse.Reactive.IContext)");

    if (_node == NULL)
        OnNewNode(NULL);
    else
        _nodeSub = ::g::Fuse::Reactive::IExpression::Subscribe(uInterface(uPtr(_node), ::TYPES[38/*Fuse.Reactive.IExpression*/]), context, (uObject*)this);
}

// private void OnNewNode(object obj) [instance] :90
void InstantiatorFunction__InstantiatorSubscription::OnNewNode(uObject* obj)
{
    uStackFrame __("Fuse.Reactive.InstantiatorFunction.InstantiatorSubscription", "OnNewNode(object)");
    ::g::Fuse::Node* ind1;

    if (_instantiator != NULL)
    {
        uPtr(_instantiator)->remove_UpdatedWindowItems(uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)InstantiatorFunction__InstantiatorSubscription__OnUpdatedWindowItems_fn, this));
        _instantiator = NULL;
        _instance = NULL;
    }

    ind1 = uAs< ::g::Fuse::Node*>(obj, ::TYPES[42/*Fuse.Node*/]);
    ::g::Fuse::Node* searchNode = (ind1 != NULL) ? ind1 : (::g::Fuse::Node*)::g::Fuse::Reactive::IContext::Node(uInterface(uPtr(_context), ::TYPES[27/*Fuse.Reactive.IContext*/]));

    if (searchNode == NULL)
    {
        ::g::Fuse::Diagnostics::UserError(::STRINGS[76/*"invalid sea...*/], this, ::STRINGS[77/*"C:\\Users\\...*/], 102, ::STRINGS[78/*"OnNewNode"*/], NULL);
        ::g::Fuse::Reactive::IListener::OnLostData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_expr);
        return;
    }

    _instantiator = ((::g::Fuse::Reactive::Instantiator*)uPtr(searchNode)->FindBehavior(::TYPES[45/*Fuse.Node.FindBehavior<Fuse.Reactive.Instantiator>*/]));

    if (_instantiator == NULL)
    {
        ::g::Fuse::Diagnostics::UserError(::STRINGS[79/*"Could not f...*/], this, ::STRINGS[77/*"C:\\Users\\...*/], 110, ::STRINGS[78/*"OnNewNode"*/], NULL);
        ::g::Fuse::Reactive::IListener::OnLostData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_expr);
        return;
    }

    ::g::Fuse::Node* p = ::g::Fuse::Reactive::IContext::Node(uInterface(uPtr(_context), ::TYPES[27/*Fuse.Reactive.IContext*/]));

    while ((p != NULL) && (uPtr(p)->ContextParent() != _instantiator))
        p = uPtr(p)->ContextParent();

    if (p == NULL)
    {
        ::g::Fuse::Diagnostics::InternalError(::STRINGS[80/*"Unable to r...*/], this, ::STRINGS[77/*"C:\\Users\\...*/], 122, ::STRINGS[78/*"OnNewNode"*/]);
        ::g::Fuse::Reactive::IListener::OnLostData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_expr);
        return;
    }

    if (_instantiator != NULL)
    {
        _instance = p;
        uPtr(_instantiator)->add_UpdatedWindowItems(uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)InstantiatorFunction__InstantiatorSubscription__OnUpdatedWindowItems_fn, this));
        PushValue();
    }
}

// private void OnUpdatedWindowItems() [instance] :163
void InstantiatorFunction__InstantiatorSubscription::OnUpdatedWindowItems()
{
    uStackFrame __("Fuse.Reactive.InstantiatorFunction.InstantiatorSubscription", "OnUpdatedWindowItems()");
    PushValue();
}

// private void PushValue() [instance] :149
void InstantiatorFunction__InstantiatorSubscription::PushValue()
{
    uStackFrame __("Fuse.Reactive.InstantiatorFunction.InstantiatorSubscription", "PushValue()");
    int32_t q = -1;

    if (::g::Uno::UX::Selector__op_Equality(_item, ::g::Fuse::Reactive::InstantiatorFunction::DataIndexName()))
        q = uPtr(_instantiator)->DataIndexOfChild(_instance);
    else if (::g::Uno::UX::Selector__op_Equality(_item, ::g::Fuse::Reactive::InstantiatorFunction::OffsetIndexName()))
        q = uPtr(_instantiator)->DataIndexOfChild(_instance) - uPtr(_instantiator)->Offset();

    if (q != -1)
        ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_expr, uBox<int32_t>(::TYPES[20/*int*/], q));
    else
        ::g::Fuse::Reactive::IListener::OnLostData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_expr);
}

// public InstantiatorSubscription New(Fuse.Reactive.InstantiatorFunction expr, Uno.UX.Selector item, Fuse.Reactive.IListener listener, Fuse.Reactive.IContext context, Fuse.Reactive.IExpression node) [static] :59
InstantiatorFunction__InstantiatorSubscription* InstantiatorFunction__InstantiatorSubscription::New1(::g::Fuse::Reactive::InstantiatorFunction* expr, ::g::Uno::UX::Selector item, uObject* listener, uObject* context, uObject* node)
{
    InstantiatorFunction__InstantiatorSubscription* obj2 = (InstantiatorFunction__InstantiatorSubscription*)uNew(InstantiatorFunction__InstantiatorSubscription_typeof());
    obj2->ctor_1(expr, item, listener, context, node);
    return obj2;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\IObservable.uno
// ---------------------------------------------------------------------------------------

// internal abstract interface IObservable :125
// {
uInterfaceType* IObservable_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.IObservable", 0, 0);
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\IObservable.uno
// ---------------------------------------------------------------------------------------

// internal abstract interface IObservableArray :54
// {
uInterfaceType* IObservableArray_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.IObservableArray", 0, 0);
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\IObservable.uno
// ---------------------------------------------------------------------------------------

// internal abstract interface IObservableObject :16
// {
uInterfaceType* IObservableObject_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.IObservableObject", 0, 0);
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\IObservable.uno
// ---------------------------------------------------------------------------------------

// internal abstract interface IObserver :142
// {
uInterfaceType* IObserver_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.IObserver", 0, 0);
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\IObservable.uno
// ---------------------------------------------------------------------------------------

// internal abstract interface IPropertyObserver :28
// {
uInterfaceType* IPropertyObserver_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.IPropertyObserver", 0, 0);
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\IObservable.uno
// ---------------------------------------------------------------------------------------

// internal abstract interface IPropertySubscription :22
// {
uInterfaceType* IPropertySubscription_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.IPropertySubscription", 0, 0);
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\PlatformFunctions.uno
// ---------------------------------------------------------------------------------------------------------

// public sealed class IsAndroidFunction :77
// {
static void IsAndroidFunction_build(uType* type)
{
    ::STRINGS[81] = uString::Const("Android");
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::PlatformFunction_type, interface0));
    type->SetFields(1);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)IsAndroidFunction__New1_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::PlatformFunction_type* IsAndroidFunction_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::PlatformFunction_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::PlatformFunction_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(IsAndroidFunction);
    options.TypeSize = sizeof(::g::Fuse::Reactive::PlatformFunction_type);
    type = (::g::Fuse::Reactive::PlatformFunction_type*)uClassType::New("Fuse.Reactive.IsAndroidFunction", options);
    type->fp_build_ = IsAndroidFunction_build;
    type->fp_ctor_ = (void*)IsAndroidFunction__New1_fn;
    type->fp_GetResult = (void(*)(::g::Fuse::Reactive::PlatformFunction*, bool*))IsAndroidFunction__GetResult_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::PlatformFunction__Subscribe_fn;
    return type;
}

// public IsAndroidFunction() :80
void IsAndroidFunction__ctor_2_fn(IsAndroidFunction* __this)
{
    __this->ctor_2();
}

// protected override sealed bool GetResult() :81
void IsAndroidFunction__GetResult_fn(IsAndroidFunction* __this, bool* __retval)
{
    return *__retval = true, void();
}

// public IsAndroidFunction New() :80
void IsAndroidFunction__New1_fn(IsAndroidFunction** __retval)
{
    *__retval = IsAndroidFunction::New1();
}

// public IsAndroidFunction() [instance] :80
void IsAndroidFunction::ctor_2()
{
    ctor_1(::STRINGS[81/*"Android"*/]);
}

// public IsAndroidFunction New() [static] :80
IsAndroidFunction* IsAndroidFunction::New1()
{
    IsAndroidFunction* obj1 = (IsAndroidFunction*)uNew(IsAndroidFunction_typeof());
    obj1->ctor_2();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\IsDefined.uno
// -------------------------------------------------------------------------------------------------

// public sealed class IsDefined :17
// {
static void IsDefined_build(uType* type)
{
    ::TYPES[10] = ::g::Fuse::Reactive::Expression_typeof()->Array();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::ComputeExpression_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(2,
        new uFunction(".ctor", NULL, (void*)IsDefined__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()),
        new uFunction("get_Operand", NULL, (void*)IsDefined__get_Operand_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0));
}

::g::Fuse::Reactive::ComputeExpression_type* IsDefined_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::ComputeExpression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ComputeExpression_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(IsDefined);
    options.TypeSize = sizeof(::g::Fuse::Reactive::ComputeExpression_type);
    type = (::g::Fuse::Reactive::ComputeExpression_type*)uClassType::New("Fuse.Reactive.IsDefined", options);
    type->fp_build_ = IsDefined_build;
    type->fp_TryCompute = (void(*)(::g::Fuse::Reactive::ComputeExpression*, uArray*, uObject**, bool*))IsDefined__TryCompute_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public IsDefined(Fuse.Reactive.Expression operand) :22
void IsDefined__ctor_2_fn(IsDefined* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_2(operand);
}

// public IsDefined New(Fuse.Reactive.Expression operand) :22
void IsDefined__New1_fn(::g::Fuse::Reactive::Expression* operand, IsDefined** __retval)
{
    *__retval = IsDefined::New1(operand);
}

// public Fuse.Reactive.Expression get_Operand() :19
void IsDefined__get_Operand_fn(IsDefined* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->Operand();
}

// protected override sealed bool TryCompute(Fuse.Reactive.Expression.Argument[] args, object& result) :26
void IsDefined__TryCompute_fn(IsDefined* __this, uArray* args, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.IsDefined", "TryCompute(Fuse.Reactive.Expression.Argument[],object&)");
    *result = uBox(::TYPES[12/*bool*/], uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(0))->HasValue());
    return *__retval = true, void();
}

// public IsDefined(Fuse.Reactive.Expression operand) [instance] :22
void IsDefined::ctor_2(::g::Fuse::Reactive::Expression* operand)
{
    uStackFrame __("Fuse.Reactive.IsDefined", ".ctor(Fuse.Reactive.Expression)");
    ctor_1(uArray::Init< ::g::Fuse::Reactive::Expression*>(::TYPES[10/*Fuse.Reactive.Expression[]*/], 1, operand), 48, NULL);
}

// public Fuse.Reactive.Expression get_Operand() [instance] :19
::g::Fuse::Reactive::Expression* IsDefined::Operand()
{
    uStackFrame __("Fuse.Reactive.IsDefined", "get_Operand()");
    return GetArgument(0);
}

// public IsDefined New(Fuse.Reactive.Expression operand) [static] :22
IsDefined* IsDefined::New1(::g::Fuse::Reactive::Expression* operand)
{
    IsDefined* obj1 = (IsDefined*)uNew(IsDefined_typeof());
    obj1->ctor_2(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\PlatformFunctions.uno
// ---------------------------------------------------------------------------------------------------------

// public sealed class IsDesktopFunction :68
// {
static void IsDesktopFunction_build(uType* type)
{
    ::STRINGS[82] = uString::Const("Desktop");
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::PlatformFunction_type, interface0));
    type->SetFields(1);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)IsDesktopFunction__New1_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::PlatformFunction_type* IsDesktopFunction_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::PlatformFunction_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::PlatformFunction_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(IsDesktopFunction);
    options.TypeSize = sizeof(::g::Fuse::Reactive::PlatformFunction_type);
    type = (::g::Fuse::Reactive::PlatformFunction_type*)uClassType::New("Fuse.Reactive.IsDesktopFunction", options);
    type->fp_build_ = IsDesktopFunction_build;
    type->fp_ctor_ = (void*)IsDesktopFunction__New1_fn;
    type->fp_GetResult = (void(*)(::g::Fuse::Reactive::PlatformFunction*, bool*))IsDesktopFunction__GetResult_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::PlatformFunction__Subscribe_fn;
    return type;
}

// public IsDesktopFunction() :71
void IsDesktopFunction__ctor_2_fn(IsDesktopFunction* __this)
{
    __this->ctor_2();
}

// protected override sealed bool GetResult() :72
void IsDesktopFunction__GetResult_fn(IsDesktopFunction* __this, bool* __retval)
{
    return *__retval = false, void();
}

// public IsDesktopFunction New() :71
void IsDesktopFunction__New1_fn(IsDesktopFunction** __retval)
{
    *__retval = IsDesktopFunction::New1();
}

// public IsDesktopFunction() [instance] :71
void IsDesktopFunction::ctor_2()
{
    ctor_1(::STRINGS[82/*"Desktop"*/]);
}

// public IsDesktopFunction New() [static] :71
IsDesktopFunction* IsDesktopFunction::New1()
{
    IsDesktopFunction* obj1 = (IsDesktopFunction*)uNew(IsDesktopFunction_typeof());
    obj1->ctor_2();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\PlatformFunctions.uno
// ---------------------------------------------------------------------------------------------------------

// public sealed class IsIOSFunction :59
// {
static void IsIOSFunction_build(uType* type)
{
    ::STRINGS[83] = uString::Const("IOS");
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::PlatformFunction_type, interface0));
    type->SetFields(1);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)IsIOSFunction__New1_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::PlatformFunction_type* IsIOSFunction_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::PlatformFunction_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::PlatformFunction_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(IsIOSFunction);
    options.TypeSize = sizeof(::g::Fuse::Reactive::PlatformFunction_type);
    type = (::g::Fuse::Reactive::PlatformFunction_type*)uClassType::New("Fuse.Reactive.IsIOSFunction", options);
    type->fp_build_ = IsIOSFunction_build;
    type->fp_ctor_ = (void*)IsIOSFunction__New1_fn;
    type->fp_GetResult = (void(*)(::g::Fuse::Reactive::PlatformFunction*, bool*))IsIOSFunction__GetResult_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::PlatformFunction__Subscribe_fn;
    return type;
}

// public IsIOSFunction() :62
void IsIOSFunction__ctor_2_fn(IsIOSFunction* __this)
{
    __this->ctor_2();
}

// protected override sealed bool GetResult() :63
void IsIOSFunction__GetResult_fn(IsIOSFunction* __this, bool* __retval)
{
    return *__retval = false, void();
}

// public IsIOSFunction New() :62
void IsIOSFunction__New1_fn(IsIOSFunction** __retval)
{
    *__retval = IsIOSFunction::New1();
}

// public IsIOSFunction() [instance] :62
void IsIOSFunction::ctor_2()
{
    ctor_1(::STRINGS[83/*"IOS"*/]);
}

// public IsIOSFunction New() [static] :62
IsIOSFunction* IsIOSFunction::New1()
{
    IsIOSFunction* obj1 = (IsIOSFunction*)uNew(IsIOSFunction_typeof());
    obj1->ctor_2();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\PlatformFunctions.uno
// ---------------------------------------------------------------------------------------------------------

// public sealed class IsMobileFunction :86
// {
static void IsMobileFunction_build(uType* type)
{
    ::STRINGS[84] = uString::Const("Mobile");
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::PlatformFunction_type, interface0));
    type->SetFields(1);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)IsMobileFunction__New1_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::PlatformFunction_type* IsMobileFunction_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::PlatformFunction_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::PlatformFunction_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(IsMobileFunction);
    options.TypeSize = sizeof(::g::Fuse::Reactive::PlatformFunction_type);
    type = (::g::Fuse::Reactive::PlatformFunction_type*)uClassType::New("Fuse.Reactive.IsMobileFunction", options);
    type->fp_build_ = IsMobileFunction_build;
    type->fp_ctor_ = (void*)IsMobileFunction__New1_fn;
    type->fp_GetResult = (void(*)(::g::Fuse::Reactive::PlatformFunction*, bool*))IsMobileFunction__GetResult_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::PlatformFunction__Subscribe_fn;
    return type;
}

// public IsMobileFunction() :89
void IsMobileFunction__ctor_2_fn(IsMobileFunction* __this)
{
    __this->ctor_2();
}

// protected override sealed bool GetResult() :90
void IsMobileFunction__GetResult_fn(IsMobileFunction* __this, bool* __retval)
{
    return *__retval = true, void();
}

// public IsMobileFunction New() :89
void IsMobileFunction__New1_fn(IsMobileFunction** __retval)
{
    *__retval = IsMobileFunction::New1();
}

// public IsMobileFunction() [instance] :89
void IsMobileFunction::ctor_2()
{
    ctor_1(::STRINGS[84/*"Mobile"*/]);
}

// public IsMobileFunction New() [static] :89
IsMobileFunction* IsMobileFunction::New1()
{
    IsMobileFunction* obj1 = (IsMobileFunction*)uNew(IsMobileFunction_typeof());
    obj1->ctor_2();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\IsDefined.uno
// -------------------------------------------------------------------------------------------------

// public sealed class IsNull :44
// {
static void IsNull_build(uType* type)
{
    ::STRINGS[85] = uString::Const("isNull");
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)IsNull__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* IsNull_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(IsNull);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.IsNull", options);
    type->fp_build_ = IsNull_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::UnaryOperator*, uObject*, uObject**, bool*))IsNull__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public IsNull(Fuse.Reactive.Expression operand) :47
void IsNull__ctor_4_fn(IsNull* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_4(operand);
}

// public IsNull New(Fuse.Reactive.Expression operand) :47
void IsNull__New1_fn(::g::Fuse::Reactive::Expression* operand, IsNull** __retval)
{
    *__retval = IsNull::New1(operand);
}

// protected override sealed bool TryCompute(object operand, object& result) :49
void IsNull__TryCompute1_fn(IsNull* __this, uObject* operand, uObject** result, bool* __retval)
{
    *result = uBox(::TYPES[12/*bool*/], operand == NULL);
    return *__retval = true, void();
}

// public IsNull(Fuse.Reactive.Expression operand) [instance] :47
void IsNull::ctor_4(::g::Fuse::Reactive::Expression* operand)
{
    ctor_3(operand, ::STRINGS[85/*"isNull"*/], 1);
}

// public IsNull New(Fuse.Reactive.Expression operand) [static] :47
IsNull* IsNull::New1(::g::Fuse::Reactive::Expression* operand)
{
    IsNull* obj1 = (IsNull*)uNew(IsNull_typeof());
    obj1->ctor_4(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\PlatformFunctions.uno
// ---------------------------------------------------------------------------------------------------------

// public sealed class IsOSXFunction :95
// {
static void IsOSXFunction_build(uType* type)
{
    ::STRINGS[86] = uString::Const("OSX");
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::PlatformFunction_type, interface0));
    type->SetFields(1);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)IsOSXFunction__New1_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::PlatformFunction_type* IsOSXFunction_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::PlatformFunction_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::PlatformFunction_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(IsOSXFunction);
    options.TypeSize = sizeof(::g::Fuse::Reactive::PlatformFunction_type);
    type = (::g::Fuse::Reactive::PlatformFunction_type*)uClassType::New("Fuse.Reactive.IsOSXFunction", options);
    type->fp_build_ = IsOSXFunction_build;
    type->fp_ctor_ = (void*)IsOSXFunction__New1_fn;
    type->fp_GetResult = (void(*)(::g::Fuse::Reactive::PlatformFunction*, bool*))IsOSXFunction__GetResult_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::PlatformFunction__Subscribe_fn;
    return type;
}

// public IsOSXFunction() :98
void IsOSXFunction__ctor_2_fn(IsOSXFunction* __this)
{
    __this->ctor_2();
}

// protected override sealed bool GetResult() :99
void IsOSXFunction__GetResult_fn(IsOSXFunction* __this, bool* __retval)
{
    return *__retval = false, void();
}

// public IsOSXFunction New() :98
void IsOSXFunction__New1_fn(IsOSXFunction** __retval)
{
    *__retval = IsOSXFunction::New1();
}

// public IsOSXFunction() [instance] :98
void IsOSXFunction::ctor_2()
{
    ctor_1(::STRINGS[86/*"OSX"*/]);
}

// public IsOSXFunction New() [static] :98
IsOSXFunction* IsOSXFunction::New1()
{
    IsOSXFunction* obj1 = (IsOSXFunction*)uNew(IsOSXFunction_typeof());
    obj1->ctor_2();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\IObservable.uno
// ---------------------------------------------------------------------------------------

// internal abstract interface ISubscription :131
// {
uInterfaceType* ISubscription_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.ISubscription", 0, 0);
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\PlatformFunctions.uno
// ---------------------------------------------------------------------------------------------------------

// public sealed class IsWindowsFunction :104
// {
static void IsWindowsFunction_build(uType* type)
{
    ::STRINGS[87] = uString::Const("Windows");
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::PlatformFunction_type, interface0));
    type->SetFields(1);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)IsWindowsFunction__New1_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::PlatformFunction_type* IsWindowsFunction_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::PlatformFunction_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::PlatformFunction_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(IsWindowsFunction);
    options.TypeSize = sizeof(::g::Fuse::Reactive::PlatformFunction_type);
    type = (::g::Fuse::Reactive::PlatformFunction_type*)uClassType::New("Fuse.Reactive.IsWindowsFunction", options);
    type->fp_build_ = IsWindowsFunction_build;
    type->fp_ctor_ = (void*)IsWindowsFunction__New1_fn;
    type->fp_GetResult = (void(*)(::g::Fuse::Reactive::PlatformFunction*, bool*))IsWindowsFunction__GetResult_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::PlatformFunction__Subscribe_fn;
    return type;
}

// public IsWindowsFunction() :107
void IsWindowsFunction__ctor_2_fn(IsWindowsFunction* __this)
{
    __this->ctor_2();
}

// protected override sealed bool GetResult() :108
void IsWindowsFunction__GetResult_fn(IsWindowsFunction* __this, bool* __retval)
{
    return *__retval = false, void();
}

// public IsWindowsFunction New() :107
void IsWindowsFunction__New1_fn(IsWindowsFunction** __retval)
{
    *__retval = IsWindowsFunction::New1();
}

// public IsWindowsFunction() [instance] :107
void IsWindowsFunction::ctor_2()
{
    ctor_1(::STRINGS[87/*"Windows"*/]);
}

// public IsWindowsFunction New() [static] :107
IsWindowsFunction* IsWindowsFunction::New1()
{
    IsWindowsFunction* obj1 = (IsWindowsFunction*)uNew(IsWindowsFunction_typeof());
    obj1->ctor_2();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\ItemsWindowList.uno
// ----------------------------------------------------------------------------------------------------

// internal partial sealed class ItemsWindowList<T> :12
// {
static void ItemsWindowList_build(uType* type)
{
    type->SetBase(::g::Fuse::Reactive::WindowList_typeof()->MakeType(type->T(0), NULL));
    type->SetPrecalc(
        ::g::Fuse::Reactive::WindowListItem_typeof()->MakeMethod(0/*Create<T>*/, type->T(0), NULL),
        ItemsWindowList__IListener_typeof()->MakeType(type->T(0), NULL));
    type->SetInterfaces(
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(ItemsWindowList_type, interface0),
        ::g::Fuse::Reactive::WindowListItem__IDataWatcher_typeof(), offsetof(ItemsWindowList_type, interface1));
    type->SetFields(5,
        ItemsWindowList__IListener_typeof()->MakeType(type->T(0), NULL), offsetof(ItemsWindowList, _listener), uFieldFlagsWeak,
        ::g::Fuse::Reactive::InstanceIdentity_typeof(), offsetof(ItemsWindowList, Identity), 0,
        ::g::Uno::String_typeof(), offsetof(ItemsWindowList, _identityKey), 0,
        uObject_typeof(), offsetof(ItemsWindowList, _items), 0,
        ::g::Uno::IDisposable_typeof(), offsetof(ItemsWindowList, _itemsSubscription), 0,
        ::g::Uno::Bool_typeof(), offsetof(ItemsWindowList, _isRooted), 0);
}

ItemsWindowList_type* ItemsWindowList_typeof()
{
    static uSStrong<ItemsWindowList_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::WindowList_typeof();
    options.FieldCount = 11;
    options.GenericCount = 1;
    options.InterfaceCount = 2;
    options.PrecalcCount = 2;
    options.ObjectSize = sizeof(ItemsWindowList);
    options.TypeSize = sizeof(ItemsWindowList_type);
    type = (ItemsWindowList_type*)uClassType::New("Fuse.Reactive.ItemsWindowList`1", options);
    type->fp_build_ = ItemsWindowList_build;
    type->fp_CreateWindowItem = (void(*)(::g::Fuse::Reactive::WindowList*, int32_t*, uObject**))ItemsWindowList__CreateWindowItem_fn;
    type->fp_GetDataCount = (void(*)(::g::Fuse::Reactive::WindowList*, int32_t*))ItemsWindowList__GetDataCount_fn;
    type->fp_OnAddedWindowItem = (void(*)(::g::Fuse::Reactive::WindowList*, int32_t*, uObject*))ItemsWindowList__OnAddedWindowItem_fn;
    type->fp_OnErrorMessageChanged = (void(*)(::g::Fuse::Reactive::WindowList*, uString*))ItemsWindowList__OnErrorMessageChanged_fn;
    type->fp_OnRemovedWindowItem = (void(*)(::g::Fuse::Reactive::WindowList*, uObject*))ItemsWindowList__OnRemovedWindowItem_fn;
    type->interface1.fp_OnCurrentDataChanged = (void(*)(uObject*, ::g::Fuse::Reactive::WindowListItem*, uObject*))ItemsWindowList__FuseReactiveWindowListItemIDataWatcherOnCurrentDataChanged_fn;
    type->interface0.fp_OnSet = (void(*)(uObject*, uObject*))ItemsWindowList__FuseReactiveIObserverOnSet_fn;
    type->interface0.fp_OnFailed = (void(*)(uObject*, uString*))ItemsWindowList__FuseReactiveIObserverOnFailed_fn;
    type->interface0.fp_OnAdd = (void(*)(uObject*, uObject*))ItemsWindowList__FuseReactiveIObserverOnAdd_fn;
    type->interface0.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))ItemsWindowList__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface0.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))ItemsWindowList__FuseReactiveIObserverOnInsertAt_fn;
    type->interface0.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))ItemsWindowList__FuseReactiveIObserverOnNewAt_fn;
    type->interface0.fp_OnNewAll = (void(*)(uObject*, uObject*))ItemsWindowList__FuseReactiveIObserverOnNewAll_fn;
    type->interface0.fp_OnClear = (void(*)(uObject*))ItemsWindowList__FuseReactiveIObserverOnClear_fn;
    return type;
}

// public ItemsWindowList(Fuse.Reactive.ItemsWindowList<T>.IListener listener) :29
void ItemsWindowList__ctor_1_fn(ItemsWindowList* __this, uObject* listener)
{
    __this->ctor_1(listener);
}

// protected override sealed T CreateWindowItem(int dataIndex) :178
void ItemsWindowList__CreateWindowItem_fn(ItemsWindowList* __this, int32_t* dataIndex, ::g::Fuse::Reactive::WindowListItem** __retval)
{
    uType* __types[] = {
        __this->__type->Precalced(0/*Fuse.Reactive.WindowListItem.Create<T>*/),
    };
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "CreateWindowItem(int)");
    int32_t dataIndex_ = *dataIndex;
    uObject* data = __this->GetData(dataIndex_);
    ::g::Fuse::Reactive::WindowListItem* wi = (::g::Fuse::Reactive::WindowListItem*)::g::Fuse::Reactive::WindowListItem::Create(__types[0], (uObject*)__this, __this->GetDataId(data), data);
    return *__retval = wi, void();
}

// private void DisposeItemsSubscription() :76
void ItemsWindowList__DisposeItemsSubscription_fn(ItemsWindowList* __this)
{
    __this->DisposeItemsSubscription();
}

// private void Fuse.Reactive.IObserver.OnAdd(object addedValue) :286
void ItemsWindowList__FuseReactiveIObserverOnAdd_fn(ItemsWindowList* __this, uObject* addedValue)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "Fuse.Reactive.IObserver.OnAdd(object)");
    __this->TrimAndPad();
}

// private void Fuse.Reactive.IObserver.OnClear() :323
void ItemsWindowList__FuseReactiveIObserverOnClear_fn(ItemsWindowList* __this)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "Fuse.Reactive.IObserver.OnClear()");
    __this->RemoveAll();
}

// private void Fuse.Reactive.IObserver.OnFailed(string message) :280
void ItemsWindowList__FuseReactiveIObserverOnFailed_fn(ItemsWindowList* __this, uString* message)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "Fuse.Reactive.IObserver.OnFailed(string)");
    __this->RemoveAll();
    __this->SetError(message);
}

// private void Fuse.Reactive.IObserver.OnInsertAt(int index, object value) :297
void ItemsWindowList__FuseReactiveIObserverOnInsertAt_fn(ItemsWindowList* __this, int32_t* index, uObject* value)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "Fuse.Reactive.IObserver.OnInsertAt(int,object)");
    int32_t index_ = *index;
    __this->InsertedDataAt(index_);
    __this->TrimAndPad();
}

// private void Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray values) :314
void ItemsWindowList__FuseReactiveIObserverOnNewAll_fn(ItemsWindowList* __this, uObject* values)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray)");

    if (__this->Identity != 0)
        __this->PatchTo(values);
    else
        __this->RemoveAll();

    __this->TrimAndPad();
}

// private void Fuse.Reactive.IObserver.OnNewAt(int index, object value) :303
void ItemsWindowList__FuseReactiveIObserverOnNewAt_fn(ItemsWindowList* __this, int32_t* index, uObject* value)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "Fuse.Reactive.IObserver.OnNewAt(int,object)");
    int32_t index_ = *index;

    if (!__this->TryUpdateAt(index_, value))
    {
        __this->RemovedDataAt(index_);
        __this->InsertedDataAt(index_);
    }

    __this->TrimAndPad();
}

// private void Fuse.Reactive.IObserver.OnRemoveAt(int index) :291
void ItemsWindowList__FuseReactiveIObserverOnRemoveAt_fn(ItemsWindowList* __this, int32_t* index)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "Fuse.Reactive.IObserver.OnRemoveAt(int)");
    int32_t index_ = *index;
    __this->RemovedDataAt(index_);
    __this->TrimAndPad();
}

// private void Fuse.Reactive.IObserver.OnSet(object newValue) :274
void ItemsWindowList__FuseReactiveIObserverOnSet_fn(ItemsWindowList* __this, uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "Fuse.Reactive.IObserver.OnSet(object)");
    __this->RemoveAll();
    __this->TrimAndPad();
}

// private void Fuse.Reactive.WindowListItem.IDataWatcher.OnCurrentDataChanged(Fuse.Reactive.WindowListItem item, object oldData) :164
void ItemsWindowList__FuseReactiveWindowListItemIDataWatcherOnCurrentDataChanged_fn(ItemsWindowList* __this, ::g::Fuse::Reactive::WindowListItem* item, uObject* oldData)
{
    uType* __types[] = {
        __this->__type->Precalced(1/*Fuse.Reactive.ItemsWindowList<T>.IListener*/),
    };
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "Fuse.Reactive.WindowListItem.IDataWatcher.OnCurrentDataChanged(Fuse.Reactive.WindowListItem,object)");

    if (!__this->_isRooted)
        return;

    ::g::Fuse::Reactive::WindowListItem* wi = uAs< ::g::Fuse::Reactive::WindowListItem*>(item, __this->__type->T(0));

    if (wi == NULL)
    {
        ::g::Fuse::Diagnostics::InternalError(uString::Const("Invalid item in WindowList"), __this, uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Bindings\\1.8.1\\ItemsWindowList.uno"), 171, uString::Const("Fuse.Reactive.WindowListItem.IDataWatcher.OnCurrentDataChanged"));
        return;
    }

    ItemsWindowList__IListener::OnCurrentDataChanged(uInterface(uPtr(__this->_listener), __types[0]), wi, oldData);
}

// private object GetData(int dataIndex) :85
void ItemsWindowList__GetData_fn(ItemsWindowList* __this, int32_t* dataIndex, uObject** __retval)
{
    *__retval = __this->GetData(*dataIndex);
}

// public override sealed int GetDataCount() :205
void ItemsWindowList__GetDataCount_fn(ItemsWindowList* __this, int32_t* __retval)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "GetDataCount()");

    if (!__this->_isRooted)
        return *__retval = 0, void();

    uArray* e = uAs<uArray*>(__this->_items, ::TYPES[4/*object[]*/]);

    if (e != NULL)
        return *__retval = uPtr(e)->Length(), void();

    uObject* a = uAs<uObject*>(__this->_items, ::TYPES[28/*Fuse.IArray*/]);

    if (a != NULL)
        return *__retval = ::g::Fuse::IArray::Length(uInterface(uPtr(a), ::TYPES[28/*Fuse.IArray*/])), void();

    return *__retval = 0, void();
}

// private object GetDataId(object data) :147
void ItemsWindowList__GetDataId_fn(ItemsWindowList* __this, uObject* data, uObject** __retval)
{
    *__retval = __this->GetDataId(data);
}

// internal object GetDataKey(object data, string key) :130
void ItemsWindowList__GetDataKey_fn(ItemsWindowList* __this, uObject* data, uString* key, uObject** __retval)
{
    *__retval = __this->GetDataKey(data, key);
}

// public object GetItems() :48
void ItemsWindowList__GetItems_fn(ItemsWindowList* __this, uObject** __retval)
{
    *__retval = __this->GetItems();
}

// public string get_IdentityKey() :39
void ItemsWindowList__get_IdentityKey_fn(ItemsWindowList* __this, uString** __retval)
{
    *__retval = __this->IdentityKey();
}

// public void set_IdentityKey(string value) :40
void ItemsWindowList__set_IdentityKey_fn(ItemsWindowList* __this, uString* value)
{
    __this->IdentityKey(value);
}

// private void ItemsChanged() :64
void ItemsWindowList__ItemsChanged_fn(ItemsWindowList* __this)
{
    __this->ItemsChanged();
}

// public ItemsWindowList New(Fuse.Reactive.ItemsWindowList<T>.IListener listener) :29
void ItemsWindowList__New1_fn(uType* __type, uObject* listener, ItemsWindowList** __retval)
{
    *__retval = ItemsWindowList::New1(__type, listener);
}

// protected override sealed void OnAddedWindowItem(int windowIndex, T wi) :200
void ItemsWindowList__OnAddedWindowItem_fn(ItemsWindowList* __this, int32_t* windowIndex, ::g::Fuse::Reactive::WindowListItem* wi)
{
    uType* __types[] = {
        __this->__type->Precalced(1/*Fuse.Reactive.ItemsWindowList<T>.IListener*/),
    };
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "OnAddedWindowItem(int,T)");
    int32_t windowIndex_ = *windowIndex;

    if (__this->_isRooted)
        ItemsWindowList__IListener::AddedWindowItem(uInterface(uPtr(__this->_listener), __types[0]), windowIndex_, wi);
}

// protected override sealed void OnErrorMessageChanged(string _errorMessage) :185
void ItemsWindowList__OnErrorMessageChanged_fn(ItemsWindowList* __this, uString* _errorMessage1)
{
    uType* __types[] = {
        __this->__type->Precalced(1/*Fuse.Reactive.ItemsWindowList<T>.IListener*/),
    };
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "OnErrorMessageChanged(string)");

    if (!__this->_isRooted)
        return;

    if (::g::Uno::String::op_Inequality(_errorMessage1, NULL))
        ItemsWindowList__IListener::SetFailed(uInterface(uPtr(__this->_listener), __types[0]), _errorMessage1);
    else
        ItemsWindowList__IListener::SetValid(uInterface(uPtr(__this->_listener), __types[0]));
}

// protected override sealed void OnRemovedWindowItem(T wi) :195
void ItemsWindowList__OnRemovedWindowItem_fn(ItemsWindowList* __this, ::g::Fuse::Reactive::WindowListItem* wi)
{
    uType* __types[] = {
        __this->__type->Precalced(1/*Fuse.Reactive.ItemsWindowList<T>.IListener*/),
    };
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "OnRemovedWindowItem(T)");

    if (__this->_isRooted)
        ItemsWindowList__IListener::RemovedWindowItem(uInterface(uPtr(__this->_listener), __types[0]), wi);
}

// private void PatchTo(Fuse.IArray values) :238
void ItemsWindowList__PatchTo_fn(ItemsWindowList* __this, uObject* values)
{
    __this->PatchTo(values);
}

// private void Repopulate() :110
void ItemsWindowList__Repopulate_fn(ItemsWindowList* __this)
{
    __this->Repopulate();
}

// public void Rooted() :97
void ItemsWindowList__Rooted_fn(ItemsWindowList* __this)
{
    __this->Rooted();
}

// public void SetItems(object value) :50
void ItemsWindowList__SetItems_fn(ItemsWindowList* __this, uObject* value)
{
    __this->SetItems(value);
}

// public void SetItemsDerivedRooting(object value) :58
void ItemsWindowList__SetItemsDerivedRooting_fn(ItemsWindowList* __this, uObject* value)
{
    __this->SetItemsDerivedRooting(value);
}

// private bool TryUpdateAt(int dataIndex, object newData) :220
void ItemsWindowList__TryUpdateAt_fn(ItemsWindowList* __this, int32_t* dataIndex, uObject* newData, bool* __retval)
{
    *__retval = __this->TryUpdateAt(*dataIndex, newData);
}

// public void Unrooted() :103
void ItemsWindowList__Unrooted_fn(ItemsWindowList* __this)
{
    __this->Unrooted();
}

// public ItemsWindowList(Fuse.Reactive.ItemsWindowList<T>.IListener listener) [instance] :29
void ItemsWindowList::ctor_1(uObject* listener)
{
    ctor_();
    _listener = listener;
}

// private void DisposeItemsSubscription() [instance] :76
void ItemsWindowList::DisposeItemsSubscription()
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "DisposeItemsSubscription()");

    if (_itemsSubscription != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_itemsSubscription), ::TYPES[3/*Uno.IDisposable*/]));
        _itemsSubscription = NULL;
    }
}

// private object GetData(int dataIndex) [instance] :85
uObject* ItemsWindowList::GetData(int32_t dataIndex)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "GetData(int)");
    uArray* e = uAs<uArray*>(_items, ::TYPES[4/*object[]*/]);

    if (e != NULL)
        return uPtr(e)->Strong<uObject*>(dataIndex);

    uObject* a = uAs<uObject*>(_items, ::TYPES[28/*Fuse.IArray*/]);

    if (a != NULL)
        return ::g::Fuse::IArray::Item(uInterface(uPtr(a), ::TYPES[28/*Fuse.IArray*/]), dataIndex);

    return NULL;
}

// private object GetDataId(object data) [instance] :147
uObject* ItemsWindowList::GetDataId(uObject* data)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "GetDataId(object)");

    switch (Identity)
    {
        case 0:
            return NULL;
        case 1:
            return GetDataKey(data, IdentityKey());
        case 2:
            return data;
    }

    return NULL;
}

// internal object GetDataKey(object data, string key) [instance] :130
uObject* ItemsWindowList::GetDataKey(uObject* data, uString* key)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "GetDataKey(object,string)");
    uObject* so = uAs<uObject*>(data, ::TYPES[50/*Fuse.IObject*/]);

    if ((so != NULL) && ::g::Uno::String::op_Inequality(key, NULL))
    {
        if (::g::Fuse::IObject::ContainsKey(uInterface(uPtr(so), ::TYPES[50/*Fuse.IObject*/]), key))
            return ::g::Fuse::IObject::Item(uInterface(uPtr(so), ::TYPES[50/*Fuse.IObject*/]), key);
    }

    return NULL;
}

// public object GetItems() [instance] :48
uObject* ItemsWindowList::GetItems()
{
    return _items;
}

// public string get_IdentityKey() [instance] :39
uString* ItemsWindowList::IdentityKey()
{
    return _identityKey;
}

// public void set_IdentityKey(string value) [instance] :40
void ItemsWindowList::IdentityKey(uString* value)
{
    _identityKey = value;
    Identity = 1;
}

// private void ItemsChanged() [instance] :64
void ItemsWindowList::ItemsChanged()
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "ItemsChanged()");
    DisposeItemsSubscription();
    Repopulate();
    uObject* obs = uAs<uObject*>(_items, ::TYPES[30/*Fuse.Reactive.IObservableArray*/]);

    if (obs != NULL)
        _itemsSubscription = ::g::Fuse::Reactive::IObservableArray::Subscribe(uInterface(uPtr(obs), ::TYPES[30/*Fuse.Reactive.IObservableArray*/]), (uObject*)this);
}

// private void PatchTo(Fuse.IArray values) [instance] :238
void ItemsWindowList::PatchTo(uObject* values)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "PatchTo(Fuse.IArray)");
    ::g::Uno::Collections::List* ret2;
    ::g::Fuse::Reactive::Internal::PatchItem ret3;
    ::g::Uno::Collections::List* newIds = (::g::Uno::Collections::List*)::g::Uno::Collections::List::New1(::TYPES[60/*Uno.Collections.List`1*/]->MakeType(uObject_typeof(), NULL));
    int32_t limit = CalcOffsetLimitCountOf(::g::Fuse::IArray::Length(uInterface(uPtr(values), ::TYPES[28/*Fuse.IArray*/])));

    for (int32_t i = 0; i < limit; ++i)
        ::g::Uno::Collections::List__Add_fn(uPtr(newIds), GetDataId(::g::Fuse::IArray::Item(uInterface(uPtr(values), ::TYPES[28/*Fuse.IArray*/]), i + Offset())));

    ::g::Uno::Collections::List* curIds = (::g::Uno::Collections::List*)::g::Uno::Collections::List::New1(::TYPES[60/*Uno.Collections.List`1*/]->MakeType(uObject_typeof(), NULL));

    for (int32_t i1 = 0; i1 < WindowItemCount(); ++i1)
        ::g::Uno::Collections::List__Add_fn(uPtr(curIds), uPtr((::g::Fuse::Reactive::WindowListItem*)GetWindowItem(i1))->Id());

    ::g::Uno::Collections::List* ops = (::g::Fuse::Reactive::Internal::PatchList__Patch_fn(::g::Fuse::Reactive::Internal::PatchList_typeof()->MakeMethod(0/*Patch<object>*/, uObject_typeof(), NULL), (uObject*)curIds, (uObject*)newIds, uCRef<int32_t>(1), NULL, &ret2), ret2);

    for (int32_t i2 = 0; i2 < uPtr(ops)->Count(); ++i2)
    {
        ::g::Fuse::Reactive::Internal::PatchItem op = (::g::Uno::Collections::List__get_Item_fn(uPtr(ops), uCRef<int32_t>(i2), &ret3), ret3);

        switch (op.Op)
        {
            case 0:
            {
                RemovedDataAt(op.A + Offset());
                break;
            }
            case 1:
            {
                InsertWindowItem(DataToWindowIndex(op.A + Offset()), op.Data);
                break;
            }
            case 2:
            {
                if (!TryUpdateAt(op.A + Offset(), ::g::Fuse::IArray::Item(uInterface(uPtr(values), ::TYPES[28/*Fuse.IArray*/]), op.Data)))
                {
                    RemovedDataAt(op.A + Offset());
                    InsertWindowItem(DataToWindowIndex(op.A + Offset()), op.Data);
                }

                break;
            }
        }
    }
}

// private void Repopulate() [instance] :110
void ItemsWindowList::Repopulate()
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "Repopulate()");
    RemoveAll();
    uArray* e = uAs<uArray*>(_items, ::TYPES[4/*object[]*/]);

    if (e != NULL)

        for (int32_t i = 0; i < uPtr(e)->Length(); i++)
            InsertedDataAt(i);
    else
    {
        uObject* a = uAs<uObject*>(_items, ::TYPES[28/*Fuse.IArray*/]);

        if (a != NULL)

            for (int32_t i1 = 0; i1 < ::g::Fuse::IArray::Length(uInterface(uPtr(a), ::TYPES[28/*Fuse.IArray*/])); i1++)
                InsertedDataAt(i1);
    }
}

// public void Rooted() [instance] :97
void ItemsWindowList::Rooted()
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "Rooted()");
    _isRooted = true;
    ItemsChanged();
}

// public void SetItems(object value) [instance] :50
void ItemsWindowList::SetItems(uObject* value)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "SetItems(object)");
    _items = value;

    if (!_isRooted)
        return;

    ItemsChanged();
}

// public void SetItemsDerivedRooting(object value) [instance] :58
void ItemsWindowList::SetItemsDerivedRooting(uObject* value)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "SetItemsDerivedRooting(object)");
    _items = value;
    ItemsChanged();
}

// private bool TryUpdateAt(int dataIndex, object newData) [instance] :220
bool ItemsWindowList::TryUpdateAt(int32_t dataIndex, uObject* newData)
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "TryUpdateAt(int,object)");

    if (Identity == 0)
        return false;

    int32_t windowIndex = DataToWindowIndex(dataIndex);

    if ((windowIndex < 0) || (windowIndex >= WindowItemCount()))
        return false;

    ::g::Fuse::Reactive::WindowListItem* wi = (::g::Fuse::Reactive::WindowListItem*)GetWindowItem(windowIndex);
    uObject* newId = GetDataId(newData);

    if ((uPtr(wi)->Id() == NULL) || !::g::Uno::Object::Equals1(uPtr(wi)->Id(), newId))
        return false;

    uPtr(wi)->Data(newData);
    return true;
}

// public void Unrooted() [instance] :103
void ItemsWindowList::Unrooted()
{
    uStackFrame __("Fuse.Reactive.ItemsWindowList`1", "Unrooted()");
    RemoveAll();
    DisposeItemsSubscription();
    _isRooted = false;
}

// public ItemsWindowList New(Fuse.Reactive.ItemsWindowList<T>.IListener listener) [static] :29
ItemsWindowList* ItemsWindowList::New1(uType* __type, uObject* listener)
{
    ItemsWindowList* obj1 = (ItemsWindowList*)uNew(__type);
    obj1->ctor_1(listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\ValueObserver.uno
// -----------------------------------------------------------------------------------------

// public abstract interface ValueForwarder.IValueListener :108
// {
uInterfaceType* ValueForwarder__IValueListener_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.ValueForwarder.IValueListener", 0, 0);
    type->Reflection.SetFunctions(2,
        new uFunction("LostValue", NULL, NULL, offsetof(ValueForwarder__IValueListener, fp_LostValue), false, uVoid_typeof(), 0),
        new uFunction("NewValue", NULL, NULL, offsetof(ValueForwarder__IValueListener, fp_NewValue), false, uVoid_typeof(), 1, uObject_typeof()));
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\IExpression.uno
// ---------------------------------------------------------------------------------------

// public abstract interface IWriteable :37
// {
uInterfaceType* IWriteable_typeof()
{
    static uSStrong<uInterfaceType*> type;
    if (type != NULL) return type;

    type = uInterfaceType::New("Fuse.Reactive.IWriteable", 0, 0);
    type->Reflection.SetFunctions(1,
        new uFunction("TrySetExclusive", NULL, NULL, offsetof(IWriteable, fp_TrySetExclusive), false, ::g::Uno::Bool_typeof(), 1, uObject_typeof()));
    return type;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Scripting.JavaScript\1.8.1\JavaScript.Dependencies.uno
// ---------------------------------------------------------------------------------------------------------------

// public partial class JavaScript :10
// {
static void JavaScript_build(uType* type)
{
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(JavaScript_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(JavaScript_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(JavaScript_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(JavaScript_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(JavaScript_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(JavaScript_type, interface5),
        ::g::Fuse::Scripting::IModuleProvider_typeof(), offsetof(JavaScript_type, interface6),
        ::g::Fuse::Reactive::ValueForwarder__IValueListener_typeof(), offsetof(JavaScript_type, interface7),
        ::g::Fuse::Node__ISiblingDataProvider_typeof(), offsetof(JavaScript_type, interface8),
        ::g::Fuse::Reactive::IContext_typeof(), offsetof(JavaScript_type, interface9));
    type->SetFields(16,
        ::g::Uno::Collections::List_typeof()->MakeType(JavaScript__Dependency_typeof(), NULL), offsetof(JavaScript, _dependencies), 0,
        ::g::Fuse::Scripting::JavaScript::ModuleInstance_typeof(), offsetof(JavaScript, _moduleInstance), 0,
        ::g::Uno::Bool_typeof(), offsetof(JavaScript, _preserveModuleInstance), 0,
        ::g::Uno::UX::NameTable_typeof(), offsetof(JavaScript, _nameTable), 0,
        ::g::Fuse::Scripting::JavaScript::RootableScriptModule_typeof(), offsetof(JavaScript, _scriptModule), 0,
        uObject_typeof(), offsetof(JavaScript, _currentDc), 0,
        ::g::Uno::IDisposable_typeof(), offsetof(JavaScript, _sub), 0,
        uObject_typeof(), offsetof(JavaScript, _siblingData), 0,
        ::g::Uno::Int_typeof(), (uintptr_t)&JavaScript::_javaScriptCounter_, uFieldFlagsStatic,
        ::g::Fuse::Scripting::JavaScript::ThreadWorker_typeof(), (uintptr_t)&JavaScript::Worker_, uFieldFlagsStatic);
    type->Reflection.SetFunctions(12,
        new uFunction("get_Code", NULL, (void*)JavaScript__get_Code_fn, 0, false, ::g::Uno::String_typeof(), 0),
        new uFunction("set_Code", NULL, (void*)JavaScript__set_Code_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::String_typeof()),
        new uFunction("get_Dependencies", NULL, (void*)JavaScript__get_Dependencies_fn, 0, false, ::g::Uno::Collections::IList_typeof()->MakeType(JavaScript__Dependency_typeof(), NULL), 0),
        new uFunction("get_File", NULL, (void*)JavaScript__get_File_fn, 0, false, ::g::Uno::UX::FileSource_typeof(), 0),
        new uFunction("set_File", NULL, (void*)JavaScript__set_File_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::UX::FileSource_typeof()),
        new uFunction("get_FileName", NULL, (void*)JavaScript__get_FileName_fn, 0, false, ::g::Uno::String_typeof(), 0),
        new uFunction("set_FileName", NULL, (void*)JavaScript__set_FileName_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::String_typeof()),
        new uFunction("get_LineNumber", NULL, (void*)JavaScript__get_LineNumber_fn, 0, false, ::g::Uno::Int_typeof(), 0),
        new uFunction("set_LineNumber", NULL, (void*)JavaScript__set_LineNumber_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::Int_typeof()),
        new uFunction("get_Names", NULL, (void*)JavaScript__get_Names_fn, 0, false, ::g::Fuse::Scripting::JavaScript::ScriptModuleNames_typeof(), 0),
        new uFunction("set_Names", NULL, (void*)JavaScript__set_Names_fn, 0, false, uVoid_typeof(), 1, ::g::Fuse::Scripting::JavaScript::ScriptModuleNames_typeof()),
        new uFunction(".ctor", NULL, (void*)JavaScript__New2_fn, 0, true, type, 1, ::g::Uno::UX::NameTable_typeof()));
}

JavaScript_type* JavaScript_typeof()
{
    static uSStrong<JavaScript_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Behavior_typeof();
    options.FieldCount = 26;
    options.InterfaceCount = 10;
    options.ObjectSize = sizeof(JavaScript);
    options.TypeSize = sizeof(JavaScript_type);
    type = (JavaScript_type*)uClassType::New("Fuse.Reactive.JavaScript", options);
    type->fp_build_ = JavaScript_build;
    type->fp_OnBeforeSubscribeToDependenciesAndDispatchEvaluate = JavaScript__OnBeforeSubscribeToDependenciesAndDispatchEvaluate_fn;
    type->fp_OnRooted = (void(*)(::g::Fuse::Node*))JavaScript__OnRooted_fn;
    type->fp_OnUnrooted = (void(*)(::g::Fuse::Node*))JavaScript__OnUnrooted_fn;
    type->interface9.fp_Subscribe = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))JavaScript__FuseReactiveIContextSubscribe_fn;
    type->interface9.fp_SubscribeResource = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))JavaScript__FuseReactiveIContextSubscribeResource_fn;
    type->interface6.fp_GetModule = (void(*)(uObject*, ::g::Fuse::Scripting::Module**))JavaScript__FuseScriptingIModuleProviderGetModule_fn;
    type->interface7.fp_NewValue = (void(*)(uObject*, uObject*))JavaScript__FuseReactiveValueForwarderIValueListenerNewValue_fn;
    type->interface7.fp_LostValue = (void(*)(uObject*))JavaScript__FuseReactiveValueForwarderIValueListenerLostValue_fn;
    type->interface8.fp_TryGetDataProvider = (void(*)(uObject*, int32_t*, uObject**, int32_t*))JavaScript__FuseNodeISiblingDataProviderTryGetDataProvider_fn;
    type->interface9.fp_get_Node = (void(*)(uObject*, ::g::Fuse::Node**))JavaScript__FuseReactiveIContextget_Node_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public JavaScript(Uno.UX.NameTable nameTable) :39
void JavaScript__ctor_3_fn(JavaScript* __this, ::g::Uno::UX::NameTable* nameTable)
{
    __this->ctor_3(nameTable);
}

// public string get_Code() :149
void JavaScript__get_Code_fn(JavaScript* __this, uString** __retval)
{
    *__retval = __this->Code();
}

// public void set_Code(string value) :150
void JavaScript__set_Code_fn(JavaScript* __this, uString* value)
{
    __this->Code(value);
}

// public Uno.Collections.IList<Fuse.Reactive.JavaScript.Dependency> get_Dependencies() :88
void JavaScript__get_Dependencies_fn(JavaScript* __this, uObject** __retval)
{
    *__retval = __this->Dependencies();
}

// internal void DispatchEvaluate() :129
void JavaScript__DispatchEvaluate_fn(JavaScript* __this)
{
    __this->DispatchEvaluate();
}

// private void DispatchEvaluateIfDependenciesReady() :113
void JavaScript__DispatchEvaluateIfDependenciesReady_fn(JavaScript* __this)
{
    __this->DispatchEvaluateIfDependenciesReady();
}

// private void DisposeDependencySubscriptions() :106
void JavaScript__DisposeDependencySubscriptions_fn(JavaScript* __this)
{
    __this->DisposeDependencySubscriptions();
}

// protected void DisposeModuleInstance() :137
void JavaScript__DisposeModuleInstance_fn(JavaScript* __this)
{
    __this->DisposeModuleInstance();
}

// private void DisposeSubscription() :136
void JavaScript__DisposeSubscription_fn(JavaScript* __this)
{
    __this->DisposeSubscription();
}

// internal static void EnsureVMStarted() :32
void JavaScript__EnsureVMStarted_fn()
{
    JavaScript::EnsureVMStarted();
}

// public Uno.UX.FileSource get_File() :170
void JavaScript__get_File_fn(JavaScript* __this, ::g::Uno::UX::FileSource** __retval)
{
    *__retval = __this->File();
}

// public void set_File(Uno.UX.FileSource value) :171
void JavaScript__set_File_fn(JavaScript* __this, ::g::Uno::UX::FileSource* value)
{
    __this->File(value);
}

// public string get_FileName() :178
void JavaScript__get_FileName_fn(JavaScript* __this, uString** __retval)
{
    *__retval = __this->FileName();
}

// public void set_FileName(string value) :179
void JavaScript__set_FileName_fn(JavaScript* __this, uString* value)
{
    __this->FileName(value);
}

// private Fuse.Node.ContextDataResult Fuse.Node.ISiblingDataProvider.TryGetDataProvider(Fuse.Node.DataType type, object& provider) :130
void JavaScript__FuseNodeISiblingDataProviderTryGetDataProvider_fn(JavaScript* __this, int32_t* type, uObject** provider, int32_t* __retval)
{
    int32_t type_ = *type;
    *provider = (type_ == 0) ? (uObject*)__this->_siblingData : NULL;
    return *__retval = 0, void();
}

// private Fuse.Node Fuse.Reactive.IContext.get_Node() :154
void JavaScript__FuseReactiveIContextget_Node_fn(JavaScript* __this, ::g::Fuse::Node** __retval)
{
    return *__retval = __this, void();
}

// private Uno.IDisposable Fuse.Reactive.IContext.Subscribe(Fuse.Reactive.IExpression source, string key, Fuse.Reactive.IListener listener) :149
void JavaScript__FuseReactiveIContextSubscribe_fn(JavaScript* __this, uObject* source, uString* key, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "Fuse.Reactive.IContext.Subscribe(Fuse.Reactive.IExpression,string,Fuse.Reactive.IListener)");
    return *__retval = (uObject*)::g::Fuse::Reactive::DataSubscription::New1(source, __this, key, listener), void();
}

// private Uno.IDisposable Fuse.Reactive.IContext.SubscribeResource(Fuse.Reactive.IExpression source, string key, Fuse.Reactive.IListener listener) :156
void JavaScript__FuseReactiveIContextSubscribeResource_fn(JavaScript* __this, uObject* source, uString* key, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "Fuse.Reactive.IContext.SubscribeResource(Fuse.Reactive.IExpression,string,Fuse.Reactive.IListener)");
    return *__retval = (uObject*)::g::Fuse::Reactive::ResourceSubscription::New1(source, __this, key, listener, uObject_typeof()), void();
}

// private void Fuse.Reactive.ValueForwarder.IValueListener.LostValue() :117
void JavaScript__FuseReactiveValueForwarderIValueListenerLostValue_fn(JavaScript* __this)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "Fuse.Reactive.ValueForwarder.IValueListener.LostValue()");
    __this->SetSiblingData(NULL);
}

// private void Fuse.Reactive.ValueForwarder.IValueListener.NewValue(object data) :112
void JavaScript__FuseReactiveValueForwarderIValueListenerNewValue_fn(JavaScript* __this, uObject* data)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "Fuse.Reactive.ValueForwarder.IValueListener.NewValue(object)");
    __this->SetSiblingData(data);
}

// private Fuse.Scripting.Module Fuse.Scripting.IModuleProvider.GetModule() :82
void JavaScript__FuseScriptingIModuleProviderGetModule_fn(JavaScript* __this, ::g::Fuse::Scripting::Module** __retval)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "Fuse.Scripting.IModuleProvider.GetModule()");

    if (__this->IsRootingCompleted())
        U_THROW(::g::Uno::Exception::New2(uString::Const("Cannot require() a rooted module")));

    return *__retval = __this->_scriptModule, void();
}

// public int get_LineNumber() :163
void JavaScript__get_LineNumber_fn(JavaScript* __this, int32_t* __retval)
{
    *__retval = __this->LineNumber();
}

// public void set_LineNumber(int value) :164
void JavaScript__set_LineNumber_fn(JavaScript* __this, int32_t* value)
{
    __this->LineNumber(*value);
}

// public Fuse.Scripting.JavaScript.ScriptModuleNames get_Names() :189
void JavaScript__get_Names_fn(JavaScript* __this, int32_t* __retval)
{
    *__retval = __this->Names();
}

// public void set_Names(Fuse.Scripting.JavaScript.ScriptModuleNames value) :190
void JavaScript__set_Names_fn(JavaScript* __this, int32_t* value)
{
    __this->Names(*value);
}

// public JavaScript New(Uno.UX.NameTable nameTable) :39
void JavaScript__New2_fn(::g::Uno::UX::NameTable* nameTable, JavaScript** __retval)
{
    *__retval = JavaScript::New2(nameTable);
}

// protected virtual void OnBeforeSubscribeToDependenciesAndDispatchEvaluate() :46
void JavaScript__OnBeforeSubscribeToDependenciesAndDispatchEvaluate_fn(JavaScript* __this)
{
}

// protected override sealed void OnRooted() :48
void JavaScript__OnRooted_fn(JavaScript* __this)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "OnRooted()");
    ::g::Fuse::Node__OnRooted_fn(__this);
    JavaScript::_javaScriptCounter_++;
    __this->OnBeforeSubscribeToDependenciesAndDispatchEvaluate();

    if ((__this->_moduleInstance == NULL) || !uPtr(__this->_moduleInstance)->ReflectExports())
        __this->SubscribeToDependenciesAndDispatchEvaluate();

    __this->_preserveModuleInstance = false;
}

// protected override sealed void OnUnrooted() :63
void JavaScript__OnUnrooted_fn(JavaScript* __this)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "OnUnrooted()");
    ::g::Fuse::Scripting::NativeModule* ret5;
    __this->DisposeDependencySubscriptions();
    __this->SetDataContext(NULL);
    __this->DisposeModuleInstance();

    if ((--JavaScript::_javaScriptCounter_) <= 0)
    {
        ::g::Fuse::Scripting::AppInitialized::Reset();
        uObject* enum1 = (uObject*)::g::Uno::Collections::IEnumerable::GetEnumerator(uInterface(uPtr((uObject*)::g::Uno::UX::Resource::GetGlobalsOfType(::g::Uno::UX::Resource_typeof()->MakeMethod(0/*GetGlobalsOfType<Fuse.Scripting.NativeModule>*/, ::g::Fuse::Scripting::NativeModule_typeof(), NULL))), ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Scripting::NativeModule_typeof(), NULL)));

        {
            try
            {
                {
                    while (::g::Uno::Collections::IEnumerator::MoveNext(uInterface(uPtr(enum1), ::TYPES[53/*Uno.Collections.IEnumerator*/])))
                    {
                        ::g::Fuse::Scripting::NativeModule* nm = (::g::Uno::Collections::IEnumerator1::get_Current_ex(uInterface(uPtr(enum1), ::g::Uno::Collections::IEnumerator1_typeof()->MakeType(::g::Fuse::Scripting::NativeModule_typeof(), NULL)), &ret5), ret5);
                        uPtr(nm)->InternalReset();
                    }
                }
            }

            catch (const uThrowable& __t)
            {
                {
                    ::g::Uno::IDisposable::Dispose(uInterface(uPtr(enum1), ::TYPES[3/*Uno.IDisposable*/]));
                }
                                throw __t;
                goto __after_finally_2;
            }

            {
                ::g::Uno::IDisposable::Dispose(uInterface(uPtr(enum1), ::TYPES[3/*Uno.IDisposable*/]));
            }
            __after_finally_2:;
        }
    }

    ::g::Fuse::Node__OnUnrooted_fn(__this);
}

// internal Fuse.Scripting.JavaScript.RootableScriptModule get_ScriptModule() :29
void JavaScript__get_ScriptModule_fn(JavaScript* __this, ::g::Fuse::Scripting::JavaScript::RootableScriptModule** __retval)
{
    *__retval = __this->ScriptModule();
}

// internal void SetDataContext(object newDc) :91
void JavaScript__SetDataContext_fn(JavaScript* __this, uObject* newDc)
{
    __this->SetDataContext(newDc);
}

// private void SetSiblingData(object data) :123
void JavaScript__SetSiblingData_fn(JavaScript* __this, uObject* data)
{
    __this->SetSiblingData(data);
}

// private void SubscribeToDependenciesAndDispatchEvaluate() :97
void JavaScript__SubscribeToDependenciesAndDispatchEvaluate_fn(JavaScript* __this)
{
    __this->SubscribeToDependenciesAndDispatchEvaluate();
}

int32_t JavaScript::_javaScriptCounter_;
uSStrong< ::g::Fuse::Scripting::JavaScript::ThreadWorker*> JavaScript::Worker_;

// public JavaScript(Uno.UX.NameTable nameTable) [instance] :39
void JavaScript::ctor_3(::g::Uno::UX::NameTable* nameTable)
{
    ctor_2();
    JavaScript::EnsureVMStarted();
    _nameTable = nameTable;
    _scriptModule = ::g::Fuse::Scripting::JavaScript::RootableScriptModule::New2(JavaScript::Worker_, nameTable);
}

// public string get_Code() [instance] :149
uString* JavaScript::Code()
{
    uStackFrame __("Fuse.Reactive.JavaScript", "get_Code()");
    return uPtr(_scriptModule)->Code();
}

// public void set_Code(string value) [instance] :150
void JavaScript::Code(uString* value)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "set_Code(string)");

    if (::g::Uno::String::op_Inequality(uPtr(_scriptModule)->Code(), value))
        uPtr(_scriptModule)->Code(value);
}

// public Uno.Collections.IList<Fuse.Reactive.JavaScript.Dependency> get_Dependencies() [instance] :88
uObject* JavaScript::Dependencies()
{
    uStackFrame __("Fuse.Reactive.JavaScript", "get_Dependencies()");

    if (_dependencies == NULL)
        _dependencies = ((::g::Uno::Collections::List*)::g::Uno::Collections::List::New1(::TYPES[60/*Uno.Collections.List`1*/]->MakeType(JavaScript__Dependency_typeof(), NULL)));

    return (uObject*)_dependencies;
}

// internal void DispatchEvaluate() [instance] :129
void JavaScript::DispatchEvaluate()
{
    uStackFrame __("Fuse.Reactive.JavaScript", "DispatchEvaluate()");

    if (!IsRootingStarted())
        return;

    DisposeModuleInstance();
    _moduleInstance = ::g::Fuse::Scripting::JavaScript::ModuleInstance::New2((uObject*)JavaScript::Worker_, this);
}

// private void DispatchEvaluateIfDependenciesReady() [instance] :113
void JavaScript::DispatchEvaluateIfDependenciesReady()
{
    uStackFrame __("Fuse.Reactive.JavaScript", "DispatchEvaluateIfDependenciesReady()");
    JavaScript__Dependency* ret3;

    if (_dependencies != NULL)

        for (int32_t i = 0; i < uPtr(_dependencies)->Count(); i++)
            if (!uPtr((::g::Uno::Collections::List__get_Item_fn(uPtr(_dependencies), uCRef<int32_t>(i), &ret3), ret3))->HasValue)
                return;

    DispatchEvaluate();
}

// private void DisposeDependencySubscriptions() [instance] :106
void JavaScript::DisposeDependencySubscriptions()
{
    uStackFrame __("Fuse.Reactive.JavaScript", "DisposeDependencySubscriptions()");
    JavaScript__Dependency* ret4;

    if (_dependencies != NULL)

        for (int32_t i = 0; i < uPtr(_dependencies)->Count(); i++)
            uPtr((::g::Uno::Collections::List__get_Item_fn(uPtr(_dependencies), uCRef<int32_t>(i), &ret4), ret4))->Unsubscribe();
}

// protected void DisposeModuleInstance() [instance] :137
void JavaScript::DisposeModuleInstance()
{
    uStackFrame __("Fuse.Reactive.JavaScript", "DisposeModuleInstance()");

    if (_preserveModuleInstance)
        return;

    if (_moduleInstance != NULL)
    {
        uPtr(_moduleInstance)->Dispose();
        _moduleInstance = NULL;
    }
}

// private void DisposeSubscription() [instance] :136
void JavaScript::DisposeSubscription()
{
    uStackFrame __("Fuse.Reactive.JavaScript", "DisposeSubscription()");

    if (_sub != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_sub), ::TYPES[3/*Uno.IDisposable*/]));
        _sub = NULL;
    }
}

// public Uno.UX.FileSource get_File() [instance] :170
::g::Uno::UX::FileSource* JavaScript::File()
{
    uStackFrame __("Fuse.Reactive.JavaScript", "get_File()");
    return uPtr(_scriptModule)->File();
}

// public void set_File(Uno.UX.FileSource value) [instance] :171
void JavaScript::File(::g::Uno::UX::FileSource* value)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "set_File(Uno.UX.FileSource)");
    uPtr(_scriptModule)->File(value);
}

// public string get_FileName() [instance] :178
uString* JavaScript::FileName()
{
    uStackFrame __("Fuse.Reactive.JavaScript", "get_FileName()");
    return uPtr(_scriptModule)->FileName();
}

// public void set_FileName(string value) [instance] :179
void JavaScript::FileName(uString* value)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "set_FileName(string)");
    uPtr(_scriptModule)->FileName(value);
}

// public int get_LineNumber() [instance] :163
int32_t JavaScript::LineNumber()
{
    uStackFrame __("Fuse.Reactive.JavaScript", "get_LineNumber()");
    return uPtr(_scriptModule)->LineNumberOffset();
}

// public void set_LineNumber(int value) [instance] :164
void JavaScript::LineNumber(int32_t value)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "set_LineNumber(int)");
    uPtr(_scriptModule)->LineNumberOffset(value);
}

// public Fuse.Scripting.JavaScript.ScriptModuleNames get_Names() [instance] :189
int32_t JavaScript::Names()
{
    uStackFrame __("Fuse.Reactive.JavaScript", "get_Names()");
    return uPtr(_scriptModule)->ModuleNames();
}

// public void set_Names(Fuse.Scripting.JavaScript.ScriptModuleNames value) [instance] :190
void JavaScript::Names(int32_t value)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "set_Names(Fuse.Scripting.JavaScript.ScriptModuleNames)");
    uPtr(_scriptModule)->ModuleNames(value);
}

// internal Fuse.Scripting.JavaScript.RootableScriptModule get_ScriptModule() [instance] :29
::g::Fuse::Scripting::JavaScript::RootableScriptModule* JavaScript::ScriptModule()
{
    return _scriptModule;
}

// internal void SetDataContext(object newDc) [instance] :91
void JavaScript::SetDataContext(uObject* newDc)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "SetDataContext(object)");
    DisposeSubscription();
    uObject* oldDc = _currentDc;
    _currentDc = newDc;
    uObject* obs = uAs<uObject*>(newDc, ::TYPES[46/*Fuse.Reactive.IObservable*/]);

    if (obs != NULL)
    {
        SetSiblingData(NULL);
        _sub = (uObject*)::g::Fuse::Reactive::ValueForwarder::New1(obs, (uObject*)this);
    }
    else
        SetSiblingData(newDc);

    if (oldDc != NULL)
        ::g::Fuse::Scripting::ValueMirror::Unsubscribe1(oldDc);
}

// private void SetSiblingData(object data) [instance] :123
void JavaScript::SetSiblingData(uObject* data)
{
    uStackFrame __("Fuse.Reactive.JavaScript", "SetSiblingData(object)");
    uObject* oldSiblingData = _siblingData;
    _siblingData = data;

    if (Parent() != NULL)
        uPtr(Parent())->BroadcastDataChange(oldSiblingData, data);
}

// private void SubscribeToDependenciesAndDispatchEvaluate() [instance] :97
void JavaScript::SubscribeToDependenciesAndDispatchEvaluate()
{
    uStackFrame __("Fuse.Reactive.JavaScript", "SubscribeToDependenciesAndDispatchEvaluate()");
    JavaScript__Dependency* ret6;

    if (_dependencies != NULL)

        for (int32_t i = 0; i < uPtr(_dependencies)->Count(); i++)
            uPtr((::g::Uno::Collections::List__get_Item_fn(uPtr(_dependencies), uCRef<int32_t>(i), &ret6), ret6))->Subscribe(this);

    if ((_dependencies == NULL) || (uPtr(_dependencies)->Count() == 0))
        DispatchEvaluateIfDependenciesReady();
}

// internal static void EnsureVMStarted() [static] :32
void JavaScript::EnsureVMStarted()
{
    uStackFrame __("Fuse.Reactive.JavaScript", "EnsureVMStarted()");

    if (JavaScript::Worker_ == NULL)
        JavaScript::Worker_ = ::g::Fuse::Scripting::JavaScript::ThreadWorker::New1();
}

// public JavaScript New(Uno.UX.NameTable nameTable) [static] :39
JavaScript* JavaScript::New2(::g::Uno::UX::NameTable* nameTable)
{
    JavaScript* obj2 = (JavaScript*)uNew(JavaScript_typeof());
    obj2->ctor_3(nameTable);
    return obj2;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Lerp :423
// {
static void Lerp_build(uType* type)
{
    ::STRINGS[88] = uString::Const("lerp(");
    ::STRINGS[17] = uString::Const(",");
    ::STRINGS[6] = uString::Const(")");
    ::TYPES[2] = ::g::Fuse::Marshal_typeof()->MakeMethod(1/*TryToType<float>*/, ::g::Uno::Float_typeof(), NULL);
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::TernaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Lerp__New1_fn, 0, true, type, 3, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::TernaryOperator_type* Lerp_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::TernaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::TernaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(Lerp);
    options.TypeSize = sizeof(::g::Fuse::Reactive::TernaryOperator_type);
    type = (::g::Fuse::Reactive::TernaryOperator_type*)uClassType::New("Fuse.Reactive.Lerp", options);
    type->fp_build_ = Lerp_build;
    type->fp_ToString = (void(*)(uObject*, uString**))Lerp__ToString_fn;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::TernaryOperator*, uObject*, uObject*, uObject*, uObject**, bool*))Lerp__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Lerp(Fuse.Reactive.Expression first, Fuse.Reactive.Expression second, Fuse.Reactive.Expression third) :426
void Lerp__ctor_3_fn(Lerp* __this, ::g::Fuse::Reactive::Expression* first, ::g::Fuse::Reactive::Expression* second, ::g::Fuse::Reactive::Expression* third)
{
    __this->ctor_3(first, second, third);
}

// public Lerp New(Fuse.Reactive.Expression first, Fuse.Reactive.Expression second, Fuse.Reactive.Expression third) :426
void Lerp__New1_fn(::g::Fuse::Reactive::Expression* first, ::g::Fuse::Reactive::Expression* second, ::g::Fuse::Reactive::Expression* third, Lerp** __retval)
{
    *__retval = Lerp::New1(first, second, third);
}

// public override sealed string ToString() :461
void Lerp__ToString_fn(Lerp* __this, uString** __retval)
{
    uStackFrame __("Fuse.Reactive.Lerp", "ToString()");
    return *__retval = ::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition1(::STRINGS[88/*"lerp("*/], __this->First()), ::STRINGS[17/*","*/]), __this->Second()), ::STRINGS[17/*","*/]), __this->Third()), ::STRINGS[6/*")"*/]), void();
}

// protected override sealed bool TryCompute(object a, object b, object t, object& result) :431
void Lerp__TryCompute1_fn(Lerp* __this, uObject* a, uObject* b, uObject* t, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.Lerp", "TryCompute(object,object,object,object&)");
    bool ret2;
    *result = NULL;
    ::g::Uno::Float4 av = ::g::Uno::Float4__New1(0.0f), bv = ::g::Uno::Float4__New1(0.0f);
    int32_t asize = 0, bsize = 0;
    float tv = 0.0f;

    if ((!::g::Fuse::Marshal::TryToZeroFloat4(a, &av, &asize) || !::g::Fuse::Marshal::TryToZeroFloat4(b, &bv, &bsize)) || !(::g::Fuse::Marshal__TryToType_fn(::TYPES[2/*Fuse.Marshal.TryToType<float>*/], t, &tv, &ret2), ret2))
        return *__retval = false, void();

    int32_t size = ::g::Uno::Math::Max8(asize, bsize);

    switch (size)
    {
        case 1:
        {
            *result = uBox(::TYPES[21/*float*/], ::g::Uno::Math::Lerp1(av.X, bv.X, tv));
            return *__retval = true, void();
        }
        case 2:
        {
            *result = uBox(::g::Uno::Float2_typeof(), ::g::Uno::Math::Lerp2(::g::Uno::Float2__New2(av.X, av.Y), ::g::Uno::Float2__New2(bv.X, bv.Y), tv));
            return *__retval = true, void();
        }
        case 3:
        {
            *result = uBox(::g::Uno::Float3_typeof(), ::g::Uno::Math::Lerp4(::g::Uno::Float3__New2(av.X, av.Y, av.Z), ::g::Uno::Float3__New2(bv.X, bv.Y, bv.Z), tv));
            return *__retval = true, void();
        }
        case 4:
        {
            *result = uBox(::g::Uno::Float4_typeof(), ::g::Uno::Math::Lerp6(av, bv, tv));
            return *__retval = true, void();
        }
    }

    return *__retval = false, void();
}

// public Lerp(Fuse.Reactive.Expression first, Fuse.Reactive.Expression second, Fuse.Reactive.Expression third) [instance] :426
void Lerp::ctor_3(::g::Fuse::Reactive::Expression* first, ::g::Fuse::Reactive::Expression* second, ::g::Fuse::Reactive::Expression* third)
{
    ctor_2(first, second, third, 0);
}

// public Lerp New(Fuse.Reactive.Expression first, Fuse.Reactive.Expression second, Fuse.Reactive.Expression third) [static] :426
Lerp* Lerp::New1(::g::Fuse::Reactive::Expression* first, ::g::Fuse::Reactive::Expression* second, ::g::Fuse::Reactive::Expression* third)
{
    Lerp* obj1 = (Lerp*)uNew(Lerp_typeof());
    obj1->ctor_3(first, second, third);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class LessOrEqual :160
// {
static void LessOrEqual_build(uType* type)
{
    ::STRINGS[89] = uString::Const("<=");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)LessOrEqual__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* LessOrEqual_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InfixOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(LessOrEqual);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.LessOrEqual", options);
    type->fp_build_ = LessOrEqual_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))LessOrEqual__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public LessOrEqual(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :163
void LessOrEqual__ctor_6_fn(LessOrEqual* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_6(left, right);
}

// public LessOrEqual New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :163
void LessOrEqual__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, LessOrEqual** __retval)
{
    *__retval = LessOrEqual::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :165
void LessOrEqual__TryCompute1_fn(LessOrEqual* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    bool v = false;
    bool r = ::g::Fuse::Marshal::TryLessOrEqual(left, right, &v);
    *result = uBox(::TYPES[12/*bool*/], v);
    return *__retval = r, void();
}

// public LessOrEqual(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :163
void LessOrEqual::ctor_6(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    uStackFrame __("Fuse.Reactive.LessOrEqual", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression)");
    ctor_5(left, right, ::STRINGS[89/*"<="*/], 0);
}

// public LessOrEqual New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :163
LessOrEqual* LessOrEqual::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    LessOrEqual* obj1 = (LessOrEqual*)uNew(LessOrEqual_typeof());
    obj1->ctor_6(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class LessThan :118
// {
static void LessThan_build(uType* type)
{
    ::STRINGS[90] = uString::Const("<");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)LessThan__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* LessThan_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InfixOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(LessThan);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.LessThan", options);
    type->fp_build_ = LessThan_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))LessThan__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public LessThan(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :121
void LessThan__ctor_6_fn(LessThan* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_6(left, right);
}

// public LessThan New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :121
void LessThan__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, LessThan** __retval)
{
    *__retval = LessThan::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :123
void LessThan__TryCompute1_fn(LessThan* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    bool v = false;
    bool r = ::g::Fuse::Marshal::TryLessThan(left, right, &v);
    *result = uBox(::TYPES[12/*bool*/], v);
    return *__retval = r, void();
}

// public LessThan(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :121
void LessThan::ctor_6(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    uStackFrame __("Fuse.Reactive.LessThan", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression)");
    ctor_5(left, right, ::STRINGS[90/*"<"*/], 0);
}

// public LessThan New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :121
LessThan* LessThan::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    LessThan* obj1 = (LessThan*)uNew(LessThan_typeof());
    obj1->ctor_6(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Let.uno
// ----------------------------------------------------------------------------------------

// public sealed class Let :261
// {
static void Let_build(uType* type)
{
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(Let_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(Let_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(Let_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(Let_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(Let_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(Let_type, interface5),
        ::g::Fuse::Node__ISiblingDataProvider_typeof(), offsetof(Let_type, interface6),
        ::g::Fuse::IObject_typeof(), offsetof(Let_type, interface7),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(Let_type, interface8),
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(Let_type, interface9));
    type->SetFields(20,
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(Let, _expr), 0,
        ::g::Fuse::Reactive::NodeExpressionBinding_typeof(), offsetof(Let, _exprSub), 0);
    type->Reflection.SetFunctions(6,
        new uFunction("get_Expression", NULL, (void*)Let__get_Expression_fn, 0, false, ::g::Fuse::Reactive::IExpression_typeof(), 0),
        new uFunction("set_Expression", NULL, (void*)Let__set_Expression_fn, 0, false, uVoid_typeof(), 1, ::g::Fuse::Reactive::IExpression_typeof()),
        new uFunction(".ctor", NULL, (void*)Let__New2_fn, 0, true, type, 0),
        new uFunction("SetValue", NULL, (void*)Let__SetValue_fn, 0, false, uVoid_typeof(), 2, uObject_typeof(), ::g::Uno::UX::IPropertyListener_typeof()),
        new uFunction("get_Value", NULL, (void*)Let__get_Value_fn, 0, false, uObject_typeof(), 0),
        new uFunction("set_Value", NULL, (void*)Let__set_Value_fn, 0, false, uVoid_typeof(), 1, uObject_typeof()));
}

Let_type* Let_typeof()
{
    static uSStrong<Let_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::LetBase_typeof();
    options.FieldCount = 22;
    options.InterfaceCount = 10;
    options.ObjectSize = sizeof(Let);
    options.TypeSize = sizeof(Let_type);
    type = (Let_type*)uClassType::New("Fuse.Reactive.Let", options);
    type->fp_build_ = Let_build;
    type->fp_ctor_ = (void*)Let__New2_fn;
    type->fp_OnRootedValue = (void(*)(::g::Fuse::Reactive::LetBase*))Let__OnRootedValue_fn;
    type->fp_OnUnrooted = (void(*)(::g::Fuse::Node*))Let__OnUnrooted_fn;
    type->interface9.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))Let__FuseReactiveIListenerOnNewData_fn;
    type->interface9.fp_OnLostData = (void(*)(uObject*, uObject*))Let__FuseReactiveIListenerOnLostData_fn;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, int32_t*, uObject**, int32_t*))::g::Fuse::Reactive::LetBase__FuseNodeISiblingDataProviderTryGetDataProvider_fn;
    type->interface7.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))::g::Fuse::Reactive::LetBase__FuseIObjectContainsKey_fn;
    type->interface8.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::LetBase__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface7.fp_get_Item = (void(*)(uObject*, uString*, uObject**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Item_fn;
    type->interface7.fp_get_Keys = (void(*)(uObject*, uArray**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Keys_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public generated Let() :261
void Let__ctor_4_fn(Let* __this)
{
    __this->ctor_4();
}

// private void CleanupExpression() :299
void Let__CleanupExpression_fn(Let* __this)
{
    __this->CleanupExpression();
}

// public Fuse.Reactive.IExpression get_Expression() :266
void Let__get_Expression_fn(Let* __this, uObject** __retval)
{
    *__retval = __this->Expression();
}

// public void set_Expression(Fuse.Reactive.IExpression value) :267
void Let__set_Expression_fn(Let* __this, uObject* value)
{
    __this->Expression(value);
}

// private void Fuse.Reactive.IListener.OnLostData(Fuse.Reactive.IExpression source) :322
void Let__FuseReactiveIListenerOnLostData_fn(Let* __this, uObject* source)
{
    uStackFrame __("Fuse.Reactive.Let", "Fuse.Reactive.IListener.OnLostData(Fuse.Reactive.IExpression)");
    __this->ResetObjectValue();
}

// private void Fuse.Reactive.IListener.OnNewData(Fuse.Reactive.IExpression source, object value) :317
void Let__FuseReactiveIListenerOnNewData_fn(Let* __this, uObject* source, uObject* value)
{
    uStackFrame __("Fuse.Reactive.Let", "Fuse.Reactive.IListener.OnNewData(Fuse.Reactive.IExpression,object)");
    __this->SetObjectValue(value, (uObject*)__this);
}

// public generated Let New() :261
void Let__New2_fn(Let** __retval)
{
    *__retval = Let::New2();
}

// protected override sealed void OnRootedValue() :288
void Let__OnRootedValue_fn(Let* __this)
{
    uStackFrame __("Fuse.Reactive.Let", "OnRootedValue()");
    __this->SubscribeExpression();
}

// protected override sealed void OnUnrooted() :293
void Let__OnUnrooted_fn(Let* __this)
{
    uStackFrame __("Fuse.Reactive.Let", "OnUnrooted()");
    __this->CleanupExpression();
}

// public void SetValue(object value, Uno.UX.IPropertyListener origin) :283
void Let__SetValue_fn(Let* __this, uObject* value, uObject* origin)
{
    __this->SetValue(value, origin);
}

// private void SubscribeExpression() :308
void Let__SubscribeExpression_fn(Let* __this)
{
    __this->SubscribeExpression();
}

// public object get_Value() :279
void Let__get_Value_fn(Let* __this, uObject** __retval)
{
    *__retval = __this->Value();
}

// public void set_Value(object value) :280
void Let__set_Value_fn(Let* __this, uObject* value)
{
    __this->Value(value);
}

// public generated Let() [instance] :261
void Let::ctor_4()
{
    ctor_3();
}

// private void CleanupExpression() [instance] :299
void Let::CleanupExpression()
{
    uStackFrame __("Fuse.Reactive.Let", "CleanupExpression()");

    if (_exprSub != NULL)
    {
        uPtr(_exprSub)->Dispose();
        _exprSub = NULL;
    }
}

// public Fuse.Reactive.IExpression get_Expression() [instance] :266
uObject* Let::Expression()
{
    return _expr;
}

// public void set_Expression(Fuse.Reactive.IExpression value) [instance] :267
void Let::Expression(uObject* value)
{
    uStackFrame __("Fuse.Reactive.Let", "set_Expression(Fuse.Reactive.IExpression)");
    CleanupExpression();
    _expr = value;

    if (IsRootingCompleted())
        SubscribeExpression();
}

// public void SetValue(object value, Uno.UX.IPropertyListener origin) [instance] :283
void Let::SetValue(uObject* value, uObject* origin)
{
    SetObjectValue(value, origin);
}

// private void SubscribeExpression() [instance] :308
void Let::SubscribeExpression()
{
    uStackFrame __("Fuse.Reactive.Let", "SubscribeExpression()");
    CleanupExpression();

    if (_expr == NULL)
        return;

    _exprSub = ::g::Fuse::Reactive::NodeExpressionBinding::New1(_expr, this, (uObject*)this);
}

// public object get_Value() [instance] :279
uObject* Let::Value()
{
    return ObjectValue();
}

// public void set_Value(object value) [instance] :280
void Let::Value(uObject* value)
{
    uStackFrame __("Fuse.Reactive.Let", "set_Value(object)");
    SetValue(value, (uObject*)this);
}

// public generated Let New() [static] :261
Let* Let::New2()
{
    Let* obj1 = (Let*)uNew(Let_typeof());
    obj1->ctor_4();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Let.uno
// ----------------------------------------------------------------------------------------

// public abstract class LetBase :11
// {
// static generated LetBase() :11
static void LetBase__cctor_1_fn(uType* __type)
{
    LetBase::ValueName_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[91/*"Value"*/]);
}

static void LetBase_build(uType* type)
{
    ::STRINGS[91] = uString::Const("Value");
    ::STRINGS[92] = uString::Const("Missing a `Name` for Let");
    ::STRINGS[93] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Bindings\\1.8.1\\Let.uno");
    ::STRINGS[94] = uString::Const("DataChanged");
    ::TYPES[46] = ::g::Fuse::Reactive::IObservable_typeof();
    ::TYPES[47] = ::g::Uno::String_typeof()->Array();
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(LetBase_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(LetBase_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(LetBase_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(LetBase_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(LetBase_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(LetBase_type, interface5),
        ::g::Fuse::Node__ISiblingDataProvider_typeof(), offsetof(LetBase_type, interface6),
        ::g::Fuse::IObject_typeof(), offsetof(LetBase_type, interface7),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(LetBase_type, interface8));
    type->SetFields(16,
        ::g::Uno::Bool_typeof(), offsetof(LetBase, _hasValue), 0,
        uObject_typeof(), offsetof(LetBase, _value), 0,
        ::g::Fuse::Reactive::LetObservable_typeof(), offsetof(LetBase, _observable), 0,
        ::g::Uno::Bool_typeof(), offsetof(LetBase, _updated), 0,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&LetBase::ValueName_, uFieldFlagsStatic);
    type->Reflection.SetFunctions(1,
        new uFunction("SetObjectValue", NULL, (void*)LetBase__SetObjectValue_fn, 0, false, uVoid_typeof(), 2, uObject_typeof(), ::g::Uno::UX::IPropertyListener_typeof()));
}

LetBase_type* LetBase_typeof()
{
    static uSStrong<LetBase_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Behavior_typeof();
    options.FieldCount = 21;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(LetBase);
    options.TypeSize = sizeof(LetBase_type);
    type = (LetBase_type*)uClassType::New("Fuse.Reactive.LetBase", options);
    type->fp_build_ = LetBase_build;
    type->fp_cctor_ = LetBase__cctor_1_fn;
    type->fp_OnRooted = (void(*)(::g::Fuse::Node*))LetBase__OnRooted_fn;
    type->fp_OnRootedValue = LetBase__OnRootedValue_fn;
    type->fp_OnUnrooted = (void(*)(::g::Fuse::Node*))LetBase__OnUnrooted_fn;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, int32_t*, uObject**, int32_t*))LetBase__FuseNodeISiblingDataProviderTryGetDataProvider_fn;
    type->interface7.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))LetBase__FuseIObjectContainsKey_fn;
    type->interface8.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))LetBase__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface7.fp_get_Item = (void(*)(uObject*, uString*, uObject**))LetBase__FuseIObjectget_Item_fn;
    type->interface7.fp_get_Keys = (void(*)(uObject*, uArray**))LetBase__FuseIObjectget_Keys_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// internal LetBase() :13
void LetBase__ctor_3_fn(LetBase* __this)
{
    __this->ctor_3();
}

// private object get_ContextValue() :90
void LetBase__get_ContextValue_fn(LetBase* __this, uObject** __retval)
{
    *__retval = __this->ContextValue();
}

// private void DataChanged(object newValue) :68
void LetBase__DataChanged_fn(LetBase* __this, uObject* newValue)
{
    __this->DataChanged(newValue);
}

// private bool Fuse.IObject.ContainsKey(string key) :123
void LetBase__FuseIObjectContainsKey_fn(LetBase* __this, uString* key, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.LetBase", "Fuse.IObject.ContainsKey(string)");
    return *__retval = ::g::Uno::String::op_Equality(::g::Uno::UX::Selector__op_Implicit1(__this->Name()), key), void();
}

// private object Fuse.IObject.get_Item(string key) :129
void LetBase__FuseIObjectget_Item_fn(LetBase* __this, uString* key, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.LetBase", "Fuse.IObject.get_Item(string)");

    if (::g::Uno::String::op_Equality(::g::Uno::UX::Selector__op_Implicit1(__this->Name()), key))
        return *__retval = __this->ContextValue(), void();

    return *__retval = NULL, void();
}

// private string[] Fuse.IObject.get_Keys() :138
void LetBase__FuseIObjectget_Keys_fn(LetBase* __this, uArray** __retval)
{
    uStackFrame __("Fuse.Reactive.LetBase", "Fuse.IObject.get_Keys()");
    return *__retval = uArray::Init<uString*>(::TYPES[47/*string[]*/], 1, (uString*)::g::Uno::UX::Selector__op_Implicit1(__this->Name())), void();
}

// private Fuse.Node.ContextDataResult Fuse.Node.ISiblingDataProvider.TryGetDataProvider(Fuse.Node.DataType type, object& provider) :117
void LetBase__FuseNodeISiblingDataProviderTryGetDataProvider_fn(LetBase* __this, int32_t* type, uObject** provider, int32_t* __retval)
{
    uStackFrame __("Fuse.Reactive.LetBase", "Fuse.Node.ISiblingDataProvider.TryGetDataProvider(Fuse.Node.DataType,object&)");
    int32_t type_ = *type;
    *provider = (type_ != 0) ? uCast<LetBase*>(NULL, LetBase_typeof()) : __this;
    return *__retval = 0, void();
}

// internal bool get_HasValue() :26
void LetBase__get_HasValue_fn(LetBase* __this, bool* __retval)
{
    *__retval = __this->HasValue();
}

// internal object get_ObjectValue() :21
void LetBase__get_ObjectValue_fn(LetBase* __this, uObject** __retval)
{
    *__retval = __this->ObjectValue();
}

// protected override sealed void OnRooted() :98
void LetBase__OnRooted_fn(LetBase* __this)
{
    uStackFrame __("Fuse.Reactive.LetBase", "OnRooted()");
    __this->_updated = false;
    ::g::Fuse::Node__OnRooted_fn(__this);
    __this->OnRootedValue();

    if (!__this->_updated)
        __this->UpdateValue((uObject*)__this);
}

// protected virtual void OnRootedValue() :107
void LetBase__OnRootedValue_fn(LetBase* __this)
{
}

// protected override void OnUnrooted() :109
void LetBase__OnUnrooted_fn(LetBase* __this)
{
    uStackFrame __("Fuse.Reactive.LetBase", "OnUnrooted()");
    __this->_observable = NULL;
    __this->DataChanged(NULL);
    ::g::Fuse::Node__OnUnrooted_fn(__this);
}

// internal void ResetObjectValue() :81
void LetBase__ResetObjectValue_fn(LetBase* __this)
{
    __this->ResetObjectValue();
}

// public void SetObjectValue(object value, Uno.UX.IPropertyListener origin) :30
void LetBase__SetObjectValue_fn(LetBase* __this, uObject* value, uObject* origin)
{
    __this->SetObjectValue(value, origin);
}

// private void Uno.UX.IPropertyListener.OnPropertyChanged(Uno.UX.PropertyObject source, Uno.UX.Selector selector) :141
void LetBase__UnoUXIPropertyListenerOnPropertyChanged_fn(LetBase* __this, ::g::Uno::UX::PropertyObject* source, ::g::Uno::UX::Selector* selector)
{
}

// private void UpdateValue(Uno.UX.IPropertyListener origin) :41
void LetBase__UpdateValue_fn(LetBase* __this, uObject* origin)
{
    __this->UpdateValue(origin);
}

::g::Uno::UX::Selector LetBase::ValueName_;

// internal LetBase() [instance] :13
void LetBase::ctor_3()
{
    ctor_2();
}

// private object get_ContextValue() [instance] :90
uObject* LetBase::ContextValue()
{
    if (_observable != NULL)
        return _observable;

    return _value;
}

// private void DataChanged(object newValue) [instance] :68
void LetBase::DataChanged(uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.LetBase", "DataChanged(object)");

    if (::g::Uno::String::op_Equality(::g::Uno::UX::Selector__op_Implicit1(Name()), NULL))
    {
        if (IsRootingStarted())
            ::g::Fuse::Diagnostics::UserWarning(::STRINGS[92/*"Missing a `...*/], this, ::STRINGS[93/*"C:\\Users\\...*/], 74, ::STRINGS[94/*"DataChanged"*/]);

        return;
    }

    OnDataChanged(::g::Uno::UX::Selector__op_Implicit1(Name()), newValue);
}

// internal bool get_HasValue() [instance] :26
bool LetBase::HasValue()
{
    return _hasValue;
}

// internal object get_ObjectValue() [instance] :21
uObject* LetBase::ObjectValue()
{
    return _value;
}

// internal void ResetObjectValue() [instance] :81
void LetBase::ResetObjectValue()
{
    uStackFrame __("Fuse.Reactive.LetBase", "ResetObjectValue()");
    _value = NULL;
    _hasValue = false;
    UpdateValue((uObject*)this);
}

// public void SetObjectValue(object value, Uno.UX.IPropertyListener origin) [instance] :30
void LetBase::SetObjectValue(uObject* value, uObject* origin)
{
    uStackFrame __("Fuse.Reactive.LetBase", "SetObjectValue(object,Uno.UX.IPropertyListener)");

    if (_hasValue && ::g::Uno::Object::Equals1(_value, value))
        return;

    _value = value;
    _hasValue = true;
    UpdateValue(origin);
}

// private void UpdateValue(Uno.UX.IPropertyListener origin) [instance] :41
void LetBase::UpdateValue(uObject* origin)
{
    uStackFrame __("Fuse.Reactive.LetBase", "UpdateValue(Uno.UX.IPropertyListener)");
    _updated = true;
    OnPropertyChanged1(LetBase::ValueName_, origin);

    if (uIs((uObject*)_value, ::TYPES[46/*Fuse.Reactive.IObservable*/]))
    {
        _observable = NULL;
        DataChanged(_value);
    }
    else
    {
        if (_observable == NULL)
        {
            _observable = ::g::Fuse::Reactive::LetObservable::New1(this);
            DataChanged(_observable);
        }
        else if (_hasValue)
            uPtr(_observable)->UpdateSetValue();
        else
            uPtr(_observable)->UpdateClear();
    }
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Let.uno
// ----------------------------------------------------------------------------------------

// public sealed class LetBool :381
// {
static void LetBool_build(uType* type)
{
    type->SetBase(::g::Fuse::Reactive::LetType_typeof()->MakeType(::g::Uno::Bool_typeof(), NULL));
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface5),
        ::g::Fuse::Node__ISiblingDataProvider_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface6),
        ::g::Fuse::IObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface7),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface8));
    type->SetFields(20);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)LetBool__New2_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::LetBase_type* LetBool_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::LetBase_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::LetType_typeof();
    options.FieldCount = 20;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(LetBool);
    options.TypeSize = sizeof(::g::Fuse::Reactive::LetBase_type);
    type = (::g::Fuse::Reactive::LetBase_type*)uClassType::New("Fuse.Reactive.LetBool", options);
    type->fp_build_ = LetBool_build;
    type->fp_ctor_ = (void*)LetBool__New2_fn;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, int32_t*, uObject**, int32_t*))::g::Fuse::Reactive::LetBase__FuseNodeISiblingDataProviderTryGetDataProvider_fn;
    type->interface7.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))::g::Fuse::Reactive::LetBase__FuseIObjectContainsKey_fn;
    type->interface8.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::LetBase__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface7.fp_get_Item = (void(*)(uObject*, uString*, uObject**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Item_fn;
    type->interface7.fp_get_Keys = (void(*)(uObject*, uArray**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Keys_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public generated LetBool() :381
void LetBool__ctor_5_fn(LetBool* __this)
{
    __this->ctor_5();
}

// public generated LetBool New() :381
void LetBool__New2_fn(LetBool** __retval)
{
    *__retval = LetBool::New2();
}

// public generated LetBool() [instance] :381
void LetBool::ctor_5()
{
    ctor_4();
}

// public generated LetBool New() [static] :381
LetBool* LetBool::New2()
{
    LetBool* obj1 = (LetBool*)uNew(LetBool_typeof());
    obj1->ctor_5();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Let.uno
// ----------------------------------------------------------------------------------------

// public sealed class LetFloat :371
// {
static void LetFloat_build(uType* type)
{
    type->SetBase(::g::Fuse::Reactive::LetType_typeof()->MakeType(::g::Uno::Float_typeof(), NULL));
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface5),
        ::g::Fuse::Node__ISiblingDataProvider_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface6),
        ::g::Fuse::IObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface7),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface8));
    type->SetFields(20);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)LetFloat__New2_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::LetBase_type* LetFloat_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::LetBase_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::LetType_typeof();
    options.FieldCount = 20;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(LetFloat);
    options.TypeSize = sizeof(::g::Fuse::Reactive::LetBase_type);
    type = (::g::Fuse::Reactive::LetBase_type*)uClassType::New("Fuse.Reactive.LetFloat", options);
    type->fp_build_ = LetFloat_build;
    type->fp_ctor_ = (void*)LetFloat__New2_fn;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, int32_t*, uObject**, int32_t*))::g::Fuse::Reactive::LetBase__FuseNodeISiblingDataProviderTryGetDataProvider_fn;
    type->interface7.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))::g::Fuse::Reactive::LetBase__FuseIObjectContainsKey_fn;
    type->interface8.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::LetBase__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface7.fp_get_Item = (void(*)(uObject*, uString*, uObject**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Item_fn;
    type->interface7.fp_get_Keys = (void(*)(uObject*, uArray**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Keys_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public generated LetFloat() :371
void LetFloat__ctor_5_fn(LetFloat* __this)
{
    __this->ctor_5();
}

// public generated LetFloat New() :371
void LetFloat__New2_fn(LetFloat** __retval)
{
    *__retval = LetFloat::New2();
}

// public generated LetFloat() [instance] :371
void LetFloat::ctor_5()
{
    ctor_4();
}

// public generated LetFloat New() [static] :371
LetFloat* LetFloat::New2()
{
    LetFloat* obj1 = (LetFloat*)uNew(LetFloat_typeof());
    obj1->ctor_5();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Let.uno
// ----------------------------------------------------------------------------------------

// public sealed class LetFloat2 :373
// {
static void LetFloat2_build(uType* type)
{
    type->SetBase(::g::Fuse::Reactive::LetType_typeof()->MakeType(::g::Uno::Float2_typeof(), NULL));
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface5),
        ::g::Fuse::Node__ISiblingDataProvider_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface6),
        ::g::Fuse::IObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface7),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface8));
    type->SetFields(20);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)LetFloat2__New2_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::LetBase_type* LetFloat2_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::LetBase_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::LetType_typeof();
    options.FieldCount = 20;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(LetFloat2);
    options.TypeSize = sizeof(::g::Fuse::Reactive::LetBase_type);
    type = (::g::Fuse::Reactive::LetBase_type*)uClassType::New("Fuse.Reactive.LetFloat2", options);
    type->fp_build_ = LetFloat2_build;
    type->fp_ctor_ = (void*)LetFloat2__New2_fn;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, int32_t*, uObject**, int32_t*))::g::Fuse::Reactive::LetBase__FuseNodeISiblingDataProviderTryGetDataProvider_fn;
    type->interface7.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))::g::Fuse::Reactive::LetBase__FuseIObjectContainsKey_fn;
    type->interface8.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::LetBase__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface7.fp_get_Item = (void(*)(uObject*, uString*, uObject**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Item_fn;
    type->interface7.fp_get_Keys = (void(*)(uObject*, uArray**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Keys_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public generated LetFloat2() :373
void LetFloat2__ctor_5_fn(LetFloat2* __this)
{
    __this->ctor_5();
}

// public generated LetFloat2 New() :373
void LetFloat2__New2_fn(LetFloat2** __retval)
{
    *__retval = LetFloat2::New2();
}

// public generated LetFloat2() [instance] :373
void LetFloat2::ctor_5()
{
    ctor_4();
}

// public generated LetFloat2 New() [static] :373
LetFloat2* LetFloat2::New2()
{
    LetFloat2* obj1 = (LetFloat2*)uNew(LetFloat2_typeof());
    obj1->ctor_5();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Let.uno
// ----------------------------------------------------------------------------------------

// public sealed class LetFloat3 :375
// {
static void LetFloat3_build(uType* type)
{
    type->SetBase(::g::Fuse::Reactive::LetType_typeof()->MakeType(::g::Uno::Float3_typeof(), NULL));
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface5),
        ::g::Fuse::Node__ISiblingDataProvider_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface6),
        ::g::Fuse::IObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface7),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface8));
    type->SetFields(20);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)LetFloat3__New2_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::LetBase_type* LetFloat3_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::LetBase_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::LetType_typeof();
    options.FieldCount = 20;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(LetFloat3);
    options.TypeSize = sizeof(::g::Fuse::Reactive::LetBase_type);
    type = (::g::Fuse::Reactive::LetBase_type*)uClassType::New("Fuse.Reactive.LetFloat3", options);
    type->fp_build_ = LetFloat3_build;
    type->fp_ctor_ = (void*)LetFloat3__New2_fn;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, int32_t*, uObject**, int32_t*))::g::Fuse::Reactive::LetBase__FuseNodeISiblingDataProviderTryGetDataProvider_fn;
    type->interface7.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))::g::Fuse::Reactive::LetBase__FuseIObjectContainsKey_fn;
    type->interface8.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::LetBase__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface7.fp_get_Item = (void(*)(uObject*, uString*, uObject**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Item_fn;
    type->interface7.fp_get_Keys = (void(*)(uObject*, uArray**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Keys_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public generated LetFloat3() :375
void LetFloat3__ctor_5_fn(LetFloat3* __this)
{
    __this->ctor_5();
}

// public generated LetFloat3 New() :375
void LetFloat3__New2_fn(LetFloat3** __retval)
{
    *__retval = LetFloat3::New2();
}

// public generated LetFloat3() [instance] :375
void LetFloat3::ctor_5()
{
    ctor_4();
}

// public generated LetFloat3 New() [static] :375
LetFloat3* LetFloat3::New2()
{
    LetFloat3* obj1 = (LetFloat3*)uNew(LetFloat3_typeof());
    obj1->ctor_5();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Let.uno
// ----------------------------------------------------------------------------------------

// public sealed class LetFloat4 :377
// {
static void LetFloat4_build(uType* type)
{
    type->SetBase(::g::Fuse::Reactive::LetType_typeof()->MakeType(::g::Uno::Float4_typeof(), NULL));
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface5),
        ::g::Fuse::Node__ISiblingDataProvider_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface6),
        ::g::Fuse::IObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface7),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface8));
    type->SetFields(20);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)LetFloat4__New2_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::LetBase_type* LetFloat4_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::LetBase_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::LetType_typeof();
    options.FieldCount = 20;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(LetFloat4);
    options.TypeSize = sizeof(::g::Fuse::Reactive::LetBase_type);
    type = (::g::Fuse::Reactive::LetBase_type*)uClassType::New("Fuse.Reactive.LetFloat4", options);
    type->fp_build_ = LetFloat4_build;
    type->fp_ctor_ = (void*)LetFloat4__New2_fn;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, int32_t*, uObject**, int32_t*))::g::Fuse::Reactive::LetBase__FuseNodeISiblingDataProviderTryGetDataProvider_fn;
    type->interface7.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))::g::Fuse::Reactive::LetBase__FuseIObjectContainsKey_fn;
    type->interface8.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::LetBase__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface7.fp_get_Item = (void(*)(uObject*, uString*, uObject**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Item_fn;
    type->interface7.fp_get_Keys = (void(*)(uObject*, uArray**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Keys_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public generated LetFloat4() :377
void LetFloat4__ctor_5_fn(LetFloat4* __this)
{
    __this->ctor_5();
}

// public generated LetFloat4 New() :377
void LetFloat4__New2_fn(LetFloat4** __retval)
{
    *__retval = LetFloat4::New2();
}

// public generated LetFloat4() [instance] :377
void LetFloat4::ctor_5()
{
    ctor_4();
}

// public generated LetFloat4 New() [static] :377
LetFloat4* LetFloat4::New2()
{
    LetFloat4* obj1 = (LetFloat4*)uNew(LetFloat4_typeof());
    obj1->ctor_5();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Let.uno
// ----------------------------------------------------------------------------------------

// internal sealed class LetObservable :146
// {
static void LetObservable_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IObservable_typeof(), offsetof(LetObservable_type, interface0),
        ::g::Fuse::Reactive::IObservableArray_typeof(), offsetof(LetObservable_type, interface1),
        ::g::Fuse::IArray_typeof(), offsetof(LetObservable_type, interface2));
    type->SetFields(0,
        ::g::Uno::Collections::List_typeof()->MakeType(::g::Fuse::Reactive::IObserver_typeof(), NULL), offsetof(LetObservable, _observers), 0,
        ::g::Fuse::Reactive::LetBase_typeof(), offsetof(LetObservable, _let), 0);
}

LetObservable_type* LetObservable_typeof()
{
    static uSStrong<LetObservable_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 2;
    options.InterfaceCount = 3;
    options.ObjectSize = sizeof(LetObservable);
    options.TypeSize = sizeof(LetObservable_type);
    type = (LetObservable_type*)uClassType::New("Fuse.Reactive.LetObservable", options);
    type->fp_build_ = LetObservable_build;
    type->interface1.fp_Subscribe = (void(*)(uObject*, uObject*, uObject**))LetObservable__FuseReactiveIObservableArraySubscribe_fn;
    type->interface2.fp_get_Length = (void(*)(uObject*, int32_t*))LetObservable__FuseIArrayget_Length_fn;
    type->interface2.fp_get_Item = (void(*)(uObject*, int32_t*, uObject**))LetObservable__FuseIArrayget_Item_fn;
    return type;
}

// public LetObservable(Fuse.Reactive.LetBase let) :151
void LetObservable__ctor__fn(LetObservable* __this, ::g::Fuse::Reactive::LetBase* let)
{
    __this->ctor_(let);
}

// public void Dispose() :156
void LetObservable__Dispose_fn(LetObservable* __this)
{
    __this->Dispose();
}

// private object Fuse.IArray.get_Item(int index) :177
void LetObservable__FuseIArrayget_Item_fn(LetObservable* __this, int32_t* index, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.LetObservable", "Fuse.IArray.get_Item(int)");
    int32_t index_ = *index;

    if (((index_ != 0) || (__this->_let == NULL)) || !uPtr(__this->_let)->HasValue())
        U_THROW(::g::Uno::IndexOutOfRangeException::New4());

    return *__retval = uPtr(__this->_let)->ObjectValue(), void();
}

// private int Fuse.IArray.get_Length() :172
void LetObservable__FuseIArrayget_Length_fn(LetObservable* __this, int32_t* __retval)
{
    uStackFrame __("Fuse.Reactive.LetObservable", "Fuse.IArray.get_Length()");
    return *__retval = ((__this->_let != NULL) && uPtr(__this->_let)->HasValue()) ? 1 : 0, void();
}

// private Uno.IDisposable Fuse.Reactive.IObservableArray.Subscribe(Fuse.Reactive.IObserver observer) :162
void LetObservable__FuseReactiveIObservableArraySubscribe_fn(LetObservable* __this, uObject* observer, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.LetObservable", "Fuse.Reactive.IObservableArray.Subscribe(Fuse.Reactive.IObserver)");
    LetObservable__Subscription* collection1;

    if (__this->_observers == NULL)
        __this->_observers = ((::g::Uno::Collections::List*)::g::Uno::Collections::List::New1(::TYPES[60/*Uno.Collections.List`1*/]->MakeType(::TYPES[55/*Fuse.Reactive.IObserver*/], NULL)));

    ::g::Uno::Collections::List__Add_fn(uPtr(__this->_observers), observer);
    return *__retval = (uObject*)(collection1 = LetObservable__Subscription::New1(), uPtr(collection1)->Source = __this, uPtr(collection1)->Observer = observer, collection1), void();
}

// public LetObservable New(Fuse.Reactive.LetBase let) :151
void LetObservable__New1_fn(::g::Fuse::Reactive::LetBase* let, LetObservable** __retval)
{
    *__retval = LetObservable::New1(let);
}

// private void Unsubscribe(Fuse.Reactive.IObserver observer) :185
void LetObservable__Unsubscribe_fn(LetObservable* __this, uObject* observer)
{
    __this->Unsubscribe(observer);
}

// public void UpdateClear() :200
void LetObservable__UpdateClear_fn(LetObservable* __this)
{
    __this->UpdateClear();
}

// public void UpdateSetValue() :191
void LetObservable__UpdateSetValue_fn(LetObservable* __this)
{
    __this->UpdateSetValue();
}

// public LetObservable(Fuse.Reactive.LetBase let) [instance] :151
void LetObservable::ctor_(::g::Fuse::Reactive::LetBase* let)
{
    _let = let;
}

// public void Dispose() [instance] :156
void LetObservable::Dispose()
{
    _let = NULL;
    _observers = NULL;
}

// private void Unsubscribe(Fuse.Reactive.IObserver observer) [instance] :185
void LetObservable::Unsubscribe(uObject* observer)
{
    uStackFrame __("Fuse.Reactive.LetObservable", "Unsubscribe(Fuse.Reactive.IObserver)");
    bool ret3;

    if (_observers != NULL)
        ::g::Uno::Collections::List__Remove_fn(uPtr(_observers), observer, &ret3);
}

// public void UpdateClear() [instance] :200
void LetObservable::UpdateClear()
{
    uStackFrame __("Fuse.Reactive.LetObservable", "UpdateClear()");
    uObject* ret4;

    if (_observers != NULL)

        for (int32_t i = 0; i < uPtr(_observers)->Count(); ++i)
            ::g::Fuse::Reactive::IObserver::OnClear(uInterface(uPtr((::g::Uno::Collections::List__get_Item_fn(uPtr(_observers), uCRef<int32_t>(i), &ret4), ret4)), ::TYPES[55/*Fuse.Reactive.IObserver*/]));
}

// public void UpdateSetValue() [instance] :191
void LetObservable::UpdateSetValue()
{
    uStackFrame __("Fuse.Reactive.LetObservable", "UpdateSetValue()");
    uObject* ret5;

    if (_observers != NULL)

        for (int32_t i = 0; i < uPtr(_observers)->Count(); ++i)
            ::g::Fuse::Reactive::IObserver::OnSet(uInterface(uPtr((::g::Uno::Collections::List__get_Item_fn(uPtr(_observers), uCRef<int32_t>(i), &ret5), ret5)), ::TYPES[55/*Fuse.Reactive.IObserver*/]), uPtr(_let)->ObjectValue());
}

// public LetObservable New(Fuse.Reactive.LetBase let) [static] :151
LetObservable* LetObservable::New1(::g::Fuse::Reactive::LetBase* let)
{
    LetObservable* obj2 = (LetObservable*)uNew(LetObservable_typeof());
    obj2->ctor_(let);
    return obj2;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Let.uno
// ----------------------------------------------------------------------------------------

// public sealed class LetSize :383
// {
static void LetSize_build(uType* type)
{
    type->SetBase(::g::Fuse::Reactive::LetType_typeof()->MakeType(::g::Uno::UX::Size_typeof(), NULL));
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface5),
        ::g::Fuse::Node__ISiblingDataProvider_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface6),
        ::g::Fuse::IObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface7),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface8));
    type->SetFields(20);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)LetSize__New2_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::LetBase_type* LetSize_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::LetBase_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::LetType_typeof();
    options.FieldCount = 20;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(LetSize);
    options.TypeSize = sizeof(::g::Fuse::Reactive::LetBase_type);
    type = (::g::Fuse::Reactive::LetBase_type*)uClassType::New("Fuse.Reactive.LetSize", options);
    type->fp_build_ = LetSize_build;
    type->fp_ctor_ = (void*)LetSize__New2_fn;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, int32_t*, uObject**, int32_t*))::g::Fuse::Reactive::LetBase__FuseNodeISiblingDataProviderTryGetDataProvider_fn;
    type->interface7.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))::g::Fuse::Reactive::LetBase__FuseIObjectContainsKey_fn;
    type->interface8.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::LetBase__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface7.fp_get_Item = (void(*)(uObject*, uString*, uObject**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Item_fn;
    type->interface7.fp_get_Keys = (void(*)(uObject*, uArray**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Keys_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public generated LetSize() :383
void LetSize__ctor_5_fn(LetSize* __this)
{
    __this->ctor_5();
}

// public generated LetSize New() :383
void LetSize__New2_fn(LetSize** __retval)
{
    *__retval = LetSize::New2();
}

// public generated LetSize() [instance] :383
void LetSize::ctor_5()
{
    ctor_4();
}

// public generated LetSize New() [static] :383
LetSize* LetSize::New2()
{
    LetSize* obj1 = (LetSize*)uNew(LetSize_typeof());
    obj1->ctor_5();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Let.uno
// ----------------------------------------------------------------------------------------

// public sealed class LetSize2 :385
// {
static void LetSize2_build(uType* type)
{
    type->SetBase(::g::Fuse::Reactive::LetType_typeof()->MakeType(::g::Uno::UX::Size2_typeof(), NULL));
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface5),
        ::g::Fuse::Node__ISiblingDataProvider_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface6),
        ::g::Fuse::IObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface7),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface8));
    type->SetFields(20);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)LetSize2__New2_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::LetBase_type* LetSize2_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::LetBase_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::LetType_typeof();
    options.FieldCount = 20;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(LetSize2);
    options.TypeSize = sizeof(::g::Fuse::Reactive::LetBase_type);
    type = (::g::Fuse::Reactive::LetBase_type*)uClassType::New("Fuse.Reactive.LetSize2", options);
    type->fp_build_ = LetSize2_build;
    type->fp_ctor_ = (void*)LetSize2__New2_fn;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, int32_t*, uObject**, int32_t*))::g::Fuse::Reactive::LetBase__FuseNodeISiblingDataProviderTryGetDataProvider_fn;
    type->interface7.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))::g::Fuse::Reactive::LetBase__FuseIObjectContainsKey_fn;
    type->interface8.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::LetBase__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface7.fp_get_Item = (void(*)(uObject*, uString*, uObject**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Item_fn;
    type->interface7.fp_get_Keys = (void(*)(uObject*, uArray**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Keys_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public generated LetSize2() :385
void LetSize2__ctor_5_fn(LetSize2* __this)
{
    __this->ctor_5();
}

// public generated LetSize2 New() :385
void LetSize2__New2_fn(LetSize2** __retval)
{
    *__retval = LetSize2::New2();
}

// public generated LetSize2() [instance] :385
void LetSize2::ctor_5()
{
    ctor_4();
}

// public generated LetSize2 New() [static] :385
LetSize2* LetSize2::New2()
{
    LetSize2* obj1 = (LetSize2*)uNew(LetSize2_typeof());
    obj1->ctor_5();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Let.uno
// ----------------------------------------------------------------------------------------

// public sealed class LetString :379
// {
static void LetString_build(uType* type)
{
    type->SetBase(::g::Fuse::Reactive::LetType_typeof()->MakeType(::g::Uno::String_typeof(), NULL));
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface5),
        ::g::Fuse::Node__ISiblingDataProvider_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface6),
        ::g::Fuse::IObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface7),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface8));
    type->SetFields(20);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)LetString__New2_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::LetBase_type* LetString_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::LetBase_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::LetType_typeof();
    options.FieldCount = 20;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(LetString);
    options.TypeSize = sizeof(::g::Fuse::Reactive::LetBase_type);
    type = (::g::Fuse::Reactive::LetBase_type*)uClassType::New("Fuse.Reactive.LetString", options);
    type->fp_build_ = LetString_build;
    type->fp_ctor_ = (void*)LetString__New2_fn;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, int32_t*, uObject**, int32_t*))::g::Fuse::Reactive::LetBase__FuseNodeISiblingDataProviderTryGetDataProvider_fn;
    type->interface7.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))::g::Fuse::Reactive::LetBase__FuseIObjectContainsKey_fn;
    type->interface8.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::LetBase__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface7.fp_get_Item = (void(*)(uObject*, uString*, uObject**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Item_fn;
    type->interface7.fp_get_Keys = (void(*)(uObject*, uArray**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Keys_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public generated LetString() :379
void LetString__ctor_5_fn(LetString* __this)
{
    __this->ctor_5();
}

// public generated LetString New() :379
void LetString__New2_fn(LetString** __retval)
{
    *__retval = LetString::New2();
}

// public generated LetString() [instance] :379
void LetString::ctor_5()
{
    ctor_4();
}

// public generated LetString New() [static] :379
LetString* LetString::New2()
{
    LetString* obj1 = (LetString*)uNew(LetString_typeof());
    obj1->ctor_5();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Let.uno
// ----------------------------------------------------------------------------------------

// public abstract class LetType<T> :348
// {
static void LetType_build(uType* type)
{
    ::TYPES[48] = ::g::Fuse::Marshal_typeof();
    type->SetPrecalc(
        ::g::Fuse::Marshal_typeof()->MakeMethod(1/*TryToType<T>*/, type->T(0), NULL));
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::LetBase_type, interface5),
        ::g::Fuse::Node__ISiblingDataProvider_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface6),
        ::g::Fuse::IObject_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface7),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(::g::Fuse::Reactive::LetBase_type, interface8));
    type->SetFields(20);
    type->Reflection.SetFunctions(3,
        new uFunction("SetValue", NULL, (void*)LetType__SetValue_fn, 0, false, uVoid_typeof(), 2, type->T(0), ::g::Uno::UX::IPropertyListener_typeof()),
        new uFunction("get_Value", NULL, (void*)LetType__get_Value_fn, 0, false, type->T(0), 0),
        new uFunction("set_Value", NULL, (void*)LetType__set_Value_fn, 0, false, uVoid_typeof(), 1, type->T(0)));
}

::g::Fuse::Reactive::LetBase_type* LetType_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::LetBase_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::LetBase_typeof();
    options.FieldCount = 20;
    options.GenericCount = 1;
    options.InterfaceCount = 9;
    options.PrecalcCount = 1;
    options.ObjectSize = sizeof(LetType);
    options.TypeSize = sizeof(::g::Fuse::Reactive::LetBase_type);
    type = (::g::Fuse::Reactive::LetBase_type*)uClassType::New("Fuse.Reactive.LetType`1", options);
    type->fp_build_ = LetType_build;
    type->interface6.fp_TryGetDataProvider = (void(*)(uObject*, int32_t*, uObject**, int32_t*))::g::Fuse::Reactive::LetBase__FuseNodeISiblingDataProviderTryGetDataProvider_fn;
    type->interface7.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))::g::Fuse::Reactive::LetBase__FuseIObjectContainsKey_fn;
    type->interface8.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::LetBase__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface7.fp_get_Item = (void(*)(uObject*, uString*, uObject**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Item_fn;
    type->interface7.fp_get_Keys = (void(*)(uObject*, uArray**))::g::Fuse::Reactive::LetBase__FuseIObjectget_Keys_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// protected generated LetType() :348
void LetType__ctor_4_fn(LetType* __this)
{
    __this->ctor_4();
}

// public void SetValue(T value, Uno.UX.IPropertyListener origin) :364
void LetType__SetValue_fn(LetType* __this, void* value, uObject* origin)
{
    uStackFrame __("Fuse.Reactive.LetType`1", "SetValue(T,Uno.UX.IPropertyListener)");
    __this->SetObjectValue(uBoxPtr(__this->__type->GetBase(LetType_typeof())->T(0), value), origin);
}

// public T get_Value() :353
void LetType__get_Value_fn(LetType* __this, uTRef __retval)
{
    uType* __types[] = {
        __this->__type->GetBase(LetType_typeof())->Precalced(0/*Fuse.Marshal.TryToType<T>*/),
    };
    uStackFrame __("Fuse.Reactive.LetType`1", "get_Value()");
    uT result(__this->__type->GetBase(LetType_typeof())->T(0), U_ALLOCA(__this->__type->GetBase(LetType_typeof())->T(0)->ValueSize));
    bool ret1;
    result = uT(__this->__type->GetBase(LetType_typeof())->T(0), U_ALLOCA(__this->__type->GetBase(LetType_typeof())->T(0)->ValueSize));

    if (__this->HasValue() && (::g::Fuse::Marshal__TryToType_fn(__types[0], __this->ObjectValue(), &result, &ret1), ret1))
        return __retval.Store(result), void();

    return __retval.Store(__this->__type->GetBase(LetType_typeof())->T(0), uT(__this->__type->GetBase(LetType_typeof())->T(0), U_ALLOCA(__this->__type->GetBase(LetType_typeof())->T(0)->ValueSize))), void();
}

// public void set_Value(T value) :361
void LetType__set_Value_fn(LetType* __this, void* value)
{
    uStackFrame __("Fuse.Reactive.LetType`1", "set_Value(T)");
    LetType__SetValue_fn(__this, value, (uObject*)__this);
}

// protected generated LetType() [instance] :348
void LetType::ctor_4()
{
    ctor_3();
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Log :359
// {
static void Log_build(uType* type)
{
    ::STRINGS[32] = uString::Const("log");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Log__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Log_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Log);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Log", options);
    type->fp_build_ = Log_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Log(Fuse.Reactive.Expression operand) :362
void Log__ctor_5_fn(Log* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Log New(Fuse.Reactive.Expression operand) :362
void Log__New1_fn(::g::Fuse::Reactive::Expression* operand, Log** __retval)
{
    *__retval = Log::New1(operand);
}

// public Log(Fuse.Reactive.Expression operand) [instance] :362
void Log::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[32/*"log"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Log_fn));
}

// public Log New(Fuse.Reactive.Expression operand) [static] :362
Log* Log::New1(::g::Fuse::Reactive::Expression* operand)
{
    Log* obj1 = (Log*)uNew(Log_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Log2 :367
// {
static void Log2_build(uType* type)
{
    ::STRINGS[95] = uString::Const("log2");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Log2__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Log2_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Log2);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Log2", options);
    type->fp_build_ = Log2_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Log2(Fuse.Reactive.Expression operand) :370
void Log2__ctor_5_fn(Log2* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Log2 New(Fuse.Reactive.Expression operand) :370
void Log2__New1_fn(::g::Fuse::Reactive::Expression* operand, Log2** __retval)
{
    *__retval = Log2::New1(operand);
}

// public Log2(Fuse.Reactive.Expression operand) [instance] :370
void Log2::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[95/*"log2"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Log21_fn));
}

// public Log2 New(Fuse.Reactive.Expression operand) [static] :370
Log2* Log2::New1(::g::Fuse::Reactive::Expression* operand)
{
    Log2* obj1 = (Log2*)uNew(Log2_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class LogicalAnd :206
// {
static void LogicalAnd_build(uType* type)
{
    ::STRINGS[96] = uString::Const("&&");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)LogicalAnd__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* LogicalAnd_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InfixOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(LogicalAnd);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.LogicalAnd", options);
    type->fp_build_ = LogicalAnd_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))LogicalAnd__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public LogicalAnd(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :209
void LogicalAnd__ctor_6_fn(LogicalAnd* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_6(left, right);
}

// public LogicalAnd New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :209
void LogicalAnd__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, LogicalAnd** __retval)
{
    *__retval = LogicalAnd::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :211
void LogicalAnd__TryCompute1_fn(LogicalAnd* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.LogicalAnd", "TryCompute(object,object,object&)");
    *result = NULL;

    if ((left == NULL) || (right == NULL))
        return *__retval = false, void();

    *result = uBox(::TYPES[12/*bool*/], ::g::Fuse::Marshal::ToBool(left) && ::g::Fuse::Marshal::ToBool(right));
    return *__retval = true, void();
}

// public LogicalAnd(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :209
void LogicalAnd::ctor_6(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    uStackFrame __("Fuse.Reactive.LogicalAnd", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression)");
    ctor_5(left, right, ::STRINGS[96/*"&&"*/], 0);
}

// public LogicalAnd New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :209
LogicalAnd* LogicalAnd::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    LogicalAnd* obj1 = (LogicalAnd*)uNew(LogicalAnd_typeof());
    obj1->ctor_6(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\UnaryOperator.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class LogicalNot :81
// {
static void LogicalNot_build(uType* type)
{
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)LogicalNot__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* LogicalNot_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(LogicalNot);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.LogicalNot", options);
    type->fp_build_ = LogicalNot_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::UnaryOperator*, uObject*, uObject**, bool*))LogicalNot__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public LogicalNot(Fuse.Reactive.Expression operand) :84
void LogicalNot__ctor_4_fn(LogicalNot* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_4(operand);
}

// public LogicalNot New(Fuse.Reactive.Expression operand) :84
void LogicalNot__New1_fn(::g::Fuse::Reactive::Expression* operand, LogicalNot** __retval)
{
    *__retval = LogicalNot::New1(operand);
}

// protected override sealed bool TryCompute(object operand, object& result) :86
void LogicalNot__TryCompute1_fn(LogicalNot* __this, uObject* operand, uObject** result, bool* __retval)
{
    bool areEqual;

    if (!::g::Fuse::Marshal::TryEqualTo(operand, uBox(::TYPES[12/*bool*/], true), &areEqual))
    {
        *result = uBox(::TYPES[12/*bool*/], false);
        return *__retval = false, void();
    }

    *result = uBox(::TYPES[12/*bool*/], !areEqual);
    return *__retval = true, void();
}

// public LogicalNot(Fuse.Reactive.Expression operand) [instance] :84
void LogicalNot::ctor_4(::g::Fuse::Reactive::Expression* operand)
{
    ctor_2(operand, 3072);
}

// public LogicalNot New(Fuse.Reactive.Expression operand) [static] :84
LogicalNot* LogicalNot::New1(::g::Fuse::Reactive::Expression* operand)
{
    LogicalNot* obj1 = (LogicalNot*)uNew(LogicalNot_typeof());
    obj1->ctor_4(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class LogicalOr :220
// {
static void LogicalOr_build(uType* type)
{
    ::STRINGS[97] = uString::Const("||");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)LogicalOr__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* LogicalOr_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InfixOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(LogicalOr);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.LogicalOr", options);
    type->fp_build_ = LogicalOr_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))LogicalOr__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public LogicalOr(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :223
void LogicalOr__ctor_6_fn(LogicalOr* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_6(left, right);
}

// public LogicalOr New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :223
void LogicalOr__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, LogicalOr** __retval)
{
    *__retval = LogicalOr::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :225
void LogicalOr__TryCompute1_fn(LogicalOr* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.LogicalOr", "TryCompute(object,object,object&)");
    *result = NULL;

    if ((left == NULL) || (right == NULL))
        return *__retval = false, void();

    *result = uBox(::TYPES[12/*bool*/], ::g::Fuse::Marshal::ToBool(left) || ::g::Fuse::Marshal::ToBool(right));
    return *__retval = true, void();
}

// public LogicalOr(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :223
void LogicalOr::ctor_6(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    uStackFrame __("Fuse.Reactive.LogicalOr", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression)");
    ctor_5(left, right, ::STRINGS[97/*"||"*/], 0);
}

// public LogicalOr New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :223
LogicalOr* LogicalOr::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    LogicalOr* obj1 = (LogicalOr*)uNew(LogicalOr_typeof());
    obj1->ctor_6(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\LookUp.uno
// ----------------------------------------------------------------------------------------------

// public sealed class LookUp :17
// {
static void LookUp_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->SetFields(0,
        ::g::Fuse::Reactive::Expression_typeof(), offsetof(LookUp, _Collection), 0,
        ::g::Fuse::Reactive::Expression_typeof(), offsetof(LookUp, _Index), 0);
    type->Reflection.SetFunctions(3,
        new uFunction("get_Collection", NULL, (void*)LookUp__get_Collection_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0),
        new uFunction("get_Index", NULL, (void*)LookUp__get_Index_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0),
        new uFunction(".ctor", NULL, (void*)LookUp__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::Expression_type* LookUp_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.FieldCount = 2;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(LookUp);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.LookUp", options);
    type->fp_build_ = LookUp_build;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))LookUp__Subscribe_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))LookUp__Subscribe_fn;
    return type;
}

// public LookUp(Fuse.Reactive.Expression collection, Fuse.Reactive.Expression index) :23
void LookUp__ctor_1_fn(LookUp* __this, ::g::Fuse::Reactive::Expression* collection, ::g::Fuse::Reactive::Expression* index)
{
    __this->ctor_1(collection, index);
}

// public generated Fuse.Reactive.Expression get_Collection() :19
void LookUp__get_Collection_fn(LookUp* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->Collection();
}

// private generated void set_Collection(Fuse.Reactive.Expression value) :19
void LookUp__set_Collection_fn(LookUp* __this, ::g::Fuse::Reactive::Expression* value)
{
    __this->Collection(value);
}

// public generated Fuse.Reactive.Expression get_Index() :20
void LookUp__get_Index_fn(LookUp* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->Index();
}

// private generated void set_Index(Fuse.Reactive.Expression value) :20
void LookUp__set_Index_fn(LookUp* __this, ::g::Fuse::Reactive::Expression* value)
{
    __this->Index(value);
}

// public LookUp New(Fuse.Reactive.Expression collection, Fuse.Reactive.Expression index) :23
void LookUp__New1_fn(::g::Fuse::Reactive::Expression* collection, ::g::Fuse::Reactive::Expression* index, LookUp** __retval)
{
    *__retval = LookUp::New1(collection, index);
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :29
void LookUp__Subscribe_fn(LookUp* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.LookUp", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    return *__retval = (uObject*)LookUp__LookUpSubscription::New1(__this, context, listener), void();
}

// public LookUp(Fuse.Reactive.Expression collection, Fuse.Reactive.Expression index) [instance] :23
void LookUp::ctor_1(::g::Fuse::Reactive::Expression* collection, ::g::Fuse::Reactive::Expression* index)
{
    ctor_();
    Collection(collection);
    Index(index);
}

// public generated Fuse.Reactive.Expression get_Collection() [instance] :19
::g::Fuse::Reactive::Expression* LookUp::Collection()
{
    return _Collection;
}

// private generated void set_Collection(Fuse.Reactive.Expression value) [instance] :19
void LookUp::Collection(::g::Fuse::Reactive::Expression* value)
{
    _Collection = value;
}

// public generated Fuse.Reactive.Expression get_Index() [instance] :20
::g::Fuse::Reactive::Expression* LookUp::Index()
{
    return _Index;
}

// private generated void set_Index(Fuse.Reactive.Expression value) [instance] :20
void LookUp::Index(::g::Fuse::Reactive::Expression* value)
{
    _Index = value;
}

// public LookUp New(Fuse.Reactive.Expression collection, Fuse.Reactive.Expression index) [static] :23
LookUp* LookUp::New1(::g::Fuse::Reactive::Expression* collection, ::g::Fuse::Reactive::Expression* index)
{
    LookUp* obj1 = (LookUp*)uNew(LookUp_typeof());
    obj1->ctor_1(collection, index);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\LookUp.uno
// ----------------------------------------------------------------------------------------------

// private sealed class LookUp.LookUpSubscription :34
// {
static void LookUp__LookUpSubscription_build(uType* type)
{
    ::STRINGS[98] = uString::Const("Index must be a number: ");
    ::STRINGS[99] = uString::Const("Index was outside the bounds of the array");
    ::STRINGS[100] = uString::Const("Object does not contain the given key '");
    ::STRINGS[40] = uString::Const("'");
    ::STRINGS[101] = uString::Const("Look-up operator not supported on collection type: ");
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    ::TYPES[30] = ::g::Fuse::Reactive::IObservableArray_typeof();
    ::TYPES[46] = ::g::Fuse::Reactive::IObservable_typeof();
    ::TYPES[28] = ::g::Fuse::IArray_typeof();
    ::TYPES[49] = ::g::Fuse::MarshalException_typeof();
    ::TYPES[50] = ::g::Fuse::IObject_typeof();
    ::TYPES[35] = ::g::Fuse::Reactive::IObservableObject_typeof();
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::TYPES[3/*Uno.IDisposable*/], offsetof(LookUp__LookUpSubscription_type, interface0),
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(LookUp__LookUpSubscription_type, interface1),
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(LookUp__LookUpSubscription_type, interface2),
        ::g::Fuse::Reactive::ValueForwarder__IValueListener_typeof(), offsetof(LookUp__LookUpSubscription_type, interface3),
        ::g::Fuse::Reactive::IPropertyObserver_typeof(), offsetof(LookUp__LookUpSubscription_type, interface4));
    type->SetFields(0,
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(LookUp__LookUpSubscription, _listener), 0,
        ::g::Fuse::Reactive::LookUp_typeof(), offsetof(LookUp__LookUpSubscription, _lu), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(LookUp__LookUpSubscription, _colSub), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(LookUp__LookUpSubscription, _indexSub), 0,
        ::g::Uno::Bool_typeof(), offsetof(LookUp__LookUpSubscription, _hasCollection), 0,
        uObject_typeof(), offsetof(LookUp__LookUpSubscription, _collection), 0,
        ::g::Uno::Bool_typeof(), offsetof(LookUp__LookUpSubscription, _hasIndex), 0,
        uObject_typeof(), offsetof(LookUp__LookUpSubscription, _index), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(LookUp__LookUpSubscription, _indexForwarder), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(LookUp__LookUpSubscription, _diag), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(LookUp__LookUpSubscription, _colObsObjSub), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(LookUp__LookUpSubscription, _colObservableSub), 0);
}

LookUp__LookUpSubscription_type* LookUp__LookUpSubscription_typeof()
{
    static uSStrong<LookUp__LookUpSubscription_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 12;
    options.InterfaceCount = 5;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(LookUp__LookUpSubscription);
    options.TypeSize = sizeof(LookUp__LookUpSubscription_type);
    type = (LookUp__LookUpSubscription_type*)uClassType::New("Fuse.Reactive.LookUp.LookUpSubscription", options);
    type->fp_build_ = LookUp__LookUpSubscription_build;
    type->interface2.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))LookUp__LookUpSubscription__FuseReactiveIListenerOnNewData_fn;
    type->interface2.fp_OnLostData = (void(*)(uObject*, uObject*))LookUp__LookUpSubscription__FuseReactiveIListenerOnLostData_fn;
    type->interface3.fp_NewValue = (void(*)(uObject*, uObject*))LookUp__LookUpSubscription__FuseReactiveValueForwarderIValueListenerNewValue_fn;
    type->interface3.fp_LostValue = (void(*)(uObject*))LookUp__LookUpSubscription__FuseReactiveValueForwarderIValueListenerLostValue_fn;
    type->interface4.fp_OnPropertyChanged = (void(*)(uObject*, uObject*, uString*, uObject*))LookUp__LookUpSubscription__FuseReactiveIPropertyObserverOnPropertyChanged_fn;
    type->interface1.fp_OnClear = (void(*)(uObject*))LookUp__LookUpSubscription__FuseReactiveIObserverOnClear_fn;
    type->interface1.fp_OnSet = (void(*)(uObject*, uObject*))LookUp__LookUpSubscription__FuseReactiveIObserverOnSet_fn;
    type->interface1.fp_OnAdd = (void(*)(uObject*, uObject*))LookUp__LookUpSubscription__FuseReactiveIObserverOnAdd_fn;
    type->interface1.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))LookUp__LookUpSubscription__FuseReactiveIObserverOnNewAt_fn;
    type->interface1.fp_OnFailed = (void(*)(uObject*, uString*))LookUp__LookUpSubscription__FuseReactiveIObserverOnFailed_fn;
    type->interface1.fp_OnNewAll = (void(*)(uObject*, uObject*))LookUp__LookUpSubscription__FuseReactiveIObserverOnNewAll_fn;
    type->interface1.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))LookUp__LookUpSubscription__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface1.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))LookUp__LookUpSubscription__FuseReactiveIObserverOnInsertAt_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))LookUp__LookUpSubscription__Dispose_fn;
    return type;
}

// public LookUpSubscription(Fuse.Reactive.LookUp lu, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :42
void LookUp__LookUpSubscription__ctor__fn(LookUp__LookUpSubscription* __this, ::g::Fuse::Reactive::LookUp* lu, uObject* context, uObject* listener)
{
    __this->ctor_(lu, context, listener);
}

// public void ClearDiagnostic() :94
void LookUp__LookUpSubscription__ClearDiagnostic_fn(LookUp__LookUpSubscription* __this)
{
    __this->ClearDiagnostic();
}

// public void Dispose() :234
void LookUp__LookUpSubscription__Dispose_fn(LookUp__LookUpSubscription* __this)
{
    __this->Dispose();
}

// private void DisposeCollectionObservableObjectSub() :128
void LookUp__LookUpSubscription__DisposeCollectionObservableObjectSub_fn(LookUp__LookUpSubscription* __this)
{
    __this->DisposeCollectionObservableObjectSub();
}

// private void DisposeCollectionObservableSub() :155
void LookUp__LookUpSubscription__DisposeCollectionObservableSub_fn(LookUp__LookUpSubscription* __this)
{
    __this->DisposeCollectionObservableSub();
}

// private void DisposeIndexSub() :119
void LookUp__LookUpSubscription__DisposeIndexSub_fn(LookUp__LookUpSubscription* __this)
{
    __this->DisposeIndexSub();
}

// private void Fuse.Reactive.IListener.OnLostData(Fuse.Reactive.IExpression source) :62
void LookUp__LookUpSubscription__FuseReactiveIListenerOnLostData_fn(LookUp__LookUpSubscription* __this, uObject* source)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Fuse.Reactive.IListener.OnLostData(Fuse.Reactive.IExpression)");
    ::g::Fuse::Reactive::IListener::OnLostData(uInterface(uPtr(__this->_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)__this->_lu);
}

// private void Fuse.Reactive.IListener.OnNewData(Fuse.Reactive.IExpression source, object value) :55
void LookUp__LookUpSubscription__FuseReactiveIListenerOnNewData_fn(LookUp__LookUpSubscription* __this, uObject* source, uObject* value)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Fuse.Reactive.IListener.OnNewData(Fuse.Reactive.IExpression,object)");

    if (__this->_lu == NULL)
        return;

    if (source == uPtr(__this->_lu)->Index())
        __this->NewIndex(value);

    if (source == uPtr(__this->_lu)->Collection())
        __this->NewCollection(value);
}

// private void Fuse.Reactive.IObserver.OnAdd(object addedValue) :257
void LookUp__LookUpSubscription__FuseReactiveIObserverOnAdd_fn(LookUp__LookUpSubscription* __this, uObject* addedValue)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Fuse.Reactive.IObserver.OnAdd(object)");
    __this->ResultChanged();
}

// private void Fuse.Reactive.IObserver.OnClear() :255
void LookUp__LookUpSubscription__FuseReactiveIObserverOnClear_fn(LookUp__LookUpSubscription* __this)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Fuse.Reactive.IObserver.OnClear()");
    __this->ResultChanged();
}

// private void Fuse.Reactive.IObserver.OnFailed(string message) :259
void LookUp__LookUpSubscription__FuseReactiveIObserverOnFailed_fn(LookUp__LookUpSubscription* __this, uString* message)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Fuse.Reactive.IObserver.OnFailed(string)");
    __this->ResultChanged();
}

// private void Fuse.Reactive.IObserver.OnInsertAt(int index, object value) :262
void LookUp__LookUpSubscription__FuseReactiveIObserverOnInsertAt_fn(LookUp__LookUpSubscription* __this, int32_t* index, uObject* value)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Fuse.Reactive.IObserver.OnInsertAt(int,object)");
    __this->ResultChanged();
}

// private void Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray values) :260
void LookUp__LookUpSubscription__FuseReactiveIObserverOnNewAll_fn(LookUp__LookUpSubscription* __this, uObject* values)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray)");
    __this->ResultChanged();
}

// private void Fuse.Reactive.IObserver.OnNewAt(int index, object value) :258
void LookUp__LookUpSubscription__FuseReactiveIObserverOnNewAt_fn(LookUp__LookUpSubscription* __this, int32_t* index, uObject* value)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Fuse.Reactive.IObserver.OnNewAt(int,object)");
    __this->ResultChanged();
}

// private void Fuse.Reactive.IObserver.OnRemoveAt(int index) :261
void LookUp__LookUpSubscription__FuseReactiveIObserverOnRemoveAt_fn(LookUp__LookUpSubscription* __this, int32_t* index)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Fuse.Reactive.IObserver.OnRemoveAt(int)");
    __this->ResultChanged();
}

// private void Fuse.Reactive.IObserver.OnSet(object newValue) :256
void LookUp__LookUpSubscription__FuseReactiveIObserverOnSet_fn(LookUp__LookUpSubscription* __this, uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Fuse.Reactive.IObserver.OnSet(object)");
    __this->ResultChanged();
}

// private void Fuse.Reactive.IPropertyObserver.OnPropertyChanged(Uno.IDisposable sub, string propertyName, object newValue) :222
void LookUp__LookUpSubscription__FuseReactiveIPropertyObserverOnPropertyChanged_fn(LookUp__LookUpSubscription* __this, uObject* sub, uString* propertyName, uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Fuse.Reactive.IPropertyObserver.OnPropertyChanged(Uno.IDisposable,string,object)");

    if (sub != __this->_colObsObjSub)
        return;

    if (::g::Uno::String::op_Inequality(propertyName, ::g::Uno::Object::ToString(uPtr(__this->_index))))
        return;

    __this->PushNewData(newValue);
}

// private void Fuse.Reactive.ValueForwarder.IValueListener.LostValue() :110
void LookUp__LookUpSubscription__FuseReactiveValueForwarderIValueListenerLostValue_fn(LookUp__LookUpSubscription* __this)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Fuse.Reactive.ValueForwarder.IValueListener.LostValue()");
    __this->_index = NULL;
    __this->_hasIndex = true;
    __this->ResultChanged();
}

// private void Fuse.Reactive.ValueForwarder.IValueListener.NewValue(object value) :103
void LookUp__LookUpSubscription__FuseReactiveValueForwarderIValueListenerNewValue_fn(LookUp__LookUpSubscription* __this, uObject* value)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Fuse.Reactive.ValueForwarder.IValueListener.NewValue(object)");
    __this->_index = value;
    __this->_hasIndex = true;
    __this->ResultChanged();
}

// public LookUpSubscription New(Fuse.Reactive.LookUp lu, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :42
void LookUp__LookUpSubscription__New1_fn(::g::Fuse::Reactive::LookUp* lu, uObject* context, uObject* listener, LookUp__LookUpSubscription** __retval)
{
    *__retval = LookUp__LookUpSubscription::New1(lu, context, listener);
}

// private void NewCollection(object col) :139
void LookUp__LookUpSubscription__NewCollection_fn(LookUp__LookUpSubscription* __this, uObject* col)
{
    __this->NewCollection(col);
}

// private void NewIndex(object ind) :68
void LookUp__LookUpSubscription__NewIndex_fn(LookUp__LookUpSubscription* __this, uObject* ind)
{
    __this->NewIndex(ind);
}

// private void PushNewData(object value) :229
void LookUp__LookUpSubscription__PushNewData_fn(LookUp__LookUpSubscription* __this, uObject* value)
{
    __this->PushNewData(value);
}

// private void ResultChanged() :166
void LookUp__LookUpSubscription__ResultChanged_fn(LookUp__LookUpSubscription* __this)
{
    __this->ResultChanged();
}

// public void SetDiagnostic(string message, Fuse.Reactive.IExpression source) :88
void LookUp__LookUpSubscription__SetDiagnostic_fn(LookUp__LookUpSubscription* __this, uString* message, uObject* source)
{
    __this->SetDiagnostic(message, source);
}

// public LookUpSubscription(Fuse.Reactive.LookUp lu, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) [instance] :42
void LookUp__LookUpSubscription::ctor_(::g::Fuse::Reactive::LookUp* lu, uObject* context, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", ".ctor(Fuse.Reactive.LookUp,Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    _listener = listener;
    _lu = lu;
    _colSub = uPtr(uPtr(_lu)->Collection())->Subscribe(context, (uObject*)this);
    _indexSub = uPtr(uPtr(_lu)->Index())->Subscribe(context, (uObject*)this);
}

// public void ClearDiagnostic() [instance] :94
void LookUp__LookUpSubscription::ClearDiagnostic()
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "ClearDiagnostic()");

    if (_diag != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_diag), ::TYPES[3/*Uno.IDisposable*/]));
        _diag = NULL;
    }
}

// public void Dispose() [instance] :234
void LookUp__LookUpSubscription::Dispose()
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "Dispose()");
    ClearDiagnostic();
    DisposeCollectionObservableObjectSub();
    DisposeCollectionObservableSub();
    DisposeIndexSub();

    if (_colSub != NULL)
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_colSub), ::TYPES[3/*Uno.IDisposable*/]));

    if (_indexSub != NULL)
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_indexSub), ::TYPES[3/*Uno.IDisposable*/]));

    _colSub = NULL;
    _indexSub = NULL;
    _collection = NULL;
    _listener = NULL;
    _index = NULL;
    _lu = NULL;
}

// private void DisposeCollectionObservableObjectSub() [instance] :128
void LookUp__LookUpSubscription::DisposeCollectionObservableObjectSub()
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "DisposeCollectionObservableObjectSub()");

    if (_colObsObjSub != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_colObsObjSub), ::TYPES[3/*Uno.IDisposable*/]));
        _colObsObjSub = NULL;
    }
}

// private void DisposeCollectionObservableSub() [instance] :155
void LookUp__LookUpSubscription::DisposeCollectionObservableSub()
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "DisposeCollectionObservableSub()");

    if (_colObservableSub != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_colObservableSub), ::TYPES[3/*Uno.IDisposable*/]));
        _colObservableSub = NULL;
    }
}

// private void DisposeIndexSub() [instance] :119
void LookUp__LookUpSubscription::DisposeIndexSub()
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "DisposeIndexSub()");

    if (_indexForwarder != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_indexForwarder), ::TYPES[3/*Uno.IDisposable*/]));
        _indexForwarder = NULL;
    }
}

// private void NewCollection(object col) [instance] :139
void LookUp__LookUpSubscription::NewCollection(uObject* col)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "NewCollection(object)");
    _collection = col;
    _hasCollection = true;
    DisposeCollectionObservableObjectSub();
    DisposeCollectionObservableSub();
    uObject* obs = uAs<uObject*>(col, ::TYPES[30/*Fuse.Reactive.IObservableArray*/]);

    if (obs != NULL)
        _colObservableSub = ::g::Fuse::Reactive::IObservableArray::Subscribe(uInterface(uPtr(obs), ::TYPES[30/*Fuse.Reactive.IObservableArray*/]), (uObject*)this);

    ResultChanged();
}

// private void NewIndex(object ind) [instance] :68
void LookUp__LookUpSubscription::NewIndex(uObject* ind)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "NewIndex(object)");
    DisposeIndexSub();
    uObject* obs = uAs<uObject*>(ind, ::TYPES[46/*Fuse.Reactive.IObservable*/]);

    if (obs != NULL)
        _indexForwarder = (uObject*)::g::Fuse::Reactive::ValueForwarder::New1(obs, (uObject*)this);
    else
    {
        _index = ind;
        _hasIndex = true;
        ResultChanged();
    }
}

// private void PushNewData(object value) [instance] :229
void LookUp__LookUpSubscription::PushNewData(uObject* value)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "PushNewData(object)");
    ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_lu, value);
}

// private void ResultChanged() [instance] :166
void LookUp__LookUpSubscription::ResultChanged()
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "ResultChanged()");

    if (_listener == NULL)
        return;

    ClearDiagnostic();

    if (!_hasIndex)
        return;

    if (!_hasCollection)
        return;

    if ((_index == NULL) || (_collection == NULL))
        PushNewData(NULL);

    uObject* arr = uAs<uObject*>(_collection, ::TYPES[28/*Fuse.IArray*/]);

    if (arr != NULL)
    {
        int32_t index = 0;

        try
        {
            {
                index = ::g::Fuse::Marshal::ToInt(_index);
            }
        }

        catch (const uThrowable& __t)
        {
            if (uIs(__t.Exception, ::TYPES[49/*Fuse.MarshalException*/]))
            {
                ::g::Fuse::MarshalException* me = (::g::Fuse::MarshalException*)__t.Exception;
                SetDiagnostic(::g::Uno::String::op_Addition2(::STRINGS[98/*"Index must ...*/], uPtr(me)->Message()), (uObject*)uPtr(_lu)->Index());
                return;
            }
            else             throw __t;
        }

        if ((index >= 0) && (index < ::g::Fuse::IArray::Length(uInterface(uPtr(arr), ::TYPES[28/*Fuse.IArray*/]))))
            PushNewData(::g::Fuse::IArray::Item(uInterface(uPtr(arr), ::TYPES[28/*Fuse.IArray*/]), index));
        else
            SetDiagnostic(::STRINGS[99/*"Index was o...*/], (uObject*)uPtr(_lu)->Index());

        return;
    }

    uObject* obj = uAs<uObject*>(_collection, ::TYPES[50/*Fuse.IObject*/]);

    if (obj != NULL)
    {
        uObject* obsObj = uAs<uObject*>(obj, ::TYPES[35/*Fuse.Reactive.IObservableObject*/]);

        if (obsObj != NULL)
            _colObsObjSub = ::g::Fuse::Reactive::IObservableObject::Subscribe(uInterface(uPtr(obsObj), ::TYPES[35/*Fuse.Reactive.IObservableObject*/]), (uObject*)this);

        uString* key = ::g::Uno::Object::ToString(uPtr(_index));

        if (::g::Fuse::IObject::ContainsKey(uInterface(uPtr(obj), ::TYPES[50/*Fuse.IObject*/]), key))
            PushNewData(::g::Fuse::IObject::Item(uInterface(uPtr(obj), ::TYPES[50/*Fuse.IObject*/]), key));
        else
            SetDiagnostic(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::STRINGS[100/*"Object does...*/], key), ::STRINGS[40/*"'"*/]), (uObject*)uPtr(_lu)->Index());

        return;
    }

    SetDiagnostic(::g::Uno::String::op_Addition1(::STRINGS[101/*"Look-up ope...*/], _collection), (uObject*)uPtr(_lu)->Collection());
}

// public void SetDiagnostic(string message, Fuse.Reactive.IExpression source) [instance] :88
void LookUp__LookUpSubscription::SetDiagnostic(uString* message, uObject* source)
{
    uStackFrame __("Fuse.Reactive.LookUp.LookUpSubscription", "SetDiagnostic(string,Fuse.Reactive.IExpression)");
    ClearDiagnostic();
    _diag = ::g::Fuse::Diagnostics::ReportTemporalUserWarning(message, source);
}

// public LookUpSubscription New(Fuse.Reactive.LookUp lu, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) [static] :42
LookUp__LookUpSubscription* LookUp__LookUpSubscription::New1(::g::Fuse::Reactive::LookUp* lu, uObject* context, uObject* listener)
{
    LookUp__LookUpSubscription* obj1 = (LookUp__LookUpSubscription*)uNew(LookUp__LookUpSubscription_typeof());
    obj1->ctor_(lu, context, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\MatchCase.uno
// ----------------------------------------------------------------------------------------------

// public sealed class Match :29
// {
static void Match_build(uType* type)
{
    ::STRINGS[102] = uString::Const("Not handled: OnAdd");
    ::STRINGS[103] = uString::Const("Not handled: InsertAt");
    ::STRINGS[104] = uString::Const("<Match> can not be used on lists (received OnNewAll)");
    ::STRINGS[105] = uString::Const("Not handled: OnNewAt");
    ::STRINGS[106] = uString::Const("<Match> can not be used on lists (received OnRemoveAt)");
    ::TYPES[51] = ::g::Uno::Collections::List_typeof()->MakeType(::g::Fuse::Node_typeof(), NULL);
    ::TYPES[52] = ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Uno::UX::Template_typeof(), NULL);
    ::TYPES[53] = ::g::Uno::Collections::IEnumerator_typeof();
    ::TYPES[54] = ::g::Uno::Collections::IEnumerator1_typeof()->MakeType(::g::Uno::UX::Template_typeof(), NULL);
    ::TYPES[42] = ::g::Fuse::Node_typeof();
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    ::TYPES[55] = ::g::Fuse::Reactive::IObserver_typeof();
    ::TYPES[28] = ::g::Fuse::IArray_typeof();
    ::TYPES[56] = ::g::Uno::Action1_typeof()->MakeType(::g::Fuse::Reactive::Case_typeof(), NULL);
    ::TYPES[57] = ::g::Uno::Collections::List__Enumerator_typeof()->MakeType(::TYPES[42/*Fuse.Node*/], NULL);
    ::TYPES[58] = ::g::Uno::Collections::IEnumerator1_typeof()->MakeType(::g::Fuse::Reactive::Case_typeof(), NULL);
    ::TYPES[12] = ::g::Uno::Bool_typeof();
    ::TYPES[59] = ::g::Uno::Collections::RootableList_typeof()->MakeType(::g::Fuse::Reactive::Case_typeof(), NULL);
    ::TYPES[20] = ::g::Uno::Int_typeof();
    ::TYPES[14] = ::g::Uno::Double_typeof();
    ::TYPES[1] = ::g::Uno::String_typeof();
    ::TYPES[46] = ::g::Fuse::Reactive::IObservable_typeof();
    ::TYPES[30] = ::g::Fuse::Reactive::IObservableArray_typeof();
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(Match_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(Match_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(Match_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(Match_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(Match_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(Match_type, interface5),
        ::TYPES[55/*Fuse.Reactive.IObserver*/], offsetof(Match_type, interface6));
    type->SetFields(16,
        ::TYPES[59/*Uno.Collections.RootableList<Fuse.Reactive.Case>*/], offsetof(Match, _cases), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(Match, _subscription), 0,
        uObject_typeof(), offsetof(Match, _realValue), 0,
        uObject_typeof(), offsetof(Match, _value), 0,
        ::TYPES[51/*Uno.Collections.List<Fuse.Node>*/], offsetof(Match, _elements), 0,
        ::g::Fuse::Reactive::Case_typeof(), offsetof(Match, _oldCase), 0);
    type->Reflection.SetFunctions(12,
        new uFunction("get_Bool", NULL, (void*)Match__get_Bool_fn, 0, false, ::TYPES[12/*bool*/], 0),
        new uFunction("set_Bool", NULL, (void*)Match__set_Bool_fn, 0, false, uVoid_typeof(), 1, ::TYPES[12/*bool*/]),
        new uFunction("get_Cases", NULL, (void*)Match__get_Cases_fn, 0, false, ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Reactive::Case_typeof(), NULL), 0),
        new uFunction("get_Integer", NULL, (void*)Match__get_Integer_fn, 0, false, ::TYPES[20/*int*/], 0),
        new uFunction("set_Integer", NULL, (void*)Match__set_Integer_fn, 0, false, uVoid_typeof(), 1, ::TYPES[20/*int*/]),
        new uFunction(".ctor", NULL, (void*)Match__New2_fn, 0, true, type, 0),
        new uFunction("get_Number", NULL, (void*)Match__get_Number_fn, 0, false, ::TYPES[14/*double*/], 0),
        new uFunction("set_Number", NULL, (void*)Match__set_Number_fn, 0, false, uVoid_typeof(), 1, ::TYPES[14/*double*/]),
        new uFunction("get_String", NULL, (void*)Match__get_String_fn, 0, false, ::TYPES[1/*string*/], 0),
        new uFunction("set_String", NULL, (void*)Match__set_String_fn, 0, false, uVoid_typeof(), 1, ::TYPES[1/*string*/]),
        new uFunction("get_Value", NULL, (void*)Match__get_Value_fn, 0, false, uObject_typeof(), 0),
        new uFunction("set_Value", NULL, (void*)Match__set_Value_fn, 0, false, uVoid_typeof(), 1, uObject_typeof()));
}

Match_type* Match_typeof()
{
    static uSStrong<Match_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Behavior_typeof();
    options.FieldCount = 22;
    options.InterfaceCount = 7;
    options.ObjectSize = sizeof(Match);
    options.TypeSize = sizeof(Match_type);
    type = (Match_type*)uClassType::New("Fuse.Reactive.Match", options);
    type->fp_build_ = Match_build;
    type->fp_ctor_ = (void*)Match__New2_fn;
    type->fp_GetLastNodeInGroup = (void(*)(::g::Fuse::Node*, ::g::Fuse::Node**))Match__GetLastNodeInGroup_fn;
    type->fp_OnRooted = (void(*)(::g::Fuse::Node*))Match__OnRooted_fn;
    type->fp_OnUnrooted = (void(*)(::g::Fuse::Node*))Match__OnUnrooted_fn;
    type->interface6.fp_OnSet = (void(*)(uObject*, uObject*))Match__FuseReactiveIObserverOnSet_fn;
    type->interface6.fp_OnClear = (void(*)(uObject*))Match__FuseReactiveIObserverOnClear_fn;
    type->interface6.fp_OnAdd = (void(*)(uObject*, uObject*))Match__FuseReactiveIObserverOnAdd_fn;
    type->interface6.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))Match__FuseReactiveIObserverOnNewAt_fn;
    type->interface6.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))Match__FuseReactiveIObserverOnInsertAt_fn;
    type->interface6.fp_OnFailed = (void(*)(uObject*, uString*))Match__FuseReactiveIObserverOnFailed_fn;
    type->interface6.fp_OnNewAll = (void(*)(uObject*, uObject*))Match__FuseReactiveIObserverOnNewAll_fn;
    type->interface6.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))Match__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public generated Match() :29
void Match__ctor_3_fn(Match* __this)
{
    __this->ctor_3();
}

// private void AddElements(Fuse.Reactive.Case c) :241
void Match__AddElements_fn(Match* __this, ::g::Fuse::Reactive::Case* c)
{
    __this->AddElements(c);
}

// public bool get_Bool() :178
void Match__get_Bool_fn(Match* __this, bool* __retval)
{
    *__retval = __this->Bool();
}

// public void set_Bool(bool value) :179
void Match__set_Bool_fn(Match* __this, bool* value)
{
    __this->Bool(*value);
}

// public Uno.Collections.IList<Fuse.Reactive.Case> get_Cases() :38
void Match__get_Cases_fn(Match* __this, uObject** __retval)
{
    *__retval = __this->Cases();
}

// private void Fuse.Reactive.IObserver.OnAdd(object addedValue) :73
void Match__FuseReactiveIObserverOnAdd_fn(Match* __this, uObject* addedValue)
{
    uStackFrame __("Fuse.Reactive.Match", "Fuse.Reactive.IObserver.OnAdd(object)");
    U_THROW(::g::Uno::Exception::New2(::STRINGS[102/*"Not handled...*/]));
}

// private void Fuse.Reactive.IObserver.OnClear() :68
void Match__FuseReactiveIObserverOnClear_fn(Match* __this)
{
}

// private void Fuse.Reactive.IObserver.OnFailed(string message) :88
void Match__FuseReactiveIObserverOnFailed_fn(Match* __this, uString* message)
{
    uStackFrame __("Fuse.Reactive.Match", "Fuse.Reactive.IObserver.OnFailed(string)");
    ::g::Fuse::Reactive::IObserver::OnClear(uInterface(uPtr(uAs<uObject*>(__this, ::TYPES[55/*Fuse.Reactive.IObserver*/])), ::TYPES[55/*Fuse.Reactive.IObserver*/]));
}

// private void Fuse.Reactive.IObserver.OnInsertAt(int index, object value) :83
void Match__FuseReactiveIObserverOnInsertAt_fn(Match* __this, int32_t* index, uObject* value)
{
    uStackFrame __("Fuse.Reactive.Match", "Fuse.Reactive.IObserver.OnInsertAt(int,object)");
    U_THROW(::g::Uno::Exception::New2(::STRINGS[103/*"Not handled...*/]));
}

// private void Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray values) :94
void Match__FuseReactiveIObserverOnNewAll_fn(Match* __this, uObject* values)
{
    uStackFrame __("Fuse.Reactive.Match", "Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray)");

    if (::g::Fuse::IArray::Length(uInterface(uPtr(values), ::TYPES[28/*Fuse.IArray*/])) == 0)
    {
        __this->_realValue = NULL;
        __this->Invalidate();
        return;
    }

    U_THROW(::g::Uno::Exception::New2(::STRINGS[104/*"<Match> can...*/]));
}

// private void Fuse.Reactive.IObserver.OnNewAt(int index, object value) :78
void Match__FuseReactiveIObserverOnNewAt_fn(Match* __this, int32_t* index, uObject* value)
{
    uStackFrame __("Fuse.Reactive.Match", "Fuse.Reactive.IObserver.OnNewAt(int,object)");
    U_THROW(::g::Uno::Exception::New2(::STRINGS[105/*"Not handled...*/]));
}

// private void Fuse.Reactive.IObserver.OnRemoveAt(int index) :106
void Match__FuseReactiveIObserverOnRemoveAt_fn(Match* __this, int32_t* index)
{
    uStackFrame __("Fuse.Reactive.Match", "Fuse.Reactive.IObserver.OnRemoveAt(int)");
    U_THROW(::g::Uno::Exception::New2(::STRINGS[106/*"<Match> can...*/]));
}

// private void Fuse.Reactive.IObserver.OnSet(object newValue) :62
void Match__FuseReactiveIObserverOnSet_fn(Match* __this, uObject* newValue)
{
    __this->_realValue = newValue;
    __this->Invalidate();
}

// internal override sealed Fuse.Node GetLastNodeInGroup() :261
void Match__GetLastNodeInGroup_fn(Match* __this, ::g::Fuse::Node** __retval)
{
    uStackFrame __("Fuse.Reactive.Match", "GetLastNodeInGroup()");
    ::g::Fuse::Node* ret8;

    if (uPtr(__this->_elements)->Count() == 0)
        return *__retval = __this, void();

    return *__retval = (::g::Uno::Collections::List__get_Item_fn(uPtr(__this->_elements), uCRef<int32_t>(uPtr(__this->_elements)->Count() - 1), &ret8), ret8), void();
}

// public int get_Integer() :170
void Match__get_Integer_fn(Match* __this, int32_t* __retval)
{
    *__retval = __this->Integer();
}

// public void set_Integer(int value) :171
void Match__set_Integer_fn(Match* __this, int32_t* value)
{
    __this->Integer(*value);
}

// internal void Invalidate() :200
void Match__Invalidate_fn(Match* __this)
{
    __this->Invalidate();
}

// public generated Match New() :29
void Match__New2_fn(Match** __retval)
{
    *__retval = Match::New2();
}

// public double get_Number() :162
void Match__get_Number_fn(Match* __this, double* __retval)
{
    *__retval = __this->Number();
}

// public void set_Number(double value) :163
void Match__set_Number_fn(Match* __this, double* value)
{
    __this->Number(*value);
}

// private void OnCaseAdded(Fuse.Reactive.Case c) :50
void Match__OnCaseAdded_fn(Match* __this, ::g::Fuse::Reactive::Case* c)
{
    __this->OnCaseAdded(c);
}

// private void OnCaseRemoved(Fuse.Reactive.Case c) :56
void Match__OnCaseRemoved_fn(Match* __this, ::g::Fuse::Reactive::Case* c)
{
    __this->OnCaseRemoved(c);
}

// protected override sealed void OnRooted() :182
void Match__OnRooted_fn(Match* __this)
{
    uStackFrame __("Fuse.Reactive.Match", "OnRooted()");
    ::g::Fuse::Node__OnRooted_fn(__this);
    uPtr(__this->_cases)->RootSubscribe(uDelegate::New(::TYPES[56/*Uno.Action<Fuse.Reactive.Case>*/], (void*)Match__OnCaseAdded_fn, __this), uDelegate::New(::TYPES[56/*Uno.Action<Fuse.Reactive.Case>*/], (void*)Match__OnCaseRemoved_fn, __this));
    __this->Update();
}

// protected override sealed void OnUnrooted() :189
void Match__OnUnrooted_fn(Match* __this)
{
    uStackFrame __("Fuse.Reactive.Match", "OnUnrooted()");
    __this->RemoveElements();
    uPtr(__this->_cases)->RootUnsubscribe();
    ::g::Fuse::Node__OnUnrooted_fn(__this);
}

// private void RemoveElements() :229
void Match__RemoveElements_fn(Match* __this)
{
    __this->RemoveElements();
}

// private Fuse.Reactive.Case SelectCase() :218
void Match__SelectCase_fn(Match* __this, ::g::Fuse::Reactive::Case** __retval)
{
    *__retval = __this->SelectCase();
}

// public string get_String() :154
void Match__get_String_fn(Match* __this, uString** __retval)
{
    *__retval = __this->String();
}

// public void set_String(string value) :155
void Match__set_String_fn(Match* __this, uString* value)
{
    __this->String(value);
}

// private void Update() :207
void Match__Update_fn(Match* __this)
{
    __this->Update();
}

// public object get_Value() :119
void Match__get_Value_fn(Match* __this, uObject** __retval)
{
    *__retval = __this->Value();
}

// public void set_Value(object value) :120
void Match__set_Value_fn(Match* __this, uObject* value)
{
    __this->Value(value);
}

// public generated Match() [instance] :29
void Match::ctor_3()
{
    _elements = ((::g::Uno::Collections::List*)::g::Uno::Collections::List::New1(::TYPES[51/*Uno.Collections.List<Fuse.Node>*/]));
    ctor_2();
}

// private void AddElements(Fuse.Reactive.Case c) [instance] :241
void Match::AddElements(::g::Fuse::Reactive::Case* c)
{
    uStackFrame __("Fuse.Reactive.Match", "AddElements(Fuse.Reactive.Case)");
    ::g::Fuse::Node* ind4;
    ::g::Uno::UX::Template* ret6;
    ::g::Uno::Collections::List__Enumerator<uStrong< ::g::Fuse::Node*> > ret7;

    if (c != NULL)
    {
        uObject* enum3 = (uObject*)::g::Uno::Collections::IEnumerable::GetEnumerator(uInterface(uPtr(uPtr(c)->Factories()), ::TYPES[52/*Uno.Collections.IEnumerable<Uno.UX.Template>*/]));

        {
            try
            {
                {
                    while (::g::Uno::Collections::IEnumerator::MoveNext(uInterface(uPtr(enum3), ::TYPES[53/*Uno.Collections.IEnumerator*/])))
                    {
                        ::g::Uno::UX::Template* f = (::g::Uno::Collections::IEnumerator1::get_Current_ex(uInterface(uPtr(enum3), ::TYPES[54/*Uno.Collections.IEnumerator<Uno.UX.Template>*/]), &ret6), ret6);
                        ::g::Fuse::Node* elm = uAs< ::g::Fuse::Node*>(uPtr(f)->New1(), ::TYPES[42/*Fuse.Node*/]);

                        if (elm != NULL)
                        {
                            uPtr(elm)->OverrideContextParent = (ind4 = uPtr(elm)->OverrideContextParent, ((ind4 != NULL) ? ind4 : this));
                            ::g::Uno::Collections::List__Add_fn(uPtr(_elements), elm);
                        }
                    }
                }
            }

            catch (const uThrowable& __t)
            {
                {
                    ::g::Uno::IDisposable::Dispose(uInterface(uPtr(enum3), ::TYPES[3/*Uno.IDisposable*/]));
                }
                                throw __t;
                goto __after_finally_3;
            }

            {
                ::g::Uno::IDisposable::Dispose(uInterface(uPtr(enum3), ::TYPES[3/*Uno.IDisposable*/]));
            }
            __after_finally_3:;
        }

        uPtr(Parent())->InsertNodesAfter(this, uBox(::TYPES[57/*Uno.Collections.List<Fuse.Node>.Enumerator*/], (::g::Uno::Collections::List__GetEnumerator_fn(uPtr(_elements), &ret7), ret7)));
    }

    _oldCase = c;
}

// public bool get_Bool() [instance] :178
bool Match::Bool()
{
    uStackFrame __("Fuse.Reactive.Match", "get_Bool()");
    return uIs((uObject*)Value(), ::TYPES[12/*bool*/]) ? uUnbox<bool>(::TYPES[12/*bool*/], Value()) : false;
}

// public void set_Bool(bool value) [instance] :179
void Match::Bool(bool value)
{
    uStackFrame __("Fuse.Reactive.Match", "set_Bool(bool)");
    Value(uBox(::TYPES[12/*bool*/], value));
}

// public Uno.Collections.IList<Fuse.Reactive.Case> get_Cases() [instance] :38
uObject* Match::Cases()
{
    uStackFrame __("Fuse.Reactive.Match", "get_Cases()");

    if (_cases == NULL)
    {
        _cases = ((::g::Uno::Collections::RootableList*)::g::Uno::Collections::RootableList::New1(::TYPES[59/*Uno.Collections.RootableList<Fuse.Reactive.Case>*/]));

        if (IsRootingCompleted())
            uPtr(_cases)->Subscribe(uDelegate::New(::TYPES[56/*Uno.Action<Fuse.Reactive.Case>*/], (void*)Match__OnCaseAdded_fn, this), uDelegate::New(::TYPES[56/*Uno.Action<Fuse.Reactive.Case>*/], (void*)Match__OnCaseRemoved_fn, this));
    }

    return (uObject*)_cases;
}

// public int get_Integer() [instance] :170
int32_t Match::Integer()
{
    uStackFrame __("Fuse.Reactive.Match", "get_Integer()");
    return uIs((uObject*)Value(), ::TYPES[20/*int*/]) ? uUnbox<int32_t>(::TYPES[20/*int*/], Value()) : 0;
}

// public void set_Integer(int value) [instance] :171
void Match::Integer(int32_t value)
{
    uStackFrame __("Fuse.Reactive.Match", "set_Integer(int)");
    Value(uBox<int32_t>(::TYPES[20/*int*/], value));
}

// internal void Invalidate() [instance] :200
void Match::Invalidate()
{
    if (!IsRootingCompleted())
        return;

    Update();
}

// public double get_Number() [instance] :162
double Match::Number()
{
    uStackFrame __("Fuse.Reactive.Match", "get_Number()");
    return uIs((uObject*)Value(), ::TYPES[14/*double*/]) ? uUnbox<double>(::TYPES[14/*double*/], Value()) : 0.0;
}

// public void set_Number(double value) [instance] :163
void Match::Number(double value)
{
    uStackFrame __("Fuse.Reactive.Match", "set_Number(double)");
    Value(uBox(::TYPES[14/*double*/], value));
}

// private void OnCaseAdded(Fuse.Reactive.Case c) [instance] :50
void Match::OnCaseAdded(::g::Fuse::Reactive::Case* c)
{
    uStackFrame __("Fuse.Reactive.Match", "OnCaseAdded(Fuse.Reactive.Case)");
    uPtr(c)->Root(this);
    Invalidate();
}

// private void OnCaseRemoved(Fuse.Reactive.Case c) [instance] :56
void Match::OnCaseRemoved(::g::Fuse::Reactive::Case* c)
{
    uStackFrame __("Fuse.Reactive.Match", "OnCaseRemoved(Fuse.Reactive.Case)");
    uPtr(c)->Unroot();
    Invalidate();
}

// private void RemoveElements() [instance] :229
void Match::RemoveElements()
{
    uStackFrame __("Fuse.Reactive.Match", "RemoveElements()");
    ::g::Uno::Collections::List__Enumerator<uStrong< ::g::Fuse::Node*> > ret9;
    _oldCase = NULL;
    ::g::Uno::Collections::List__Enumerator<uStrong< ::g::Fuse::Node*> > enum2 = (::g::Uno::Collections::List__GetEnumerator_fn(uPtr(_elements), &ret9), ret9);

    {
        try
        {
            {
                while (enum2.MoveNext(::TYPES[57/*Uno.Collections.List<Fuse.Node>.Enumerator*/]))
                {
                    ::g::Fuse::Node* e = enum2.Current(::TYPES[57/*Uno.Collections.List<Fuse.Node>.Enumerator*/]);

                    if (uPtr(e)->OverrideContextParent == this)
                        uPtr(e)->OverrideContextParent = NULL;

                    uPtr(Parent())->BeginRemoveChild(e, NULL);
                }
            }
        }

        catch (const uThrowable& __t)
        {
            {
                enum2.Dispose(::TYPES[57/*Uno.Collections.List<Fuse.Node>.Enumerator*/]);
            }
                        throw __t;
            goto __after_finally_4;
        }

        {
            enum2.Dispose(::TYPES[57/*Uno.Collections.List<Fuse.Node>.Enumerator*/]);
        }
        __after_finally_4:;
    }

    uPtr(_elements)->Clear();
}

// private Fuse.Reactive.Case SelectCase() [instance] :218
::g::Fuse::Reactive::Case* Match::SelectCase()
{
    uStackFrame __("Fuse.Reactive.Match", "SelectCase()");
    ::g::Fuse::Reactive::Case* ret10;
    ::g::Fuse::Reactive::Case* def = NULL;
    uObject* enum1 = (uObject*)uPtr(_cases)->GetEnumerator();

    {
        try
        {
            {
                while (::g::Uno::Collections::IEnumerator::MoveNext(uInterface(uPtr(enum1), ::TYPES[53/*Uno.Collections.IEnumerator*/])))
                {
                    ::g::Fuse::Reactive::Case* c = (::g::Uno::Collections::IEnumerator1::get_Current_ex(uInterface(uPtr(enum1), ::TYPES[58/*Uno.Collections.IEnumerator<Fuse.Reactive.Case>*/]), &ret10), ret10);

                    if ((uPtr(c)->Value() != NULL) && ::g::Uno::Object::Equals(uPtr(uPtr(c)->Value()), _realValue))
                    {
                        ::g::Fuse::Reactive::Case* __uno_retval = c;
                        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(enum1), ::TYPES[3/*Uno.IDisposable*/]));
                        return __uno_retval;
                    }

                    if (uPtr(c)->IsDefault())
                        def = c;
                }
            }
        }

        catch (const uThrowable& __t)
        {
            {
                ::g::Uno::IDisposable::Dispose(uInterface(uPtr(enum1), ::TYPES[3/*Uno.IDisposable*/]));
            }
                        throw __t;
            goto __after_finally_5;
        }

        {
            ::g::Uno::IDisposable::Dispose(uInterface(uPtr(enum1), ::TYPES[3/*Uno.IDisposable*/]));
        }
        __after_finally_5:;
    }

    return def;
}

// public string get_String() [instance] :154
uString* Match::String()
{
    return uAs<uString*>(Value(), ::TYPES[1/*string*/]);
}

// public void set_String(string value) [instance] :155
void Match::String(uString* value)
{
    uStackFrame __("Fuse.Reactive.Match", "set_String(string)");
    Value(value);
}

// private void Update() [instance] :207
void Match::Update()
{
    uStackFrame __("Fuse.Reactive.Match", "Update()");
    ::g::Fuse::Reactive::Case* newCase = SelectCase();

    if (newCase != _oldCase)
    {
        RemoveElements();

        if (newCase != NULL)
            AddElements(newCase);
    }
}

// public object get_Value() [instance] :119
uObject* Match::Value()
{
    return _value;
}

// public void set_Value(object value) [instance] :120
void Match::Value(uObject* value)
{
    uStackFrame __("Fuse.Reactive.Match", "set_Value(object)");

    if (_value != value)
    {
        _value = value;

        if (_subscription != NULL)
        {
            ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_subscription), ::TYPES[3/*Uno.IDisposable*/]));
            _subscription = NULL;
        }

        if (uIs((uObject*)_value, ::TYPES[46/*Fuse.Reactive.IObservable*/]))
        {
            uObject* obs = (uObject*)_value;

            if (::g::Fuse::IArray::Length(uInterface(uPtr(obs), ::TYPES[28/*Fuse.IArray*/])) > 0)
                _realValue = ::g::Fuse::IArray::Item(uInterface(uPtr(obs), ::TYPES[28/*Fuse.IArray*/]), 0);

            _subscription = ::g::Fuse::Reactive::IObservableArray::Subscribe(uInterface(uPtr(obs), ::TYPES[30/*Fuse.Reactive.IObservableArray*/]), (uObject*)this);
        }
        else
            _realValue = _value;

        Invalidate();
    }
}

// public generated Match New() [static] :29
Match* Match::New2()
{
    Match* obj5 = (Match*)uNew(Match_typeof());
    obj5->ctor_3();
    return obj5;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Max :20
// {
static void Max_build(uType* type)
{
    ::STRINGS[107] = uString::Const("max");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Max__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* Max_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::BinaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(Max);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.Max", options);
    type->fp_build_ = Max_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))Max__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Max(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :23
void Max__ctor_4_fn(Max* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_4(left, right);
}

// public Max New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :23
void Max__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, Max** __retval)
{
    *__retval = Max::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :26
void Max__TryCompute1_fn(Max* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    return *__retval = ::g::Fuse::Marshal::TryMax(left, right, result), void();
}

// public Max(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :23
void Max::ctor_4(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    uStackFrame __("Fuse.Reactive.Max", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression)");
    ctor_3(left, right, ::STRINGS[107/*"max"*/], 0);
}

// public Max New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :23
Max* Max::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    Max* obj1 = (Max*)uNew(Max_typeof());
    obj1->ctor_4(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Member.uno
// ----------------------------------------------------------------------------------------------

// public sealed class Member :8
// {
static void Member_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->SetFields(0,
        ::g::Fuse::Reactive::Expression_typeof(), offsetof(Member, _BaseObject), 0,
        ::g::Uno::String_typeof(), offsetof(Member, _Name), 0);
    type->Reflection.SetFunctions(2,
        new uFunction("get_Name", NULL, (void*)Member__get_Name_fn, 0, false, ::g::Uno::String_typeof(), 0),
        new uFunction(".ctor", NULL, (void*)Member__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Uno::String_typeof()));
}

::g::Fuse::Reactive::Expression_type* Member_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.FieldCount = 2;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Member);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.Member", options);
    type->fp_build_ = Member_build;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))Member__Subscribe_fn;
    type->fp_ToString = (void(*)(uObject*, uString**))Member__ToString_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))Member__Subscribe_fn;
    return type;
}

// public Member(Fuse.Reactive.Expression obj, string name) :14
void Member__ctor_1_fn(Member* __this, ::g::Fuse::Reactive::Expression* obj, uString* name)
{
    __this->ctor_1(obj, name);
}

// private generated Fuse.Reactive.Expression get_BaseObject() :10
void Member__get_BaseObject_fn(Member* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->BaseObject();
}

// private generated void set_BaseObject(Fuse.Reactive.Expression value) :10
void Member__set_BaseObject_fn(Member* __this, ::g::Fuse::Reactive::Expression* value)
{
    __this->BaseObject(value);
}

// public generated string get_Name() :11
void Member__get_Name_fn(Member* __this, uString** __retval)
{
    *__retval = __this->Name();
}

// private generated void set_Name(string value) :11
void Member__set_Name_fn(Member* __this, uString* value)
{
    __this->Name(value);
}

// public Member New(Fuse.Reactive.Expression obj, string name) :14
void Member__New1_fn(::g::Fuse::Reactive::Expression* obj, uString* name, Member** __retval)
{
    *__retval = Member::New1(obj, name);
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :25
void Member__Subscribe_fn(Member* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.Member", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    return *__retval = (uObject*)Member__Subscription::New1(__this, context, listener), void();
}

// public override sealed string ToString() :20
void Member__ToString_fn(Member* __this, uString** __retval)
{
    uStackFrame __("Fuse.Reactive.Member", "ToString()");
    return *__retval = ::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::g::Uno::Object::ToString(uPtr(__this->BaseObject())), ::STRINGS[47/*"."*/]), __this->Name()), void();
}

// public Member(Fuse.Reactive.Expression obj, string name) [instance] :14
void Member::ctor_1(::g::Fuse::Reactive::Expression* obj, uString* name)
{
    ctor_();
    BaseObject(obj);
    Name(name);
}

// private generated Fuse.Reactive.Expression get_BaseObject() [instance] :10
::g::Fuse::Reactive::Expression* Member::BaseObject()
{
    return _BaseObject;
}

// private generated void set_BaseObject(Fuse.Reactive.Expression value) [instance] :10
void Member::BaseObject(::g::Fuse::Reactive::Expression* value)
{
    _BaseObject = value;
}

// public generated string get_Name() [instance] :11
uString* Member::Name()
{
    return _Name;
}

// private generated void set_Name(string value) [instance] :11
void Member::Name(uString* value)
{
    _Name = value;
}

// public Member New(Fuse.Reactive.Expression obj, string name) [static] :14
Member* Member::New1(::g::Fuse::Reactive::Expression* obj, uString* name)
{
    Member* obj1 = (Member*)uNew(Member_typeof());
    obj1->ctor_1(obj, name);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Min :7
// {
static void Min_build(uType* type)
{
    ::STRINGS[108] = uString::Const("min");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Min__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* Min_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::BinaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(Min);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.Min", options);
    type->fp_build_ = Min_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))Min__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Min(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :10
void Min__ctor_4_fn(Min* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_4(left, right);
}

// public Min New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :10
void Min__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, Min** __retval)
{
    *__retval = Min::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :13
void Min__TryCompute1_fn(Min* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    return *__retval = ::g::Fuse::Marshal::TryMin(left, right, result), void();
}

// public Min(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :10
void Min::ctor_4(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    uStackFrame __("Fuse.Reactive.Min", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression)");
    ctor_3(left, right, ::STRINGS[108/*"min"*/], 0);
}

// public Min New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :10
Min* Min::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    Min* obj1 = (Min*)uNew(Min_typeof());
    obj1->ctor_4(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Mod :33
// {
static void Mod_build(uType* type)
{
    ::STRINGS[109] = uString::Const("mod");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Mod__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* Mod_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::BinaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(Mod);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.Mod", options);
    type->fp_build_ = Mod_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))Mod__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Mod(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :36
void Mod__ctor_4_fn(Mod* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_4(left, right);
}

// public Mod New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :36
void Mod__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, Mod** __retval)
{
    *__retval = Mod::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :39
void Mod__TryCompute1_fn(Mod* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.Mod", "TryCompute(object,object,object&)");
    *result = uBox(::TYPES[21/*float*/], ::g::Uno::Math::Mod1(::g::Fuse::Marshal::ToFloat(left), ::g::Fuse::Marshal::ToFloat(right)));
    return *__retval = true, void();
}

// public Mod(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :36
void Mod::ctor_4(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    uStackFrame __("Fuse.Reactive.Mod", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression)");
    ctor_3(left, right, ::STRINGS[109/*"mod"*/], 0);
}

// public Mod New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :36
Mod* Mod::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    Mod* obj1 = (Mod*)uNew(Mod_typeof());
    obj1->ctor_4(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class Multiply :76
// {
static void Multiply_build(uType* type)
{
    ::STRINGS[110] = uString::Const("*");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Multiply__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* Multiply_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InfixOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(Multiply);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.Multiply", options);
    type->fp_build_ = Multiply_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))Multiply__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Multiply(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :79
void Multiply__ctor_6_fn(Multiply* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_6(left, right);
}

// public Multiply New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :79
void Multiply__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, Multiply** __retval)
{
    *__retval = Multiply::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :81
void Multiply__TryCompute1_fn(Multiply* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    return *__retval = ::g::Fuse::Marshal::TryMultiply(left, right, result), void();
}

// public Multiply(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :79
void Multiply::ctor_6(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    uStackFrame __("Fuse.Reactive.Multiply", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression)");
    ctor_5(left, right, ::STRINGS[110/*"*"*/], 0);
}

// public Multiply New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :79
Multiply* Multiply::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    Multiply* obj1 = (Multiply*)uNew(Multiply_typeof());
    obj1->ctor_6(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\VarArgFunction.uno
// ------------------------------------------------------------------------------------------------------

// public sealed class NamedFunctionCall :176
// {
static void NamedFunctionCall_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::SimpleVarArgFunction_type, interface0));
    type->SetFields(1,
        ::g::Uno::String_typeof(), offsetof(NamedFunctionCall, _Name), 0);
    type->Reflection.SetFunctions(2,
        new uFunction("get_Name", NULL, (void*)NamedFunctionCall__get_Name_fn, 0, false, ::g::Uno::String_typeof(), 0),
        new uFunction(".ctor", NULL, (void*)NamedFunctionCall__New1_fn, 0, true, type, 1, ::g::Uno::String_typeof()));
}

::g::Fuse::Reactive::SimpleVarArgFunction_type* NamedFunctionCall_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::SimpleVarArgFunction_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::SimpleVarArgFunction_typeof();
    options.FieldCount = 2;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(NamedFunctionCall);
    options.TypeSize = sizeof(::g::Fuse::Reactive::SimpleVarArgFunction_type);
    type = (::g::Fuse::Reactive::SimpleVarArgFunction_type*)uClassType::New("Fuse.Reactive.NamedFunctionCall", options);
    type->fp_build_ = NamedFunctionCall_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::SimpleVarArgFunction__Subscribe_fn;
    return type;
}

// public NamedFunctionCall(string name) :180
void NamedFunctionCall__ctor_3_fn(NamedFunctionCall* __this, uString* name)
{
    __this->ctor_3(name);
}

// public generated string get_Name() :178
void NamedFunctionCall__get_Name_fn(NamedFunctionCall* __this, uString** __retval)
{
    *__retval = __this->Name();
}

// private generated void set_Name(string value) :178
void NamedFunctionCall__set_Name_fn(NamedFunctionCall* __this, uString* value)
{
    __this->Name(value);
}

// public NamedFunctionCall New(string name) :180
void NamedFunctionCall__New1_fn(uString* name, NamedFunctionCall** __retval)
{
    *__retval = NamedFunctionCall::New1(name);
}

// public NamedFunctionCall(string name) [instance] :180
void NamedFunctionCall::ctor_3(uString* name)
{
    ctor_2();
    Name(name);
}

// public generated string get_Name() [instance] :178
uString* NamedFunctionCall::Name()
{
    return _Name;
}

// private generated void set_Name(string value) [instance] :178
void NamedFunctionCall::Name(uString* value)
{
    _Name = value;
}

// public NamedFunctionCall New(string name) [static] :180
NamedFunctionCall* NamedFunctionCall::New1(uString* name)
{
    NamedFunctionCall* obj1 = (NamedFunctionCall*)uNew(NamedFunctionCall_typeof());
    obj1->ctor_3(name);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\NameValuePair.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class NameValuePair :6
// {
static void NameValuePair_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)NameValuePair__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* NameValuePair_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::BinaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(NameValuePair);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.NameValuePair", options);
    type->fp_build_ = NameValuePair_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))NameValuePair__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public NameValuePair(Fuse.Reactive.Expression name, Fuse.Reactive.Expression value) :9
void NameValuePair__ctor_4_fn(NameValuePair* __this, ::g::Fuse::Reactive::Expression* name, ::g::Fuse::Reactive::Expression* value)
{
    __this->ctor_4(name, value);
}

// public NameValuePair New(Fuse.Reactive.Expression name, Fuse.Reactive.Expression value) :9
void NameValuePair__New1_fn(::g::Fuse::Reactive::Expression* name, ::g::Fuse::Reactive::Expression* value, NameValuePair** __retval)
{
    *__retval = NameValuePair::New1(name, value);
}

// protected override sealed bool TryCompute(object name, object value, object& result) :13
void NameValuePair__TryCompute1_fn(NameValuePair* __this, uObject* name, uObject* value, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.NameValuePair", "TryCompute(object,object,object&)");
    *result = ::g::Fuse::NameValuePair::New1(::g::Uno::Object::ToString(uPtr(name)), value);
    return *__retval = true, void();
}

// public NameValuePair(Fuse.Reactive.Expression name, Fuse.Reactive.Expression value) [instance] :9
void NameValuePair::ctor_4(::g::Fuse::Reactive::Expression* name, ::g::Fuse::Reactive::Expression* value)
{
    uStackFrame __("Fuse.Reactive.NameValuePair", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression)");
    ctor_2(name, value, 0);
}

// public NameValuePair New(Fuse.Reactive.Expression name, Fuse.Reactive.Expression value) [static] :9
NameValuePair* NameValuePair::New1(::g::Fuse::Reactive::Expression* name, ::g::Fuse::Reactive::Expression* value)
{
    NameValuePair* obj1 = (NameValuePair*)uNew(NameValuePair_typeof());
    obj1->ctor_4(name, value);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\UnaryOperator.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Negate :71
// {
static void Negate_build(uType* type)
{
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Negate__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Negate_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(Negate);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Negate", options);
    type->fp_build_ = Negate_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::UnaryOperator*, uObject*, uObject**, bool*))Negate__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Negate(Fuse.Reactive.Expression operand) :74
void Negate__ctor_4_fn(Negate* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_4(operand);
}

// public Negate New(Fuse.Reactive.Expression operand) :74
void Negate__New1_fn(::g::Fuse::Reactive::Expression* operand, Negate** __retval)
{
    *__retval = Negate::New1(operand);
}

// protected override sealed bool TryCompute(object operand, object& result) :75
void Negate__TryCompute1_fn(Negate* __this, uObject* operand, uObject** result, bool* __retval)
{
    return *__retval = ::g::Fuse::Marshal::TryMultiply(operand, uBox<int32_t>(::TYPES[20/*int*/], -1), result), void();
}

// public Negate(Fuse.Reactive.Expression operand) [instance] :74
void Negate::ctor_4(::g::Fuse::Reactive::Expression* operand)
{
    ctor_2(operand, 0);
}

// public Negate New(Fuse.Reactive.Expression operand) [static] :74
Negate* Negate::New1(::g::Fuse::Reactive::Expression* operand)
{
    Negate* obj1 = (Negate*)uNew(Negate_typeof());
    obj1->ctor_4(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Instantiator.uno
// -------------------------------------------------------------------------------------------------

// internal sealed class Instantiator.NoContextItem :399
// {
static void Instantiator__NoContextItem_build(uType* type)
{
}

uType* Instantiator__NoContextItem_typeof()
{
    static uSStrong<uType*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.ObjectSize = sizeof(Instantiator__NoContextItem);
    options.TypeSize = sizeof(uType);
    type = uClassType::New("Fuse.Reactive.Instantiator.NoContextItem", options);
    type->fp_build_ = Instantiator__NoContextItem_build;
    type->fp_ctor_ = (void*)Instantiator__NoContextItem__New1_fn;
    return type;
}

// public generated NoContextItem() :399
void Instantiator__NoContextItem__ctor__fn(Instantiator__NoContextItem* __this)
{
    __this->ctor_();
}

// public generated NoContextItem New() :399
void Instantiator__NoContextItem__New1_fn(Instantiator__NoContextItem** __retval)
{
    *__retval = Instantiator__NoContextItem::New1();
}

// public generated NoContextItem() [instance] :399
void Instantiator__NoContextItem::ctor_()
{
}

// public generated NoContextItem New() [static] :399
Instantiator__NoContextItem* Instantiator__NoContextItem::New1()
{
    Instantiator__NoContextItem* obj1 = (Instantiator__NoContextItem*)uNew(Instantiator__NoContextItem_typeof());
    obj1->ctor_();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\NodeExpressionBinding.uno
// ----------------------------------------------------------------------------------------------------------

// internal sealed class NodeExpressionBinding :9
// {
static void NodeExpressionBinding_build(uType* type)
{
    ::STRINGS[111] = uString::Const("Invalid params");
    ::STRINGS[69] = uString::Const("The binding type does not support resource subscriptions");
    ::TYPES[37] = ::g::Uno::Action_typeof();
    ::TYPES[38] = ::g::Fuse::Reactive::IExpression_typeof();
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    type->SetDependencies(
        ::g::Fuse::UpdateManager_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IContext_typeof(), offsetof(NodeExpressionBinding_type, interface0),
        ::TYPES[3/*Uno.IDisposable*/], offsetof(NodeExpressionBinding_type, interface1));
    type->SetFields(0,
        ::TYPES[38/*Fuse.Reactive.IExpression*/], offsetof(NodeExpressionBinding, _expr), 0,
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(NodeExpressionBinding, _listener), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(NodeExpressionBinding, _sub), 0,
        ::g::Fuse::Node_typeof(), offsetof(NodeExpressionBinding, _node), 0);
}

NodeExpressionBinding_type* NodeExpressionBinding_typeof()
{
    static uSStrong<NodeExpressionBinding_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 4;
    options.InterfaceCount = 2;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(NodeExpressionBinding);
    options.TypeSize = sizeof(NodeExpressionBinding_type);
    type = (NodeExpressionBinding_type*)uClassType::New("Fuse.Reactive.NodeExpressionBinding", options);
    type->fp_build_ = NodeExpressionBinding_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))NodeExpressionBinding__FuseReactiveIContextSubscribe_fn;
    type->interface0.fp_get_Node = (void(*)(uObject*, ::g::Fuse::Node**))NodeExpressionBinding__FuseReactiveIContextget_Node_fn;
    type->interface0.fp_SubscribeResource = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))NodeExpressionBinding__SubscribeResource_fn;
    type->interface1.fp_Dispose = (void(*)(uObject*))NodeExpressionBinding__Dispose_fn;
    return type;
}

// public NodeExpressionBinding(Fuse.Reactive.IExpression expr, Fuse.Node node, Fuse.Reactive.IListener listener) :16
void NodeExpressionBinding__ctor__fn(NodeExpressionBinding* __this, uObject* expr, ::g::Fuse::Node* node, uObject* listener)
{
    __this->ctor_(expr, node, listener);
}

// private void CompleteInit() :28
void NodeExpressionBinding__CompleteInit_fn(NodeExpressionBinding* __this)
{
    __this->CompleteInit();
}

// public void Dispose() :48
void NodeExpressionBinding__Dispose_fn(NodeExpressionBinding* __this)
{
    __this->Dispose();
}

// private Fuse.Node Fuse.Reactive.IContext.get_Node() :41
void NodeExpressionBinding__FuseReactiveIContextget_Node_fn(NodeExpressionBinding* __this, ::g::Fuse::Node** __retval)
{
    return *__retval = __this->_node, void();
}

// private Uno.IDisposable Fuse.Reactive.IContext.Subscribe(Fuse.Reactive.IExpression source, string key, Fuse.Reactive.IListener listener) :36
void NodeExpressionBinding__FuseReactiveIContextSubscribe_fn(NodeExpressionBinding* __this, uObject* source, uString* key, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.NodeExpressionBinding", "Fuse.Reactive.IContext.Subscribe(Fuse.Reactive.IExpression,string,Fuse.Reactive.IListener)");
    return *__retval = (uObject*)::g::Fuse::Reactive::DataSubscription::New1(source, __this->_node, key, listener), void();
}

// public NodeExpressionBinding New(Fuse.Reactive.IExpression expr, Fuse.Node node, Fuse.Reactive.IListener listener) :16
void NodeExpressionBinding__New1_fn(uObject* expr, ::g::Fuse::Node* node, uObject* listener, NodeExpressionBinding** __retval)
{
    *__retval = NodeExpressionBinding::New1(expr, node, listener);
}

// public Uno.IDisposable SubscribeResource(Fuse.Reactive.IExpression source, string key, Fuse.Reactive.IListener listener) :43
void NodeExpressionBinding__SubscribeResource_fn(NodeExpressionBinding* __this, uObject* source, uString* key, uObject* listener, uObject** __retval)
{
    *__retval = __this->SubscribeResource(source, key, listener);
}

// public NodeExpressionBinding(Fuse.Reactive.IExpression expr, Fuse.Node node, Fuse.Reactive.IListener listener) [instance] :16
void NodeExpressionBinding::ctor_(uObject* expr, ::g::Fuse::Node* node, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.NodeExpressionBinding", ".ctor(Fuse.Reactive.IExpression,Fuse.Node,Fuse.Reactive.IListener)");

    if (((expr == NULL) || (node == NULL)) || (listener == NULL))
        U_THROW(::g::Uno::Exception::New2(::STRINGS[111/*"Invalid par...*/]));

    _expr = expr;
    _listener = listener;
    _node = node;
    ::g::Fuse::UpdateManager::AddDeferredAction2(uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)NodeExpressionBinding__CompleteInit_fn, this), -1, 2);
}

// private void CompleteInit() [instance] :28
void NodeExpressionBinding::CompleteInit()
{
    uStackFrame __("Fuse.Reactive.NodeExpressionBinding", "CompleteInit()");

    if (_expr == NULL)
        return;

    _sub = ::g::Fuse::Reactive::IExpression::Subscribe(uInterface(uPtr(_expr), ::TYPES[38/*Fuse.Reactive.IExpression*/]), (uObject*)this, _listener);
}

// public void Dispose() [instance] :48
void NodeExpressionBinding::Dispose()
{
    uStackFrame __("Fuse.Reactive.NodeExpressionBinding", "Dispose()");

    if (_sub != NULL)
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_sub), ::TYPES[3/*Uno.IDisposable*/]));

    _expr = NULL;
    _listener = NULL;
    _node = NULL;
}

// public Uno.IDisposable SubscribeResource(Fuse.Reactive.IExpression source, string key, Fuse.Reactive.IListener listener) [instance] :43
uObject* NodeExpressionBinding::SubscribeResource(uObject* source, uString* key, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.NodeExpressionBinding", "SubscribeResource(Fuse.Reactive.IExpression,string,Fuse.Reactive.IListener)");
    U_THROW(::g::Uno::Exception::New2(::STRINGS[69/*"The binding...*/]));
}

// public NodeExpressionBinding New(Fuse.Reactive.IExpression expr, Fuse.Node node, Fuse.Reactive.IListener listener) [static] :16
NodeExpressionBinding* NodeExpressionBinding::New1(uObject* expr, ::g::Fuse::Node* node, uObject* listener)
{
    NodeExpressionBinding* obj1 = (NodeExpressionBinding*)uNew(NodeExpressionBinding_typeof());
    obj1->ctor_(expr, node, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\IsDefined.uno
// -------------------------------------------------------------------------------------------------

// public sealed class NonNull :63
// {
static void NonNull_build(uType* type)
{
    ::TYPES[10] = ::g::Fuse::Reactive::Expression_typeof()->Array();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::ComputeExpression_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(2,
        new uFunction(".ctor", NULL, (void*)NonNull__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()),
        new uFunction("get_Operand", NULL, (void*)NonNull__get_Operand_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0));
}

::g::Fuse::Reactive::ComputeExpression_type* NonNull_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::ComputeExpression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ComputeExpression_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(NonNull);
    options.TypeSize = sizeof(::g::Fuse::Reactive::ComputeExpression_type);
    type = (::g::Fuse::Reactive::ComputeExpression_type*)uClassType::New("Fuse.Reactive.NonNull", options);
    type->fp_build_ = NonNull_build;
    type->fp_TryCompute = (void(*)(::g::Fuse::Reactive::ComputeExpression*, uArray*, uObject**, bool*))NonNull__TryCompute_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public NonNull(Fuse.Reactive.Expression operand) :68
void NonNull__ctor_2_fn(NonNull* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_2(operand);
}

// public NonNull New(Fuse.Reactive.Expression operand) :68
void NonNull__New1_fn(::g::Fuse::Reactive::Expression* operand, NonNull** __retval)
{
    *__retval = NonNull::New1(operand);
}

// public Fuse.Reactive.Expression get_Operand() :65
void NonNull__get_Operand_fn(NonNull* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->Operand();
}

// protected override sealed bool TryCompute(Fuse.Reactive.Expression.Argument[] args, object& result) :72
void NonNull__TryCompute_fn(NonNull* __this, uArray* args, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.NonNull", "TryCompute(Fuse.Reactive.Expression.Argument[],object&)");
    *result = uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(0))->Value();
    return *__retval = uPtr(args->Strong< ::g::Fuse::Reactive::Expression__Argument*>(0))->Value() != NULL, void();
}

// public NonNull(Fuse.Reactive.Expression operand) [instance] :68
void NonNull::ctor_2(::g::Fuse::Reactive::Expression* operand)
{
    uStackFrame __("Fuse.Reactive.NonNull", ".ctor(Fuse.Reactive.Expression)");
    ctor_1(uArray::Init< ::g::Fuse::Reactive::Expression*>(::TYPES[10/*Fuse.Reactive.Expression[]*/], 1, operand), 32, NULL);
}

// public Fuse.Reactive.Expression get_Operand() [instance] :65
::g::Fuse::Reactive::Expression* NonNull::Operand()
{
    uStackFrame __("Fuse.Reactive.NonNull", "get_Operand()");
    return GetArgument(0);
}

// public NonNull New(Fuse.Reactive.Expression operand) [static] :68
NonNull* NonNull::New1(::g::Fuse::Reactive::Expression* operand)
{
    NonNull* obj1 = (NonNull*)uNew(NonNull_typeof());
    obj1->ctor_2(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class NotEqual :188
// {
static void NotEqual_build(uType* type)
{
    ::STRINGS[112] = uString::Const("!=");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)NotEqual__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* NotEqual_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InfixOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(NotEqual);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.NotEqual", options);
    type->fp_build_ = NotEqual_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))NotEqual__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public NotEqual(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :191
void NotEqual__ctor_6_fn(NotEqual* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_6(left, right);
}

// public NotEqual New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :191
void NotEqual__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, NotEqual** __retval)
{
    *__retval = NotEqual::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :193
void NotEqual__TryCompute1_fn(NotEqual* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    bool v;

    if (!::g::Fuse::Marshal::TryEqualTo(left, right, &v))
    {
        *result = uBox(::TYPES[12/*bool*/], false);
        return *__retval = false, void();
    }

    *result = uBox(::TYPES[12/*bool*/], !v);
    return *__retval = true, void();
}

// public NotEqual(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :191
void NotEqual::ctor_6(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    uStackFrame __("Fuse.Reactive.NotEqual", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression)");
    ctor_5(left, right, ::STRINGS[112/*"!="*/], 0);
}

// public NotEqual New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :191
NotEqual* NotEqual::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    NotEqual* obj1 = (NotEqual*)uNew(NotEqual_typeof());
    obj1->ctor_6(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\NullCoalesce.uno
// ----------------------------------------------------------------------------------------------------

// public sealed class NullCoalesce :6
// {
static void NullCoalesce_build(uType* type)
{
    ::TYPES[10] = ::g::Fuse::Reactive::Expression_typeof()->Array();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::ComputeExpression_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)NullCoalesce__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::ComputeExpression_type* NullCoalesce_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::ComputeExpression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ComputeExpression_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(NullCoalesce);
    options.TypeSize = sizeof(::g::Fuse::Reactive::ComputeExpression_type);
    type = (::g::Fuse::Reactive::ComputeExpression_type*)uClassType::New("Fuse.Reactive.NullCoalesce", options);
    type->fp_build_ = NullCoalesce_build;
    type->fp_TryCompute = (void(*)(::g::Fuse::Reactive::ComputeExpression*, uArray*, uObject**, bool*))NullCoalesce__TryCompute_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public NullCoalesce(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :9
void NullCoalesce__ctor_2_fn(NullCoalesce* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_2(left, right);
}

// public NullCoalesce New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :9
void NullCoalesce__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, NullCoalesce** __retval)
{
    *__retval = NullCoalesce::New1(left, right);
}

// protected override sealed bool TryCompute(Fuse.Reactive.Expression.Argument[] args, object& result) :13
void NullCoalesce__TryCompute_fn(NullCoalesce* __this, uArray* args, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.NullCoalesce", "TryCompute(Fuse.Reactive.Expression.Argument[],object&)");

    if (uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(0))->HasValue() && (uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(0))->Value() != NULL))
    {
        *result = uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(0))->Value();
        return *__retval = true, void();
    }

    if (uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(1))->HasValue())
    {
        *result = uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(1))->Value();
        return *__retval = true, void();
    }

    *result = NULL;
    return *__retval = false, void();
}

// public NullCoalesce(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :9
void NullCoalesce::ctor_2(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    uStackFrame __("Fuse.Reactive.NullCoalesce", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression)");
    ctor_1(uArray::Init< ::g::Fuse::Reactive::Expression*>(::TYPES[10/*Fuse.Reactive.Expression[]*/], 2, left, right), 48, NULL);
}

// public NullCoalesce New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :9
NullCoalesce* NullCoalesce::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    NullCoalesce* obj1 = (NullCoalesce*)uNew(NullCoalesce_typeof());
    obj1->ctor_2(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Object.uno
// ----------------------------------------------------------------------------------------------

// public sealed class Object :16
// {
static void Object_build(uType* type)
{
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::SimpleVarArgFunction_type, interface0));
    type->SetFields(1);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Object__New1_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::SimpleVarArgFunction_type* Object_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::SimpleVarArgFunction_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::SimpleVarArgFunction_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Object);
    options.TypeSize = sizeof(::g::Fuse::Reactive::SimpleVarArgFunction_type);
    type = (::g::Fuse::Reactive::SimpleVarArgFunction_type*)uClassType::New("Fuse.Reactive.Object", options);
    type->fp_build_ = Object_build;
    type->fp_ctor_ = (void*)Object__New1_fn;
    type->fp_OnNewArguments = (void(*)(::g::Fuse::Reactive::SimpleVarArgFunction*, uArray*, uObject*))Object__OnNewArguments_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::SimpleVarArgFunction__Subscribe_fn;
    return type;
}

// public generated Object() :16
void Object__ctor_3_fn(Object* __this)
{
    __this->ctor_3();
}

// public generated Object New() :16
void Object__New1_fn(Object** __retval)
{
    *__retval = Object::New1();
}

// protected override sealed void OnNewArguments(Fuse.Reactive.Expression.Argument[] args, Fuse.Reactive.IListener listener) :18
void Object__OnNewArguments_fn(Object* __this, uArray* args, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.Object", "OnNewArguments(Fuse.Reactive.Expression.Argument[],Fuse.Reactive.IListener)");
    ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)__this, ::g::Fuse::Reactive::ArrayObject::New2(args));
}

// public generated Object() [instance] :16
void Object::ctor_3()
{
    ctor_2();
}

// public generated Object New() [static] :16
Object* Object::New1()
{
    Object* obj1 = (Object*)uNew(Object_typeof());
    obj1->ctor_3();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Subscription.uno
// ----------------------------------------------------------------------------------------------------

// private sealed class InnerListener.ObservableSubscription :82
// {
static void InnerListener__ObservableSubscription_build(uType* type)
{
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(::g::Fuse::Reactive::ValueObserver_type, interface0),
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(::g::Fuse::Reactive::ValueObserver_type, interface1));
    type->SetFields(2,
        ::g::Fuse::Reactive::InnerListener_typeof(), offsetof(InnerListener__ObservableSubscription, _listener), 0,
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(InnerListener__ObservableSubscription, _source), 0);
}

::g::Fuse::Reactive::ValueObserver_type* InnerListener__ObservableSubscription_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::ValueObserver_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ValueObserver_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(InnerListener__ObservableSubscription);
    options.TypeSize = sizeof(::g::Fuse::Reactive::ValueObserver_type);
    type = (::g::Fuse::Reactive::ValueObserver_type*)uClassType::New("Fuse.Reactive.InnerListener.ObservableSubscription", options);
    type->fp_build_ = InnerListener__ObservableSubscription_build;
    type->fp_Dispose = (void(*)(::g::Fuse::Reactive::ValueObserver*))InnerListener__ObservableSubscription__Dispose_fn;
    type->fp_LostData = (void(*)(::g::Fuse::Reactive::ValueObserver*))InnerListener__ObservableSubscription__LostData_fn;
    type->fp_PushData = (void(*)(::g::Fuse::Reactive::ValueObserver*, uObject*))InnerListener__ObservableSubscription__PushData_fn;
    type->interface1.fp_OnClear = (void(*)(uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnClear_fn;
    type->interface1.fp_OnSet = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnSet_fn;
    type->interface1.fp_OnAdd = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnAdd_fn;
    type->interface1.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnNewAt_fn;
    type->interface1.fp_OnFailed = (void(*)(uObject*, uString*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnFailed_fn;
    type->interface1.fp_OnNewAll = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnNewAll_fn;
    type->interface1.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface1.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnInsertAt_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))InnerListener__ObservableSubscription__Dispose_fn;
    return type;
}

// public ObservableSubscription(Fuse.Reactive.IExpression source, Fuse.Reactive.IObservable obs, Fuse.Reactive.InnerListener listener) :87
void InnerListener__ObservableSubscription__ctor_1_fn(InnerListener__ObservableSubscription* __this, uObject* source, uObject* obs, ::g::Fuse::Reactive::InnerListener* listener)
{
    __this->ctor_1(source, obs, listener);
}

// public override sealed void Dispose() :94
void InnerListener__ObservableSubscription__Dispose_fn(InnerListener__ObservableSubscription* __this)
{
    ::g::Fuse::Reactive::ValueObserver__Dispose_fn(__this);
    __this->_source = NULL;
    __this->_listener = NULL;
}

// protected override sealed void LostData() :106
void InnerListener__ObservableSubscription__LostData_fn(InnerListener__ObservableSubscription* __this)
{
    uStackFrame __("Fuse.Reactive.InnerListener.ObservableSubscription", "LostData()");
    uPtr(__this->_listener)->OnLostData(__this->_source);
}

// public ObservableSubscription New(Fuse.Reactive.IExpression source, Fuse.Reactive.IObservable obs, Fuse.Reactive.InnerListener listener) :87
void InnerListener__ObservableSubscription__New1_fn(uObject* source, uObject* obs, ::g::Fuse::Reactive::InnerListener* listener, InnerListener__ObservableSubscription** __retval)
{
    *__retval = InnerListener__ObservableSubscription::New1(source, obs, listener);
}

// protected override sealed void PushData(object newValue) :101
void InnerListener__ObservableSubscription__PushData_fn(InnerListener__ObservableSubscription* __this, uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.InnerListener.ObservableSubscription", "PushData(object)");
    uPtr(__this->_listener)->OnNewData(__this->_source, newValue);
}

// public ObservableSubscription(Fuse.Reactive.IExpression source, Fuse.Reactive.IObservable obs, Fuse.Reactive.InnerListener listener) [instance] :87
void InnerListener__ObservableSubscription::ctor_1(uObject* source, uObject* obs, ::g::Fuse::Reactive::InnerListener* listener)
{
    uStackFrame __("Fuse.Reactive.InnerListener.ObservableSubscription", ".ctor(Fuse.Reactive.IExpression,Fuse.Reactive.IObservable,Fuse.Reactive.InnerListener)");
    ctor_();
    _listener = listener;
    _source = source;
    Subscribe(obs);
}

// public ObservableSubscription New(Fuse.Reactive.IExpression source, Fuse.Reactive.IObservable obs, Fuse.Reactive.InnerListener listener) [static] :87
InnerListener__ObservableSubscription* InnerListener__ObservableSubscription::New1(uObject* source, uObject* obs, ::g::Fuse::Reactive::InnerListener* listener)
{
    InnerListener__ObservableSubscription* obj1 = (InnerListener__ObservableSubscription*)uNew(InnerListener__ObservableSubscription_typeof());
    obj1->ctor_1(source, obs, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\ObserverMap.uno
// ---------------------------------------------------------------------------------------

// internal abstract class ObserverMap<T> :23
// {
static void ObserverMap_build(uType* type)
{
    ::STRINGS[113] = uString::Const("An observable with write-back is expected");
    ::STRINGS[114] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive\\1.8.1\\ObserverMap.uno");
    ::STRINGS[115] = uString::Const("Attach");
    ::TYPES[60] = ::g::Uno::Collections::List_typeof();
    ::TYPES[30] = ::g::Fuse::Reactive::IObservableArray_typeof();
    ::TYPES[34] = ::g::Fuse::Reactive::ISubscription_typeof();
    ::TYPES[55] = ::g::Fuse::Reactive::IObserver_typeof();
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    ::TYPES[28] = ::g::Fuse::IArray_typeof();
    ::TYPES[61] = ::g::Fuse::Reactive::UnmappedView_typeof();
    type->SetPrecalc(
        ::g::Uno::Collections::List_typeof()->MakeType(type->T(0), NULL),
        ::g::Fuse::Reactive::UnmappedView_typeof()->MakeType(type->T(0), NULL));
    type->SetInterfaces(
        ::TYPES[55/*Fuse.Reactive.IObserver*/], offsetof(ObserverMap_type, interface0));
    type->SetFields(0,
        ::TYPES[60/*Uno.Collections.List`1*/]->MakeType(type->T(0), NULL), offsetof(ObserverMap, _list), 0,
        ::TYPES[30/*Fuse.Reactive.IObservableArray*/], offsetof(ObserverMap, _observable), 0,
        ::TYPES[28/*Fuse.IArray*/], offsetof(ObserverMap, _source), 0,
        ::TYPES[55/*Fuse.Reactive.IObserver*/], offsetof(ObserverMap, _slave), 0,
        ::TYPES[34/*Fuse.Reactive.ISubscription*/], offsetof(ObserverMap, _subscription), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(ObserverMap, _disposable), 0);
}

ObserverMap_type* ObserverMap_typeof()
{
    static uSStrong<ObserverMap_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 6;
    options.GenericCount = 1;
    options.InterfaceCount = 1;
    options.PrecalcCount = 2;
    options.ObjectSize = sizeof(ObserverMap);
    options.TypeSize = sizeof(ObserverMap_type);
    type = (ObserverMap_type*)uClassType::New("Fuse.Reactive.ObserverMap`1", options);
    type->fp_build_ = ObserverMap_build;
    type->fp_OnUpdated = ObserverMap__OnUpdated_fn;
    type->interface0.fp_OnClear = (void(*)(uObject*))ObserverMap__FuseReactiveIObserverOnClear_fn;
    type->interface0.fp_OnNewAll = (void(*)(uObject*, uObject*))ObserverMap__FuseReactiveIObserverOnNewAll_fn;
    type->interface0.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))ObserverMap__FuseReactiveIObserverOnNewAt_fn;
    type->interface0.fp_OnSet = (void(*)(uObject*, uObject*))ObserverMap__FuseReactiveIObserverOnSet_fn;
    type->interface0.fp_OnAdd = (void(*)(uObject*, uObject*))ObserverMap__FuseReactiveIObserverOnAdd_fn;
    type->interface0.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))ObserverMap__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface0.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))ObserverMap__FuseReactiveIObserverOnInsertAt_fn;
    type->interface0.fp_OnFailed = (void(*)(uObject*, uString*))ObserverMap__FuseReactiveIObserverOnFailed_fn;
    return type;
}

// protected generated ObserverMap() :23
void ObserverMap__ctor__fn(ObserverMap* __this)
{
    __this->ctor_();
}

// public void Add(T value) :95
void ObserverMap__Add_fn(ObserverMap* __this, uObject* value)
{
    __this->Add(value);
}

// public void Attach(Fuse.IArray src, [Fuse.Reactive.IObserver slave]) :58
void ObserverMap__Attach_fn(ObserverMap* __this, uObject* src, uObject* slave)
{
    __this->Attach(src, slave);
}

// public void Clear() :113
void ObserverMap__Clear_fn(ObserverMap* __this)
{
    __this->Clear();
}

// public int get_Count() :33
void ObserverMap__get_Count_fn(ObserverMap* __this, int32_t* __retval)
{
    *__retval = __this->Count();
}

// public void Detach() :82
void ObserverMap__Detach_fn(ObserverMap* __this)
{
    __this->Detach();
}

// private void Fuse.Reactive.IObserver.OnAdd(object addedValue) :175
void ObserverMap__FuseReactiveIObserverOnAdd_fn(ObserverMap* __this, uObject* addedValue)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "Fuse.Reactive.IObserver.OnAdd(object)");

    if (__this->_subscription == NULL)
        return;

    ::g::Uno::Collections::List__Add_fn(uPtr(__this->_list), __this->Map(addedValue));
    __this->OnUpdated();

    if (__this->_slave != NULL)
        ::g::Fuse::Reactive::IObserver::OnAdd(uInterface(uPtr(__this->_slave), ::TYPES[55/*Fuse.Reactive.IObserver*/]), addedValue);
}

// private void Fuse.Reactive.IObserver.OnClear() :128
void ObserverMap__FuseReactiveIObserverOnClear_fn(ObserverMap* __this)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "Fuse.Reactive.IObserver.OnClear()");

    if (__this->_subscription == NULL)
        return;

    uPtr(__this->_list)->Clear();
    __this->OnUpdated();

    if (__this->_slave != NULL)
        ::g::Fuse::Reactive::IObserver::OnClear(uInterface(uPtr(__this->_slave), ::TYPES[55/*Fuse.Reactive.IObserver*/]));
}

// private void Fuse.Reactive.IObserver.OnFailed(string message) :208
void ObserverMap__FuseReactiveIObserverOnFailed_fn(ObserverMap* __this, uString* message)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "Fuse.Reactive.IObserver.OnFailed(string)");

    if (__this->_subscription == NULL)
        return;

    uPtr(__this->_list)->Clear();
    __this->OnUpdated();

    if (__this->_slave != NULL)
        ::g::Fuse::Reactive::IObserver::OnFailed(uInterface(uPtr(__this->_slave), ::TYPES[55/*Fuse.Reactive.IObserver*/]), message);
}

// private void Fuse.Reactive.IObserver.OnInsertAt(int index, object value) :197
void ObserverMap__FuseReactiveIObserverOnInsertAt_fn(ObserverMap* __this, int32_t* index, uObject* value)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "Fuse.Reactive.IObserver.OnInsertAt(int,object)");
    int32_t index_ = *index;

    if (__this->_subscription == NULL)
        return;

    ::g::Uno::Collections::List__Insert_fn(uPtr(__this->_list), uCRef<int32_t>(index_), __this->Map(value));
    __this->OnUpdated();

    if (__this->_slave != NULL)
        ::g::Fuse::Reactive::IObserver::OnInsertAt(uInterface(uPtr(__this->_slave), ::TYPES[55/*Fuse.Reactive.IObserver*/]), index_, value);
}

// private void Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray values) :139
void ObserverMap__FuseReactiveIObserverOnNewAll_fn(ObserverMap* __this, uObject* values)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray)");

    if (__this->_subscription == NULL)
        return;

    uPtr(__this->_list)->Clear();

    for (int32_t i = 0; i < ::g::Fuse::IArray::Length(uInterface(uPtr(values), ::TYPES[28/*Fuse.IArray*/])); ++i)
        ::g::Uno::Collections::List__Add_fn(uPtr(__this->_list), __this->Map(::g::Fuse::IArray::Item(uInterface(uPtr(values), ::TYPES[28/*Fuse.IArray*/]), i)));

    __this->OnUpdated();

    if (__this->_slave != NULL)
        ::g::Fuse::Reactive::IObserver::OnNewAll(uInterface(uPtr(__this->_slave), ::TYPES[55/*Fuse.Reactive.IObserver*/]), values);
}

// private void Fuse.Reactive.IObserver.OnNewAt(int index, object newValue) :152
void ObserverMap__FuseReactiveIObserverOnNewAt_fn(ObserverMap* __this, int32_t* index, uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "Fuse.Reactive.IObserver.OnNewAt(int,object)");
    int32_t index_ = *index;

    if (__this->_subscription == NULL)
        return;

    ::g::Uno::Collections::List__set_Item_fn(uPtr(__this->_list), uCRef<int32_t>(index_), __this->Map(newValue));
    __this->OnUpdated();

    if (__this->_slave != NULL)
        ::g::Fuse::Reactive::IObserver::OnNewAt(uInterface(uPtr(__this->_slave), ::TYPES[55/*Fuse.Reactive.IObserver*/]), index_, newValue);
}

// private void Fuse.Reactive.IObserver.OnRemoveAt(int index) :186
void ObserverMap__FuseReactiveIObserverOnRemoveAt_fn(ObserverMap* __this, int32_t* index)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "Fuse.Reactive.IObserver.OnRemoveAt(int)");
    int32_t index_ = *index;

    if (__this->_subscription == NULL)
        return;

    uPtr(__this->_list)->RemoveAt(index_);
    __this->OnUpdated();

    if (__this->_slave != NULL)
        ::g::Fuse::Reactive::IObserver::OnRemoveAt(uInterface(uPtr(__this->_slave), ::TYPES[55/*Fuse.Reactive.IObserver*/]), index_);
}

// private void Fuse.Reactive.IObserver.OnSet(object newValue) :163
void ObserverMap__FuseReactiveIObserverOnSet_fn(ObserverMap* __this, uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "Fuse.Reactive.IObserver.OnSet(object)");

    if (__this->_subscription == NULL)
        return;

    uPtr(__this->_list)->Clear();
    ::g::Uno::Collections::List__Add_fn(uPtr(__this->_list), __this->Map(newValue));
    __this->OnUpdated();

    if (__this->_slave != NULL)
        ::g::Fuse::Reactive::IObserver::OnSet(uInterface(uPtr(__this->_slave), ::TYPES[55/*Fuse.Reactive.IObserver*/]), newValue);
}

// public void Insert(int index, T value) :107
void ObserverMap__Insert_fn(ObserverMap* __this, int32_t* index, uObject* value)
{
    __this->Insert(*index, value);
}

// public T get_Item(int index) :36
void ObserverMap__get_Item_fn(ObserverMap* __this, int32_t* index, uObject** __retval)
{
    *__retval = __this->Item(*index);
}

// public void set_Item(int index, T value) :37
void ObserverMap__set_Item_fn(ObserverMap* __this, int32_t* index, uObject* value)
{
    __this->Item(*index, value);
}

// protected virtual void OnUpdated() :29
void ObserverMap__OnUpdated_fn(ObserverMap* __this)
{
}

// public void RemoveAt(int index) :101
void ObserverMap__RemoveAt_fn(ObserverMap* __this, int32_t* index)
{
    __this->RemoveAt(*index);
}

// private void UpdateBacking() :119
void ObserverMap__UpdateBacking_fn(ObserverMap* __this)
{
    __this->UpdateBacking();
}

// internal object UVUnmap(T mv) :31
void ObserverMap__UVUnmap_fn(ObserverMap* __this, uObject* mv, uObject** __retval)
{
    *__retval = __this->UVUnmap(mv);
}

// protected generated ObserverMap() [instance] :23
void ObserverMap::ctor_()
{
    uType* __types[] = {
        __type->GetBase(ObserverMap_typeof())->Precalced(0/*Uno.Collections.List<T>*/),
    };
    _list = ((::g::Uno::Collections::List*)::g::Uno::Collections::List::New1(__types[0]));
}

// public void Add(T value) [instance] :95
void ObserverMap::Add(uObject* value)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "Add(T)");
    ::g::Uno::Collections::List__Add_fn(uPtr(_list), value);
    UpdateBacking();
}

// public void Attach(Fuse.IArray src, [Fuse.Reactive.IObserver slave]) [instance] :58
void ObserverMap::Attach(uObject* src, uObject* slave)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "Attach(Fuse.IArray,[Fuse.Reactive.IObserver])");
    Detach();
    _source = src;
    _observable = uAs<uObject*>(src, ::TYPES[30/*Fuse.Reactive.IObservableArray*/]);

    if (_observable != NULL)
    {
        _disposable = ::g::Fuse::Reactive::IObservableArray::Subscribe(uInterface(uPtr(_observable), ::TYPES[30/*Fuse.Reactive.IObservableArray*/]), (uObject*)this);
        _subscription = uAs<uObject*>(_disposable, ::TYPES[34/*Fuse.Reactive.ISubscription*/]);

        if (_subscription == NULL)
            ::g::Fuse::Diagnostics::InternalError(::STRINGS[113/*"An observab...*/], this, ::STRINGS[114/*"C:\\Users\\...*/], 72, ::STRINGS[115/*"Attach"*/]);
    }

    ::g::Fuse::Reactive::IObserver::OnNewAll(uInterface((uObject*)this, ::TYPES[55/*Fuse.Reactive.IObserver*/]), src);
    _slave = slave;
}

// public void Clear() [instance] :113
void ObserverMap::Clear()
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "Clear()");
    uPtr(_list)->Clear();
    UpdateBacking();
}

// public int get_Count() [instance] :33
int32_t ObserverMap::Count()
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "get_Count()");
    return uPtr(_list)->Count();
}

// public void Detach() [instance] :82
void ObserverMap::Detach()
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "Detach()");

    if (_disposable != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_disposable), ::TYPES[3/*Uno.IDisposable*/]));
        _disposable = NULL;
    }

    _subscription = NULL;
    _observable = NULL;
    _source = NULL;
    _slave = NULL;
}

// public void Insert(int index, T value) [instance] :107
void ObserverMap::Insert(int32_t index, uObject* value)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "Insert(int,T)");
    ::g::Uno::Collections::List__Insert_fn(uPtr(_list), uCRef<int32_t>(index), value);
    UpdateBacking();
}

// public T get_Item(int index) [instance] :36
uObject* ObserverMap::Item(int32_t index)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "get_Item(int)");
    uObject* ret1;
    return (::g::Uno::Collections::List__get_Item_fn(uPtr(_list), uCRef<int32_t>(index), &ret1), ret1);
}

// public void set_Item(int index, T value) [instance] :37
void ObserverMap::Item(int32_t index, uObject* value)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "set_Item(int,T)");
    ::g::Uno::Collections::List__set_Item_fn(uPtr(_list), uCRef<int32_t>(index), value);
    UpdateBacking();
}

// public void RemoveAt(int index) [instance] :101
void ObserverMap::RemoveAt(int32_t index)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "RemoveAt(int)");
    uPtr(_list)->RemoveAt(index);
    UpdateBacking();
}

// private void UpdateBacking() [instance] :119
void ObserverMap::UpdateBacking()
{
    uType* __types[] = {
        __type->GetBase(ObserverMap_typeof())->Precalced(1/*Fuse.Reactive.UnmappedView<T>*/),
    };
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "UpdateBacking()");

    if (_subscription == NULL)
        return;

    uObject* uv = (uObject*)((::g::Fuse::Reactive::UnmappedView*)::g::Fuse::Reactive::UnmappedView::New1(__types[0], this));
    ::g::Fuse::Reactive::ISubscription::ReplaceAllExclusive(uInterface(uPtr(_subscription), ::TYPES[34/*Fuse.Reactive.ISubscription*/]), uv);
}

// internal object UVUnmap(T mv) [instance] :31
uObject* ObserverMap::UVUnmap(uObject* mv)
{
    uStackFrame __("Fuse.Reactive.ObserverMap`1", "UVUnmap(T)");
    return Unmap(mv);
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Odd :67
// {
static void Odd_build(uType* type)
{
    ::STRINGS[116] = uString::Const("odd");
    ::TYPES[2] = ::g::Fuse::Marshal_typeof()->MakeMethod(1/*TryToType<float>*/, ::g::Uno::Float_typeof(), NULL);
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Odd__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Odd_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Odd);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Odd", options);
    type->fp_build_ = Odd_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::UnaryOperator*, uObject*, uObject**, bool*))Odd__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Odd(Fuse.Reactive.Expression operand) :70
void Odd__ctor_4_fn(Odd* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_4(operand);
}

// public Odd New(Fuse.Reactive.Expression operand) :70
void Odd__New1_fn(::g::Fuse::Reactive::Expression* operand, Odd** __retval)
{
    *__retval = Odd::New1(operand);
}

// protected override sealed bool TryCompute(object operand, object& result) :71
void Odd__TryCompute1_fn(Odd* __this, uObject* operand, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.Odd", "TryCompute(object,object&)");
    bool ret2;
    *result = NULL;
    float v = 0.0f;

    if (!(::g::Fuse::Marshal__TryToType_fn(::TYPES[2/*Fuse.Marshal.TryToType<float>*/], operand, &v, &ret2), ret2))
        return *__retval = false, void();

    int32_t q = (int32_t)::g::Uno::Math::Round2(v);
    *result = uBox(::TYPES[12/*bool*/], (q % 2) != 0);
    return *__retval = true, void();
}

// public Odd(Fuse.Reactive.Expression operand) [instance] :70
void Odd::ctor_4(::g::Fuse::Reactive::Expression* operand)
{
    ctor_3(operand, ::STRINGS[116/*"odd"*/], 0);
}

// public Odd New(Fuse.Reactive.Expression operand) [static] :70
Odd* Odd::New1(::g::Fuse::Reactive::Expression* operand)
{
    Odd* obj1 = (Odd*)uNew(Odd_typeof());
    obj1->ctor_4(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\InstantiatorFunction.uno
// ---------------------------------------------------------------------------------------------------------

// public sealed class OffsetIndexFunction :181
// {
static void OffsetIndexFunction_build(uType* type)
{
    type->SetDependencies(
        ::g::Fuse::Reactive::InstantiatorFunction_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->SetFields(2);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)OffsetIndexFunction__New1_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::Expression_type* OffsetIndexFunction_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InstantiatorFunction_typeof();
    options.FieldCount = 2;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(OffsetIndexFunction);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.OffsetIndexFunction", options);
    type->fp_build_ = OffsetIndexFunction_build;
    type->fp_ctor_ = (void*)OffsetIndexFunction__New1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::InstantiatorFunction__Subscribe_fn;
    return type;
}

// public OffsetIndexFunction() :184
void OffsetIndexFunction__ctor_3_fn(OffsetIndexFunction* __this)
{
    __this->ctor_3();
}

// public OffsetIndexFunction New() :184
void OffsetIndexFunction__New1_fn(OffsetIndexFunction** __retval)
{
    *__retval = OffsetIndexFunction::New1();
}

// public OffsetIndexFunction() [instance] :184
void OffsetIndexFunction::ctor_3()
{
    ctor_2(::g::Fuse::Reactive::InstantiatorFunction::OffsetIndexName());
}

// public OffsetIndexFunction New() [static] :184
OffsetIndexFunction* OffsetIndexFunction::New1()
{
    OffsetIndexFunction* obj1 = (OffsetIndexFunction*)uNew(OffsetIndexFunction_typeof());
    obj1->ctor_3();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Parameter.uno
// -------------------------------------------------------------------------------------------------

// public sealed class Parameter :16
// {
static void Parameter_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->SetFields(0,
        ::g::Fuse::Reactive::Expression_typeof(), offsetof(Parameter, Visual), 0);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Parameter__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::Expression_type* Parameter_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Parameter);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.Parameter", options);
    type->fp_build_ = Parameter_build;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))Parameter__Subscribe_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))Parameter__Subscribe_fn;
    return type;
}

// public Parameter(Fuse.Reactive.Expression visual) :21
void Parameter__ctor_1_fn(Parameter* __this, ::g::Fuse::Reactive::Expression* visual)
{
    __this->ctor_1(visual);
}

// public Parameter New(Fuse.Reactive.Expression visual) :21
void Parameter__New1_fn(::g::Fuse::Reactive::Expression* visual, Parameter** __retval)
{
    *__retval = Parameter::New1(visual);
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :26
void Parameter__Subscribe_fn(Parameter* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.Parameter", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    return *__retval = (uObject*)Parameter__Subscription::New1(__this, context, listener), void();
}

// public Parameter(Fuse.Reactive.Expression visual) [instance] :21
void Parameter::ctor_1(::g::Fuse::Reactive::Expression* visual)
{
    ctor_();
    Visual = visual;
}

// public Parameter New(Fuse.Reactive.Expression visual) [static] :21
Parameter* Parameter::New1(::g::Fuse::Reactive::Expression* visual)
{
    Parameter* obj1 = (Parameter*)uNew(Parameter_typeof());
    obj1->ctor_1(visual);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\PlatformFunctions.uno
// ---------------------------------------------------------------------------------------------------------

// public abstract class PlatformFunction :11
// {
static void PlatformFunction_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(PlatformFunction_type, interface0));
    type->SetFields(0,
        ::g::Uno::String_typeof(), offsetof(PlatformFunction, _name), 0);
}

PlatformFunction_type* PlatformFunction_typeof()
{
    static uSStrong<PlatformFunction_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(PlatformFunction);
    options.TypeSize = sizeof(PlatformFunction_type);
    type = (PlatformFunction_type*)uClassType::New("Fuse.Reactive.PlatformFunction", options);
    type->fp_build_ = PlatformFunction_build;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))PlatformFunction__Subscribe_fn;
    type->fp_ToString = (void(*)(uObject*, uString**))PlatformFunction__ToString_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))PlatformFunction__Subscribe_fn;
    return type;
}

// internal PlatformFunction(string name) :14
void PlatformFunction__ctor_1_fn(PlatformFunction* __this, uString* name)
{
    __this->ctor_1(name);
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :24
void PlatformFunction__Subscribe_fn(PlatformFunction* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.PlatformFunction", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    PlatformFunction__Subscription* sub = PlatformFunction__Subscription::New1(__this, listener);
    sub->Init();
    return *__retval = (uObject*)sub, void();
}

// public override sealed string ToString() :19
void PlatformFunction__ToString_fn(PlatformFunction* __this, uString** __retval)
{
    uStackFrame __("Fuse.Reactive.PlatformFunction", "ToString()");
    return *__retval = ::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(uString::Const("is"), __this->_name), uString::Const("()")), void();
}

// internal PlatformFunction(string name) [instance] :14
void PlatformFunction::ctor_1(uString* name)
{
    ctor_();
    _name = name;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Pow :383
// {
static void Pow_build(uType* type)
{
    ::STRINGS[117] = uString::Const("pow");
    ::TYPES[8] = ::g::Fuse::Reactive::BinaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Pow__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* Pow_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::BinaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Pow);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.Pow", options);
    type->fp_build_ = Pow_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Pow(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :386
void Pow__ctor_5_fn(Pow* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_5(left, right);
}

// public Pow New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :386
void Pow__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, Pow** __retval)
{
    *__retval = Pow::New1(left, right);
}

// public Pow(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :386
void Pow::ctor_5(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    ctor_4(left, right, ::STRINGS[117/*"pow"*/], uDelegate::New(::TYPES[8/*Fuse.Reactive.BinaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Pow_fn));
}

// public Pow New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :386
Pow* Pow::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    Pow* obj1 = (Pow*)uNew(Pow_typeof());
    obj1->ctor_5(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Property.uno
// ------------------------------------------------------------------------------------------------

// public sealed class Property :8
// {
static void Property_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->SetFields(0,
        ::g::Uno::UX::PropertyAccessor_typeof(), offsetof(Property, _Accessor), 0,
        ::g::Fuse::Reactive::ConstantExpression_typeof(), offsetof(Property, _Object), 0);
    type->Reflection.SetFunctions(3,
        new uFunction("get_Accessor", NULL, (void*)Property__get_Accessor_fn, 0, false, ::g::Uno::UX::PropertyAccessor_typeof(), 0),
        new uFunction(".ctor", NULL, (void*)Property__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::ConstantExpression_typeof(), ::g::Uno::UX::PropertyAccessor_typeof()),
        new uFunction("get_Object", NULL, (void*)Property__get_Object_fn, 0, false, ::g::Fuse::Reactive::ConstantExpression_typeof(), 0));
}

::g::Fuse::Reactive::Expression_type* Property_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.FieldCount = 2;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Property);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.Property", options);
    type->fp_build_ = Property_build;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))Property__Subscribe_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))Property__Subscribe_fn;
    return type;
}

// public Property(Fuse.Reactive.ConstantExpression obj, Uno.UX.PropertyAccessor accessor) :14
void Property__ctor_1_fn(Property* __this, ::g::Fuse::Reactive::ConstantExpression* obj, ::g::Uno::UX::PropertyAccessor* accessor)
{
    __this->ctor_1(obj, accessor);
}

// public generated Uno.UX.PropertyAccessor get_Accessor() :11
void Property__get_Accessor_fn(Property* __this, ::g::Uno::UX::PropertyAccessor** __retval)
{
    *__retval = __this->Accessor();
}

// private generated void set_Accessor(Uno.UX.PropertyAccessor value) :11
void Property__set_Accessor_fn(Property* __this, ::g::Uno::UX::PropertyAccessor* value)
{
    __this->Accessor(value);
}

// public Property New(Fuse.Reactive.ConstantExpression obj, Uno.UX.PropertyAccessor accessor) :14
void Property__New1_fn(::g::Fuse::Reactive::ConstantExpression* obj, ::g::Uno::UX::PropertyAccessor* accessor, Property** __retval)
{
    *__retval = Property::New1(obj, accessor);
}

// public generated Fuse.Reactive.ConstantExpression get_Object() :10
void Property__get_Object_fn(Property* __this, ::g::Fuse::Reactive::ConstantExpression** __retval)
{
    *__retval = __this->Object();
}

// private generated void set_Object(Fuse.Reactive.ConstantExpression value) :10
void Property__set_Object_fn(Property* __this, ::g::Fuse::Reactive::ConstantExpression* value)
{
    __this->Object(value);
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :19
void Property__Subscribe_fn(Property* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.Property", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    ::g::Uno::UX::PropertyObject* obj = uCast< ::g::Uno::UX::PropertyObject*>(uPtr(__this->Object())->GetValue(context), ::g::Uno::UX::PropertyObject_typeof());
    return *__retval = (uObject*)Property__Subscription::New1(__this, obj, __this->Accessor(), listener), void();
}

// public Property(Fuse.Reactive.ConstantExpression obj, Uno.UX.PropertyAccessor accessor) [instance] :14
void Property::ctor_1(::g::Fuse::Reactive::ConstantExpression* obj, ::g::Uno::UX::PropertyAccessor* accessor)
{
    ctor_();
    Object(obj);
    Accessor(accessor);
}

// public generated Uno.UX.PropertyAccessor get_Accessor() [instance] :11
::g::Uno::UX::PropertyAccessor* Property::Accessor()
{
    return _Accessor;
}

// private generated void set_Accessor(Uno.UX.PropertyAccessor value) [instance] :11
void Property::Accessor(::g::Uno::UX::PropertyAccessor* value)
{
    _Accessor = value;
}

// public generated Fuse.Reactive.ConstantExpression get_Object() [instance] :10
::g::Fuse::Reactive::ConstantExpression* Property::Object()
{
    return _Object;
}

// private generated void set_Object(Fuse.Reactive.ConstantExpression value) [instance] :10
void Property::Object(::g::Fuse::Reactive::ConstantExpression* value)
{
    _Object = value;
}

// public Property New(Fuse.Reactive.ConstantExpression obj, Uno.UX.PropertyAccessor accessor) [static] :14
Property* Property::New1(::g::Fuse::Reactive::ConstantExpression* obj, ::g::Uno::UX::PropertyAccessor* accessor)
{
    Property* obj1 = (Property*)uNew(Property_typeof());
    obj1->ctor_1(obj, accessor);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\DataBinding.uno
// ------------------------------------------------------------------------------------------------

// public sealed class PropertyBinding :333
// {
static void PropertyBinding_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IContext_typeof(), offsetof(::g::Fuse::Reactive::DataBinding_type, interface0),
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(::g::Fuse::Reactive::DataBinding_type, interface1),
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(::g::Fuse::Reactive::DataBinding_type, interface2),
        ::g::Fuse::INameListener_typeof(), offsetof(::g::Fuse::Reactive::DataBinding_type, interface3),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(::g::Fuse::Reactive::DataBinding_type, interface4));
    type->SetFields(9);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)PropertyBinding__New2_fn, 0, true, type, 2, ::g::Uno::UX::Property_typeof(), ::g::Uno::UX::Property_typeof()));
}

::g::Fuse::Reactive::DataBinding_type* PropertyBinding_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::DataBinding_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::DataBinding_typeof();
    options.FieldCount = 9;
    options.InterfaceCount = 5;
    options.ObjectSize = sizeof(PropertyBinding);
    options.TypeSize = sizeof(::g::Fuse::Reactive::DataBinding_type);
    type = (::g::Fuse::Reactive::DataBinding_type*)uClassType::New("Fuse.Reactive.PropertyBinding", options);
    type->fp_build_ = PropertyBinding_build;
    type->interface2.fp_OnClear = (void(*)(uObject*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnClear_fn;
    type->interface2.fp_OnSet = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnSet_fn;
    type->interface2.fp_OnAdd = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnAdd_fn;
    type->interface2.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnNewAt_fn;
    type->interface2.fp_OnFailed = (void(*)(uObject*, uString*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnFailed_fn;
    type->interface2.fp_OnNewAll = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnNewAll_fn;
    type->interface2.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface2.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnInsertAt_fn;
    type->interface3.fp_OnNameChanged = (void(*)(uObject*, ::g::Fuse::Node*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::DataBinding__FuseINameListenerOnNameChanged_fn;
    type->interface4.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::DataBinding__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIContextSubscribe_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_get_Node = (void(*)(uObject*, ::g::Fuse::Node**))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIContextget_Node_fn;
    type->interface0.fp_SubscribeResource = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))::g::Fuse::Reactive::DataBinding__SubscribeResource_fn;
    return type;
}

// public PropertyBinding(Uno.UX.Property target, Uno.UX.Property source) :336
void PropertyBinding__ctor_3_fn(PropertyBinding* __this, ::g::Uno::UX::Property* target, ::g::Uno::UX::Property* source)
{
    __this->ctor_3(target, source);
}

// public PropertyBinding New(Uno.UX.Property target, Uno.UX.Property source) :336
void PropertyBinding__New2_fn(::g::Uno::UX::Property* target, ::g::Uno::UX::Property* source, PropertyBinding** __retval)
{
    *__retval = PropertyBinding::New2(target, source);
}

// public PropertyBinding(Uno.UX.Property target, Uno.UX.Property source) [instance] :336
void PropertyBinding::ctor_3(::g::Uno::UX::Property* target, ::g::Uno::UX::Property* source)
{
    uStackFrame __("Fuse.Reactive.PropertyBinding", ".ctor(Uno.UX.Property,Uno.UX.Property)");
    ctor_2(target, (uObject*)::g::Fuse::Reactive::Property::New1(::g::Fuse::Reactive::Constant::New1(uPtr(source)->Object()), source), 3);
}

// public PropertyBinding New(Uno.UX.Property target, Uno.UX.Property source) [static] :336
PropertyBinding* PropertyBinding::New2(::g::Uno::UX::Property* target, ::g::Uno::UX::Property* source)
{
    PropertyBinding* obj1 = (PropertyBinding*)uNew(PropertyBinding_typeof());
    obj1->ctor_3(target, source);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Device.uno
// ----------------------------------------------------------------------------------------------

// private sealed class CapsObject.PropertySubscription :54
// {
static void CapsObject__PropertySubscription_build(uType* type)
{
    ::TYPES[31] = ::g::Uno::UX::Selector_typeof();
    ::TYPES[62] = ::g::Fuse::Reactive::IPropertyObserver_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IPropertySubscription_typeof(), offsetof(CapsObject__PropertySubscription_type, interface0),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(CapsObject__PropertySubscription_type, interface1),
        ::g::Uno::IDisposable_typeof(), offsetof(CapsObject__PropertySubscription_type, interface2));
    type->SetFields(0,
        ::g::Fuse::Reactive::CapsObject_typeof(), offsetof(CapsObject__PropertySubscription, _caps), 0,
        ::TYPES[62/*Fuse.Reactive.IPropertyObserver*/], offsetof(CapsObject__PropertySubscription, _observer), 0);
}

CapsObject__PropertySubscription_type* CapsObject__PropertySubscription_typeof()
{
    static uSStrong<CapsObject__PropertySubscription_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 2;
    options.InterfaceCount = 3;
    options.ObjectSize = sizeof(CapsObject__PropertySubscription);
    options.TypeSize = sizeof(CapsObject__PropertySubscription_type);
    type = (CapsObject__PropertySubscription_type*)uClassType::New("Fuse.Reactive.CapsObject.PropertySubscription", options);
    type->fp_build_ = CapsObject__PropertySubscription_build;
    type->interface0.fp_TrySetExclusive = (void(*)(uObject*, uString*, uObject*, bool*))CapsObject__PropertySubscription__TrySetExclusive_fn;
    type->interface1.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))CapsObject__PropertySubscription__OnPropertyChanged_fn;
    type->interface2.fp_Dispose = (void(*)(uObject*))CapsObject__PropertySubscription__Dispose_fn;
    return type;
}

// public PropertySubscription(Fuse.Reactive.CapsObject dc, Fuse.Reactive.IPropertyObserver observer) :59
void CapsObject__PropertySubscription__ctor__fn(CapsObject__PropertySubscription* __this, ::g::Fuse::Reactive::CapsObject* dc, uObject* observer)
{
    __this->ctor_(dc, observer);
}

// public void Dispose() :65
void CapsObject__PropertySubscription__Dispose_fn(CapsObject__PropertySubscription* __this)
{
    __this->Dispose();
}

// public PropertySubscription New(Fuse.Reactive.CapsObject dc, Fuse.Reactive.IPropertyObserver observer) :59
void CapsObject__PropertySubscription__New1_fn(::g::Fuse::Reactive::CapsObject* dc, uObject* observer, CapsObject__PropertySubscription** __retval)
{
    *__retval = CapsObject__PropertySubscription::New1(dc, observer);
}

// public void OnPropertyChanged(Uno.UX.PropertyObject ignore, Uno.UX.Selector name) :75
void CapsObject__PropertySubscription__OnPropertyChanged_fn(CapsObject__PropertySubscription* __this, ::g::Uno::UX::PropertyObject* ignore, ::g::Uno::UX::Selector* name)
{
    __this->OnPropertyChanged(ignore, *name);
}

// public bool TrySetExclusive(string propertyName, object newValue) :85
void CapsObject__PropertySubscription__TrySetExclusive_fn(CapsObject__PropertySubscription* __this, uString* propertyName, uObject* newValue, bool* __retval)
{
    *__retval = __this->TrySetExclusive(propertyName, newValue);
}

// public PropertySubscription(Fuse.Reactive.CapsObject dc, Fuse.Reactive.IPropertyObserver observer) [instance] :59
void CapsObject__PropertySubscription::ctor_(::g::Fuse::Reactive::CapsObject* dc, uObject* observer)
{
    _caps = dc;
    _observer = observer;
}

// public void Dispose() [instance] :65
void CapsObject__PropertySubscription::Dispose()
{
    uStackFrame __("Fuse.Reactive.CapsObject.PropertySubscription", "Dispose()");

    if (_caps != NULL)
    {
        uPtr(_caps)->RemovePropertyListener((uObject*)this);
        _caps = NULL;
        _observer = NULL;
    }
}

// public void OnPropertyChanged(Uno.UX.PropertyObject ignore, Uno.UX.Selector name) [instance] :75
void CapsObject__PropertySubscription::OnPropertyChanged(::g::Uno::UX::PropertyObject* ignore, ::g::Uno::UX::Selector name)
{
    uStackFrame __("Fuse.Reactive.CapsObject.PropertySubscription", "OnPropertyChanged(Uno.UX.PropertyObject,Uno.UX.Selector)");

    if (_observer != NULL)
    {
        uString* str = name.ToString(::TYPES[31/*Uno.UX.Selector*/]);
        uObject* value = uPtr(_caps)->GetValue(str);
        ::g::Fuse::Reactive::IPropertyObserver::OnPropertyChanged(uInterface(uPtr(_observer), ::TYPES[62/*Fuse.Reactive.IPropertyObserver*/]), (uObject*)this, str, value);
    }
}

// public bool TrySetExclusive(string propertyName, object newValue) [instance] :85
bool CapsObject__PropertySubscription::TrySetExclusive(uString* propertyName, uObject* newValue)
{
    return false;
}

// public PropertySubscription New(Fuse.Reactive.CapsObject dc, Fuse.Reactive.IPropertyObserver observer) [static] :59
CapsObject__PropertySubscription* CapsObject__PropertySubscription::New1(::g::Fuse::Reactive::CapsObject* dc, uObject* observer)
{
    CapsObject__PropertySubscription* obj1 = (CapsObject__PropertySubscription*)uNew(CapsObject__PropertySubscription_typeof());
    obj1->ctor_(dc, observer);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\QuaternaryOperator.uno
// ----------------------------------------------------------------------------------------------------------

// public abstract class QuaternaryOperator :8
// {
static void QuaternaryOperator_build(uType* type)
{
    ::STRINGS[11] = uString::Const(" No `TryCompute`, or a deprecated form, overriden. Migrate your code to override the one with `bool` return. ");
    ::STRINGS[118] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Expressions\\1.8.1\\QuaternaryOperator.uno");
    ::STRINGS[13] = uString::Const("TryCompute");
    ::TYPES[10] = ::g::Fuse::Reactive::Expression_typeof()->Array();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::ComputeExpression_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(4,
        new uFunction("get_First", NULL, (void*)QuaternaryOperator__get_First_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0),
        new uFunction("get_Fourth", NULL, (void*)QuaternaryOperator__get_Fourth_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0),
        new uFunction("get_Second", NULL, (void*)QuaternaryOperator__get_Second_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0),
        new uFunction("get_Third", NULL, (void*)QuaternaryOperator__get_Third_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0));
}

::g::Fuse::Reactive::ComputeExpression_type* QuaternaryOperator_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::ComputeExpression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ComputeExpression_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(QuaternaryOperator);
    options.TypeSize = sizeof(::g::Fuse::Reactive::ComputeExpression_type);
    type = (::g::Fuse::Reactive::ComputeExpression_type*)uClassType::New("Fuse.Reactive.QuaternaryOperator", options);
    type->fp_build_ = QuaternaryOperator_build;
    type->fp_GetFlags = (void(*)(::g::Fuse::Reactive::ComputeExpression*, int32_t*))QuaternaryOperator__GetFlags_fn;
    type->fp_TryCompute = (void(*)(::g::Fuse::Reactive::ComputeExpression*, uArray*, uObject**, bool*))QuaternaryOperator__TryCompute_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// protected QuaternaryOperator(Fuse.Reactive.Expression first, Fuse.Reactive.Expression second, Fuse.Reactive.Expression third, Fuse.Reactive.Expression fourth, [Fuse.Reactive.ComputeExpression.Flags flags]) :15
void QuaternaryOperator__ctor_2_fn(QuaternaryOperator* __this, ::g::Fuse::Reactive::Expression* first, ::g::Fuse::Reactive::Expression* second, ::g::Fuse::Reactive::Expression* third, ::g::Fuse::Reactive::Expression* fourth, int32_t* flags)
{
    __this->ctor_2(first, second, third, fourth, *flags);
}

// protected object Compute(object first, object second, object third, object fourth) :44
void QuaternaryOperator__Compute_fn(QuaternaryOperator* __this, uObject* first, uObject* second, uObject* third, uObject* fourth, uObject** __retval)
{
    *__retval = __this->Compute(first, second, third, fourth);
}

// public Fuse.Reactive.Expression get_First() :10
void QuaternaryOperator__get_First_fn(QuaternaryOperator* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->First();
}

// public Fuse.Reactive.Expression get_Fourth() :13
void QuaternaryOperator__get_Fourth_fn(QuaternaryOperator* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->Fourth();
}

// internal override sealed Fuse.Reactive.ComputeExpression.Flags GetFlags() :21
void QuaternaryOperator__GetFlags_fn(QuaternaryOperator* __this, int32_t* __retval)
{
    return *__retval = (((0 | (__this->IsFirstOptional() ? 1 : 0)) | (__this->IsSecondOptional() ? 2 : 0)) | (__this->IsThirdOptional() ? 4 : 0)) | (__this->IsFourthOptional() ? 8 : 0), void();
}

// protected bool get_IsFirstOptional() :31
void QuaternaryOperator__get_IsFirstOptional_fn(QuaternaryOperator* __this, bool* __retval)
{
    *__retval = __this->IsFirstOptional();
}

// protected bool get_IsFourthOptional() :34
void QuaternaryOperator__get_IsFourthOptional_fn(QuaternaryOperator* __this, bool* __retval)
{
    *__retval = __this->IsFourthOptional();
}

// protected bool get_IsSecondOptional() :32
void QuaternaryOperator__get_IsSecondOptional_fn(QuaternaryOperator* __this, bool* __retval)
{
    *__retval = __this->IsSecondOptional();
}

// protected bool get_IsThirdOptional() :33
void QuaternaryOperator__get_IsThirdOptional_fn(QuaternaryOperator* __this, bool* __retval)
{
    *__retval = __this->IsThirdOptional();
}

// public Fuse.Reactive.Expression get_Second() :11
void QuaternaryOperator__get_Second_fn(QuaternaryOperator* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->Second();
}

// public Fuse.Reactive.Expression get_Third() :12
void QuaternaryOperator__get_Third_fn(QuaternaryOperator* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->Third();
}

// protected override sealed bool TryCompute(Fuse.Reactive.Expression.Argument[] args, object& result) :46
void QuaternaryOperator__TryCompute_fn(QuaternaryOperator* __this, uArray* args, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.QuaternaryOperator", "TryCompute(Fuse.Reactive.Expression.Argument[],object&)");
    return *__retval = __this->TryCompute1(uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(0))->Value(), uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(1))->Value(), uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(2))->Value(), uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(3))->Value(), result), void();
}

// protected bool TryCompute(object first, object second, object third, object fourth, object& result) :36
void QuaternaryOperator__TryCompute1_fn(QuaternaryOperator* __this, uObject* first, uObject* second, uObject* third, uObject* fourth, uObject** result, bool* __retval)
{
    *__retval = __this->TryCompute1(first, second, third, fourth, result);
}

// protected QuaternaryOperator(Fuse.Reactive.Expression first, Fuse.Reactive.Expression second, Fuse.Reactive.Expression third, Fuse.Reactive.Expression fourth, [Fuse.Reactive.ComputeExpression.Flags flags]) [instance] :15
void QuaternaryOperator::ctor_2(::g::Fuse::Reactive::Expression* first, ::g::Fuse::Reactive::Expression* second, ::g::Fuse::Reactive::Expression* third, ::g::Fuse::Reactive::Expression* fourth, int32_t flags)
{
    uStackFrame __("Fuse.Reactive.QuaternaryOperator", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression,Fuse.Reactive.Expression,Fuse.Reactive.Expression,[Fuse.Reactive.ComputeExpression.Flags])");
    ctor_1(uArray::Init< ::g::Fuse::Reactive::Expression*>(::TYPES[10/*Fuse.Reactive.Expression[]*/], 4, first, second, third, fourth), flags, NULL);
}

// protected object Compute(object first, object second, object third, object fourth) [instance] :44
uObject* QuaternaryOperator::Compute(uObject* first, uObject* second, uObject* third, uObject* fourth)
{
    return NULL;
}

// public Fuse.Reactive.Expression get_First() [instance] :10
::g::Fuse::Reactive::Expression* QuaternaryOperator::First()
{
    uStackFrame __("Fuse.Reactive.QuaternaryOperator", "get_First()");
    return GetArgument(0);
}

// public Fuse.Reactive.Expression get_Fourth() [instance] :13
::g::Fuse::Reactive::Expression* QuaternaryOperator::Fourth()
{
    uStackFrame __("Fuse.Reactive.QuaternaryOperator", "get_Fourth()");
    return GetArgument(3);
}

// protected bool get_IsFirstOptional() [instance] :31
bool QuaternaryOperator::IsFirstOptional()
{
    return false;
}

// protected bool get_IsFourthOptional() [instance] :34
bool QuaternaryOperator::IsFourthOptional()
{
    return false;
}

// protected bool get_IsSecondOptional() [instance] :32
bool QuaternaryOperator::IsSecondOptional()
{
    return false;
}

// protected bool get_IsThirdOptional() [instance] :33
bool QuaternaryOperator::IsThirdOptional()
{
    return false;
}

// public Fuse.Reactive.Expression get_Second() [instance] :11
::g::Fuse::Reactive::Expression* QuaternaryOperator::Second()
{
    uStackFrame __("Fuse.Reactive.QuaternaryOperator", "get_Second()");
    return GetArgument(1);
}

// public Fuse.Reactive.Expression get_Third() [instance] :12
::g::Fuse::Reactive::Expression* QuaternaryOperator::Third()
{
    uStackFrame __("Fuse.Reactive.QuaternaryOperator", "get_Third()");
    return GetArgument(2);
}

// protected bool TryCompute(object first, object second, object third, object fourth, object& result) [instance] :36
bool QuaternaryOperator::TryCompute1(uObject* first, uObject* second, uObject* third, uObject* fourth, uObject** result)
{
    uStackFrame __("Fuse.Reactive.QuaternaryOperator", "TryCompute(object,object,object,object,object&)");
    ::g::Fuse::Diagnostics::Deprecated(::STRINGS[11/*" No `TryCom...*/], this, ::STRINGS[118/*"C:\\Users\\...*/], 38, ::STRINGS[13/*"TryCompute"*/]);
    *result = Compute(first, second, third, fourth);
    return true;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class RadiansToDegrees :327
// {
static void RadiansToDegrees_build(uType* type)
{
    ::STRINGS[119] = uString::Const("radiansToDegrees");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)RadiansToDegrees__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* RadiansToDegrees_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(RadiansToDegrees);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.RadiansToDegrees", options);
    type->fp_build_ = RadiansToDegrees_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public RadiansToDegrees(Fuse.Reactive.Expression operand) :330
void RadiansToDegrees__ctor_5_fn(RadiansToDegrees* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public RadiansToDegrees New(Fuse.Reactive.Expression operand) :330
void RadiansToDegrees__New1_fn(::g::Fuse::Reactive::Expression* operand, RadiansToDegrees** __retval)
{
    *__retval = RadiansToDegrees::New1(operand);
}

// public RadiansToDegrees(Fuse.Reactive.Expression operand) [instance] :330
void RadiansToDegrees::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[119/*"radiansToDe...*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__RadiansToDegrees_fn));
}

// public RadiansToDegrees New(Fuse.Reactive.Expression operand) [static] :330
RadiansToDegrees* RadiansToDegrees::New1(::g::Fuse::Reactive::Expression* operand)
{
    RadiansToDegrees* obj1 = (RadiansToDegrees*)uNew(RadiansToDegrees_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\WhileCount.uno
// -----------------------------------------------------------------------------------------------

// private enum WhileCount.Range :145
uEnumType* WhileCount__Range_typeof()
{
    static uSStrong<uEnumType*> type;
    if (type != NULL) return type;

    type = uEnumType::New("Fuse.Reactive.WhileCount.Range", ::g::Uno::Int_typeof(), 3);
    type->SetLiterals(
        "Open", 0LL,
        "Exclusive", 1LL,
        "Inclusive", 2LL);
    return type;
}

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Resource.uno
// ------------------------------------------------------------------------------------------------

// public sealed class Resource :8
// {
static void Resource_build(uType* type)
{
    ::TYPES[27] = ::g::Fuse::Reactive::IContext_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->SetFields(0,
        ::g::Uno::String_typeof(), offsetof(Resource, _Key), 0);
    type->Reflection.SetFunctions(2,
        new uFunction("get_Key", NULL, (void*)Resource__get_Key_fn, 0, false, ::g::Uno::String_typeof(), 0),
        new uFunction(".ctor", NULL, (void*)Resource__New1_fn, 0, true, type, 1, ::g::Uno::String_typeof()));
}

::g::Fuse::Reactive::Expression_type* Resource_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Resource);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.Resource", options);
    type->fp_build_ = Resource_build;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))Resource__Subscribe_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))Resource__Subscribe_fn;
    return type;
}

// public Resource(string key) :12
void Resource__ctor_1_fn(Resource* __this, uString* key)
{
    __this->ctor_1(key);
}

// public generated string get_Key() :10
void Resource__get_Key_fn(Resource* __this, uString** __retval)
{
    *__retval = __this->Key();
}

// private generated void set_Key(string value) :10
void Resource__set_Key_fn(Resource* __this, uString* value)
{
    __this->Key(value);
}

// public Resource New(string key) :12
void Resource__New1_fn(uString* key, Resource** __retval)
{
    *__retval = Resource::New1(key);
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :16
void Resource__Subscribe_fn(Resource* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.Resource", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    return *__retval = ::g::Fuse::Reactive::IContext::SubscribeResource(uInterface(uPtr(context), ::TYPES[27/*Fuse.Reactive.IContext*/]), (uObject*)__this, __this->Key(), listener), void();
}

// public Resource(string key) [instance] :12
void Resource::ctor_1(uString* key)
{
    ctor_();
    Key(key);
}

// public generated string get_Key() [instance] :10
uString* Resource::Key()
{
    return _Key;
}

// private generated void set_Key(string value) [instance] :10
void Resource::Key(uString* value)
{
    _Key = value;
}

// public Resource New(string key) [static] :12
Resource* Resource::New1(uString* key)
{
    Resource* obj1 = (Resource*)uNew(Resource_typeof());
    obj1->ctor_1(key);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\DataBinding.uno
// ------------------------------------------------------------------------------------------------

// public sealed class ResourceBinding :340
// {
static void ResourceBinding_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IContext_typeof(), offsetof(::g::Fuse::Reactive::DataBinding_type, interface0),
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(::g::Fuse::Reactive::DataBinding_type, interface1),
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(::g::Fuse::Reactive::DataBinding_type, interface2),
        ::g::Fuse::INameListener_typeof(), offsetof(::g::Fuse::Reactive::DataBinding_type, interface3),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(::g::Fuse::Reactive::DataBinding_type, interface4));
    type->SetFields(9);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)ResourceBinding__New2_fn, 0, true, type, 2, ::g::Uno::UX::Property_typeof(), ::g::Uno::String_typeof()));
}

::g::Fuse::Reactive::DataBinding_type* ResourceBinding_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::DataBinding_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::DataBinding_typeof();
    options.FieldCount = 9;
    options.InterfaceCount = 5;
    options.ObjectSize = sizeof(ResourceBinding);
    options.TypeSize = sizeof(::g::Fuse::Reactive::DataBinding_type);
    type = (::g::Fuse::Reactive::DataBinding_type*)uClassType::New("Fuse.Reactive.ResourceBinding", options);
    type->fp_build_ = ResourceBinding_build;
    type->interface2.fp_OnClear = (void(*)(uObject*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnClear_fn;
    type->interface2.fp_OnSet = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnSet_fn;
    type->interface2.fp_OnAdd = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnAdd_fn;
    type->interface2.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnNewAt_fn;
    type->interface2.fp_OnFailed = (void(*)(uObject*, uString*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnFailed_fn;
    type->interface2.fp_OnNewAll = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnNewAll_fn;
    type->interface2.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface2.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::DataBinding__FuseReactiveIObserverOnInsertAt_fn;
    type->interface3.fp_OnNameChanged = (void(*)(uObject*, ::g::Fuse::Node*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::DataBinding__FuseINameListenerOnNameChanged_fn;
    type->interface4.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::DataBinding__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIContextSubscribe_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_get_Node = (void(*)(uObject*, ::g::Fuse::Node**))::g::Fuse::Reactive::ExpressionBinding__FuseReactiveIContextget_Node_fn;
    type->interface0.fp_SubscribeResource = (void(*)(uObject*, uObject*, uString*, uObject*, uObject**))::g::Fuse::Reactive::DataBinding__SubscribeResource_fn;
    return type;
}

// public ResourceBinding(Uno.UX.Property target, string key) :343
void ResourceBinding__ctor_3_fn(ResourceBinding* __this, ::g::Uno::UX::Property* target, uString* key)
{
    __this->ctor_3(target, key);
}

// public ResourceBinding New(Uno.UX.Property target, string key) :343
void ResourceBinding__New2_fn(::g::Uno::UX::Property* target, uString* key, ResourceBinding** __retval)
{
    *__retval = ResourceBinding::New2(target, key);
}

// public ResourceBinding(Uno.UX.Property target, string key) [instance] :343
void ResourceBinding::ctor_3(::g::Uno::UX::Property* target, uString* key)
{
    uStackFrame __("Fuse.Reactive.ResourceBinding", ".ctor(Uno.UX.Property,string)");
    ctor_2(target, (uObject*)::g::Fuse::Reactive::Resource::New1(key), 3);
}

// public ResourceBinding New(Uno.UX.Property target, string key) [static] :343
ResourceBinding* ResourceBinding::New2(::g::Uno::UX::Property* target, uString* key)
{
    ResourceBinding* obj1 = (ResourceBinding*)uNew(ResourceBinding_typeof());
    obj1->ctor_3(target, key);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Subscription\ResourceSubscription.uno
// ----------------------------------------------------------------------------------------------------------------------

// internal sealed class ResourceSubscription :7
// {
static void ResourceSubscription_build(uType* type)
{
    ::STRINGS[120] = uString::Const("{Resource ");
    ::STRINGS[54] = uString::Const("} not found in data context");
    ::TYPES[37] = ::g::Uno::Action_typeof();
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    ::TYPES[63] = ::g::Uno::Predicate_typeof()->MakeType(uObject_typeof(), NULL);
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof(),
        ::g::Fuse::Resources::ResourceRegistry_typeof());
    type->SetInterfaces(
        ::TYPES[3/*Uno.IDisposable*/], offsetof(ResourceSubscription_type, interface0));
    type->SetFields(0,
        ::g::Fuse::Node_typeof(), offsetof(ResourceSubscription, _origin), 0,
        ::g::Uno::String_typeof(), offsetof(ResourceSubscription, _key), 0,
        ::g::Uno::Type_typeof(), offsetof(ResourceSubscription, _type), 0,
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(ResourceSubscription, _listener), 0,
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(ResourceSubscription, _source), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(ResourceSubscription, _diag), 0);
}

ResourceSubscription_type* ResourceSubscription_typeof()
{
    static uSStrong<ResourceSubscription_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 6;
    options.InterfaceCount = 1;
    options.DependencyCount = 2;
    options.ObjectSize = sizeof(ResourceSubscription);
    options.TypeSize = sizeof(ResourceSubscription_type);
    type = (ResourceSubscription_type*)uClassType::New("Fuse.Reactive.ResourceSubscription", options);
    type->fp_build_ = ResourceSubscription_build;
    type->interface0.fp_Dispose = (void(*)(uObject*))ResourceSubscription__Dispose_fn;
    return type;
}

// public ResourceSubscription(Fuse.Reactive.IExpression source, Fuse.Node origin, string key, Fuse.Reactive.IListener listener, Uno.Type type) :16
void ResourceSubscription__ctor__fn(ResourceSubscription* __this, uObject* source, ::g::Fuse::Node* origin, uString* key, uObject* listener, uType* type)
{
    __this->ctor_(source, origin, key, listener, type);
}

// private bool Accept(object o) :60
void ResourceSubscription__Accept_fn(ResourceSubscription* __this, uObject* o, bool* __retval)
{
    *__retval = __this->Accept(o);
}

// private void ClearDiagnostic() :36
void ResourceSubscription__ClearDiagnostic_fn(ResourceSubscription* __this)
{
    __this->ClearDiagnostic();
}

// public void Dispose() :28
void ResourceSubscription__Dispose_fn(ResourceSubscription* __this)
{
    __this->Dispose();
}

// public ResourceSubscription New(Fuse.Reactive.IExpression source, Fuse.Node origin, string key, Fuse.Reactive.IListener listener, Uno.Type type) :16
void ResourceSubscription__New1_fn(uObject* source, ::g::Fuse::Node* origin, uString* key, uObject* listener, uType* type, ResourceSubscription** __retval)
{
    *__retval = ResourceSubscription::New1(source, origin, key, listener, type);
}

// private void OnChanged() :45
void ResourceSubscription__OnChanged_fn(ResourceSubscription* __this)
{
    __this->OnChanged();
}

// public ResourceSubscription(Fuse.Reactive.IExpression source, Fuse.Node origin, string key, Fuse.Reactive.IListener listener, Uno.Type type) [instance] :16
void ResourceSubscription::ctor_(uObject* source, ::g::Fuse::Node* origin, uString* key, uObject* listener, uType* type)
{
    uStackFrame __("Fuse.Reactive.ResourceSubscription", ".ctor(Fuse.Reactive.IExpression,Fuse.Node,string,Fuse.Reactive.IListener,Uno.Type)");
    _source = source;
    _origin = origin;
    _key = key;
    _type = type;
    _listener = listener;
    ::g::Fuse::Resources::ResourceRegistry::AddResourceChangedHandler(_key, uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)ResourceSubscription__OnChanged_fn, this));
    OnChanged();
}

// private bool Accept(object o) [instance] :60
bool ResourceSubscription::Accept(uObject* o)
{
    uStackFrame __("Fuse.Reactive.ResourceSubscription", "Accept(object)");
    return ::g::Fuse::Marshal::Is(o, _type);
}

// private void ClearDiagnostic() [instance] :36
void ResourceSubscription::ClearDiagnostic()
{
    uStackFrame __("Fuse.Reactive.ResourceSubscription", "ClearDiagnostic()");

    if (_diag != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_diag), ::TYPES[3/*Uno.IDisposable*/]));
        _diag = NULL;
    }
}

// public void Dispose() [instance] :28
void ResourceSubscription::Dispose()
{
    uStackFrame __("Fuse.Reactive.ResourceSubscription", "Dispose()");
    ClearDiagnostic();
    ::g::Fuse::Resources::ResourceRegistry::RemoveResourceChangedHandler(_key, uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)ResourceSubscription__OnChanged_fn, this));
    _listener = NULL;
    _origin = NULL;
}

// private void OnChanged() [instance] :45
void ResourceSubscription::OnChanged()
{
    uStackFrame __("Fuse.Reactive.ResourceSubscription", "OnChanged()");
    ClearDiagnostic();
    uObject* resource;

    if (uPtr(_origin)->TryGetResource(_key, uDelegate::New(::TYPES[63/*Uno.Predicate<object>*/], (void*)ResourceSubscription__Accept_fn, this), &resource))
        ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), _source, resource);
    else
        _diag = ::g::Fuse::Diagnostics::ReportTemporalUserWarning(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::STRINGS[120/*"{Resource "*/], _key), ::STRINGS[54/*"} not found...*/]), _origin);
}

// public ResourceSubscription New(Fuse.Reactive.IExpression source, Fuse.Node origin, string key, Fuse.Reactive.IListener listener, Uno.Type type) [static] :16
ResourceSubscription* ResourceSubscription::New1(uObject* source, ::g::Fuse::Node* origin, uString* key, uObject* listener, uType* type)
{
    ResourceSubscription* obj1 = (ResourceSubscription*)uNew(ResourceSubscription_typeof());
    obj1->ctor_(source, origin, key, listener, type);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Round :391
// {
static void Round_build(uType* type)
{
    ::STRINGS[121] = uString::Const("operand");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Round__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Round_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Round);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Round", options);
    type->fp_build_ = Round_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Round(Fuse.Reactive.Expression operand) :394
void Round__ctor_5_fn(Round* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Round New(Fuse.Reactive.Expression operand) :394
void Round__New1_fn(::g::Fuse::Reactive::Expression* operand, Round** __retval)
{
    *__retval = Round::New1(operand);
}

// public Round(Fuse.Reactive.Expression operand) [instance] :394
void Round::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[121/*"operand"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Round_fn));
}

// public Round New(Fuse.Reactive.Expression operand) [static] :394
Round* Round::New1(::g::Fuse::Reactive::Expression* operand)
{
    Round* obj1 = (Round*)uNew(Round_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\With.uno
// -----------------------------------------------------------------------------------------

// public sealed class Select :101
// {
static void Select_build(uType* type)
{
    ::STRINGS[122] = uString::Const("'Select' is deprecated, use 'With' instead (works the same way). ");
    ::STRINGS[123] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Bindings\\1.8.1\\With.uno");
    ::STRINGS[124] = uString::Const(".ctor");
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::With_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::With_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::With_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::With_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::With_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::With_type, interface5),
        ::g::Fuse::Animations::IUnwrappedPlayerFeedback_typeof(), offsetof(::g::Fuse::Reactive::With_type, interface6),
        ::g::Fuse::Animations::IBasePlayerFeedback_typeof(), offsetof(::g::Fuse::Reactive::With_type, interface7),
        ::g::Fuse::Node__ISubtreeDataProvider_typeof(), offsetof(::g::Fuse::Reactive::With_type, interface8),
        ::g::Fuse::Reactive::ValueForwarder__IValueListener_typeof(), offsetof(::g::Fuse::Reactive::With_type, interface9));
    type->SetFields(40);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Select__New3_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::With_type* Select_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::With_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::With_typeof();
    options.FieldCount = 40;
    options.InterfaceCount = 10;
    options.ObjectSize = sizeof(Select);
    options.TypeSize = sizeof(::g::Fuse::Reactive::With_type);
    type = (::g::Fuse::Reactive::With_type*)uClassType::New("Fuse.Reactive.Select", options);
    type->fp_build_ = Select_build;
    type->fp_ctor_ = (void*)Select__New3_fn;
    type->interface8.fp_TryGetDataProvider = (void(*)(uObject*, ::g::Fuse::Node*, int32_t*, uObject**, int32_t*))::g::Fuse::Reactive::With__FuseNodeISubtreeDataProviderTryGetDataProvider_fn;
    type->interface9.fp_NewValue = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::With__FuseReactiveValueForwarderIValueListenerNewValue_fn;
    type->interface9.fp_LostValue = (void(*)(uObject*))::g::Fuse::Reactive::With__FuseReactiveValueForwarderIValueListenerLostValue_fn;
    type->interface7.fp_OnPlaybackDone = (void(*)(uObject*, uObject*))::g::Fuse::Triggers::Trigger__FuseAnimationsIBasePlayerFeedbackOnPlaybackDone_fn;
    type->interface7.fp_OnStable = (void(*)(uObject*, uObject*))::g::Fuse::Triggers::Trigger__FuseAnimationsIBasePlayerFeedbackOnStable_fn;
    type->interface6.fp_OnProgressUpdated = (void(*)(uObject*, uObject*, double*, double*, int32_t*))::g::Fuse::Triggers::Trigger__FuseAnimationsIUnwrappedPlayerFeedbackOnProgressUpdated_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public Select() :103
void Select__ctor_6_fn(Select* __this)
{
    __this->ctor_6();
}

// public Select New() :103
void Select__New3_fn(Select** __retval)
{
    *__retval = Select::New3();
}

// public Select() [instance] :103
void Select::ctor_6()
{
    ctor_5();
    ::g::Fuse::Diagnostics::Deprecated(::STRINGS[122/*"'Select' is...*/], this, ::STRINGS[123/*"C:\\Users\\...*/], 105, ::STRINGS[124/*".ctor"*/]);
}

// public Select New() [static] :103
Select* Select::New3()
{
    Select* obj1 = (Select*)uNew(Select_typeof());
    obj1->ctor_6();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Sign :375
// {
static void Sign_build(uType* type)
{
    ::STRINGS[125] = uString::Const("sign");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Sign__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Sign_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Sign);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Sign", options);
    type->fp_build_ = Sign_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Sign(Fuse.Reactive.Expression operand) :378
void Sign__ctor_5_fn(Sign* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Sign New(Fuse.Reactive.Expression operand) :378
void Sign__New1_fn(::g::Fuse::Reactive::Expression* operand, Sign** __retval)
{
    *__retval = Sign::New1(operand);
}

// public Sign(Fuse.Reactive.Expression operand) [instance] :378
void Sign::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[125/*"sign"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Sign_fn));
}

// public Sign New(Fuse.Reactive.Expression operand) [static] :378
Sign* Sign::New1(::g::Fuse::Reactive::Expression* operand)
{
    Sign* obj1 = (Sign*)uNew(Sign_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\VarArgFunction.uno
// ------------------------------------------------------------------------------------------------------

// private sealed class SimpleVarArgFunction.SimpleSubscription :145
// {
static void SimpleVarArgFunction__SimpleSubscription_build(uType* type)
{
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(::g::Fuse::Reactive::VarArgFunction__Subscription_type, interface0),
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(::g::Fuse::Reactive::VarArgFunction__Subscription_type, interface1));
    type->SetFields(7,
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(SimpleVarArgFunction__SimpleSubscription, _listener), 0,
        ::g::Fuse::Reactive::SimpleVarArgFunction_typeof(), offsetof(SimpleVarArgFunction__SimpleSubscription, _func1), 0);
}

::g::Fuse::Reactive::VarArgFunction__Subscription_type* SimpleVarArgFunction__SimpleSubscription_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::VarArgFunction__Subscription_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::VarArgFunction__Subscription_typeof();
    options.FieldCount = 9;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(SimpleVarArgFunction__SimpleSubscription);
    options.TypeSize = sizeof(::g::Fuse::Reactive::VarArgFunction__Subscription_type);
    type = (::g::Fuse::Reactive::VarArgFunction__Subscription_type*)uClassType::New("Fuse.Reactive.SimpleVarArgFunction.SimpleSubscription", options);
    type->fp_build_ = SimpleVarArgFunction__SimpleSubscription_build;
    type->fp_Dispose = (void(*)(::g::Fuse::Reactive::InnerListener*))SimpleVarArgFunction__SimpleSubscription__Dispose_fn;
    type->fp_OnNewArguments = (void(*)(::g::Fuse::Reactive::VarArgFunction__Subscription*, uArray*))SimpleVarArgFunction__SimpleSubscription__OnNewArguments_fn;
    type->fp_OnNewPartialArguments = (void(*)(::g::Fuse::Reactive::VarArgFunction__Subscription*, uArray*))SimpleVarArgFunction__SimpleSubscription__OnNewPartialArguments_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))SimpleVarArgFunction__SimpleSubscription__Dispose_fn;
    return type;
}

// public SimpleSubscription(Fuse.Reactive.SimpleVarArgFunction func, Fuse.Reactive.IListener listener) :150
void SimpleVarArgFunction__SimpleSubscription__ctor_4_fn(SimpleVarArgFunction__SimpleSubscription* __this, ::g::Fuse::Reactive::SimpleVarArgFunction* func, uObject* listener)
{
    __this->ctor_4(func, listener);
}

// public override sealed void Dispose() :167
void SimpleVarArgFunction__SimpleSubscription__Dispose_fn(SimpleVarArgFunction__SimpleSubscription* __this)
{
    __this->_listener = NULL;
    __this->_func1 = NULL;
    ::g::Fuse::Reactive::VarArgFunction__Subscription__Dispose_fn(__this);
}

// public SimpleSubscription New(Fuse.Reactive.SimpleVarArgFunction func, Fuse.Reactive.IListener listener) :150
void SimpleVarArgFunction__SimpleSubscription__New1_fn(::g::Fuse::Reactive::SimpleVarArgFunction* func, uObject* listener, SimpleVarArgFunction__SimpleSubscription** __retval)
{
    *__retval = SimpleVarArgFunction__SimpleSubscription::New1(func, listener);
}

// protected override sealed void OnNewArguments(Fuse.Reactive.Expression.Argument[] args) :162
void SimpleVarArgFunction__SimpleSubscription__OnNewArguments_fn(SimpleVarArgFunction__SimpleSubscription* __this, uArray* args)
{
    uStackFrame __("Fuse.Reactive.SimpleVarArgFunction.SimpleSubscription", "OnNewArguments(Fuse.Reactive.Expression.Argument[])");
    uPtr(__this->_func1)->OnNewArguments(args, __this->_listener);
}

// protected override sealed void OnNewPartialArguments(Fuse.Reactive.Expression.Argument[] args) :157
void SimpleVarArgFunction__SimpleSubscription__OnNewPartialArguments_fn(SimpleVarArgFunction__SimpleSubscription* __this, uArray* args)
{
    uStackFrame __("Fuse.Reactive.SimpleVarArgFunction.SimpleSubscription", "OnNewPartialArguments(Fuse.Reactive.Expression.Argument[])");
    uPtr(__this->_func1)->OnNewPartialArguments(args, __this->_listener);
}

// public SimpleSubscription(Fuse.Reactive.SimpleVarArgFunction func, Fuse.Reactive.IListener listener) [instance] :150
void SimpleVarArgFunction__SimpleSubscription::ctor_4(::g::Fuse::Reactive::SimpleVarArgFunction* func, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.SimpleVarArgFunction.SimpleSubscription", ".ctor(Fuse.Reactive.SimpleVarArgFunction,Fuse.Reactive.IListener)");
    ctor_2(func);
    _func1 = func;
    _listener = listener;
}

// public SimpleSubscription New(Fuse.Reactive.SimpleVarArgFunction func, Fuse.Reactive.IListener listener) [static] :150
SimpleVarArgFunction__SimpleSubscription* SimpleVarArgFunction__SimpleSubscription::New1(::g::Fuse::Reactive::SimpleVarArgFunction* func, uObject* listener)
{
    SimpleVarArgFunction__SimpleSubscription* obj1 = (SimpleVarArgFunction__SimpleSubscription*)uNew(SimpleVarArgFunction__SimpleSubscription_typeof());
    obj1->ctor_4(func, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\VarArgFunction.uno
// ------------------------------------------------------------------------------------------------------

// public abstract class SimpleVarArgFunction :106
// {
static void SimpleVarArgFunction_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(SimpleVarArgFunction_type, interface0));
    type->SetFields(1);
}

SimpleVarArgFunction_type* SimpleVarArgFunction_typeof()
{
    static uSStrong<SimpleVarArgFunction_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::VarArgFunction_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(SimpleVarArgFunction);
    options.TypeSize = sizeof(SimpleVarArgFunction_type);
    type = (SimpleVarArgFunction_type*)uClassType::New("Fuse.Reactive.SimpleVarArgFunction", options);
    type->fp_build_ = SimpleVarArgFunction_build;
    type->fp_OnNewArguments = SimpleVarArgFunction__OnNewArguments_fn;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))SimpleVarArgFunction__Subscribe_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))SimpleVarArgFunction__Subscribe_fn;
    return type;
}

// protected generated SimpleVarArgFunction() :106
void SimpleVarArgFunction__ctor_2_fn(SimpleVarArgFunction* __this)
{
    __this->ctor_2();
}

// protected virtual void OnNewArguments(Fuse.Reactive.Expression.Argument[] args, Fuse.Reactive.IListener listener) :140
void SimpleVarArgFunction__OnNewArguments_fn(SimpleVarArgFunction* __this, uArray* args, uObject* listener)
{
}

// protected void OnNewPartialArguments(Fuse.Reactive.Expression.Argument[] args, Fuse.Reactive.IListener listener) :125
void SimpleVarArgFunction__OnNewPartialArguments_fn(SimpleVarArgFunction* __this, uArray* args, uObject* listener)
{
    __this->OnNewPartialArguments(args, listener);
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :108
void SimpleVarArgFunction__Subscribe_fn(SimpleVarArgFunction* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.SimpleVarArgFunction", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    SimpleVarArgFunction__SimpleSubscription* ss = SimpleVarArgFunction__SimpleSubscription::New1(__this, listener);
    ss->Init(context);
    return *__retval = (uObject*)ss, void();
}

// protected generated SimpleVarArgFunction() [instance] :106
void SimpleVarArgFunction::ctor_2()
{
    ctor_1();
}

// protected void OnNewPartialArguments(Fuse.Reactive.Expression.Argument[] args, Fuse.Reactive.IListener listener) [instance] :125
void SimpleVarArgFunction::OnNewPartialArguments(uArray* args, uObject* listener)
{
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Sin :195
// {
static void Sin_build(uType* type)
{
    ::STRINGS[126] = uString::Const("sin");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Sin__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Sin_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Sin);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Sin", options);
    type->fp_build_ = Sin_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Sin(Fuse.Reactive.Expression operand) :198
void Sin__ctor_5_fn(Sin* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Sin New(Fuse.Reactive.Expression operand) :198
void Sin__New1_fn(::g::Fuse::Reactive::Expression* operand, Sin** __retval)
{
    *__retval = Sin::New1(operand);
}

// public Sin(Fuse.Reactive.Expression operand) [instance] :198
void Sin::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[126/*"sin"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Sin_fn));
}

// public Sin New(Fuse.Reactive.Expression operand) [static] :198
Sin* Sin::New1(::g::Fuse::Reactive::Expression* operand)
{
    Sin* obj1 = (Sin*)uNew(Sin_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Snapshot.uno
// ------------------------------------------------------------------------------------------------

// public sealed class Snapshot :8
// {
static void Snapshot_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->SetFields(0,
        ::g::Fuse::Reactive::Expression_typeof(), offsetof(Snapshot, _Source), 0);
    type->Reflection.SetFunctions(2,
        new uFunction(".ctor", NULL, (void*)Snapshot__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()),
        new uFunction("get_Source", NULL, (void*)Snapshot__get_Source_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0));
}

::g::Fuse::Reactive::Expression_type* Snapshot_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Snapshot);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.Snapshot", options);
    type->fp_build_ = Snapshot_build;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))Snapshot__Subscribe_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))Snapshot__Subscribe_fn;
    return type;
}

// public Snapshot(Fuse.Reactive.Expression source) :13
void Snapshot__ctor_1_fn(Snapshot* __this, ::g::Fuse::Reactive::Expression* source)
{
    __this->ctor_1(source);
}

// public Snapshot New(Fuse.Reactive.Expression source) :13
void Snapshot__New1_fn(::g::Fuse::Reactive::Expression* source, Snapshot** __retval)
{
    *__retval = Snapshot::New1(source);
}

// public generated Fuse.Reactive.Expression get_Source() :10
void Snapshot__get_Source_fn(Snapshot* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->Source();
}

// private generated void set_Source(Fuse.Reactive.Expression value) :10
void Snapshot__set_Source_fn(Snapshot* __this, ::g::Fuse::Reactive::Expression* value)
{
    __this->Source(value);
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :18
void Snapshot__Subscribe_fn(Snapshot* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.Snapshot", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    return *__retval = (uObject*)Snapshot__Subscription::New1(__this, context, listener), void();
}

// public Snapshot(Fuse.Reactive.Expression source) [instance] :13
void Snapshot::ctor_1(::g::Fuse::Reactive::Expression* source)
{
    ctor_();
    Source(source);
}

// public generated Fuse.Reactive.Expression get_Source() [instance] :10
::g::Fuse::Reactive::Expression* Snapshot::Source()
{
    return _Source;
}

// private generated void set_Source(Fuse.Reactive.Expression value) [instance] :10
void Snapshot::Source(::g::Fuse::Reactive::Expression* value)
{
    _Source = value;
}

// public Snapshot New(Fuse.Reactive.Expression source) [static] :13
Snapshot* Snapshot::New1(::g::Fuse::Reactive::Expression* source)
{
    Snapshot* obj1 = (Snapshot*)uNew(Snapshot_typeof());
    obj1->ctor_1(source);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Sqrt :295
// {
static void Sqrt_build(uType* type)
{
    ::STRINGS[127] = uString::Const("sqrt");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Sqrt__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Sqrt_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Sqrt);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Sqrt", options);
    type->fp_build_ = Sqrt_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Sqrt(Fuse.Reactive.Expression operand) :298
void Sqrt__ctor_5_fn(Sqrt* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Sqrt New(Fuse.Reactive.Expression operand) :298
void Sqrt__New1_fn(::g::Fuse::Reactive::Expression* operand, Sqrt** __retval)
{
    *__retval = Sqrt::New1(operand);
}

// public Sqrt(Fuse.Reactive.Expression operand) [instance] :298
void Sqrt::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[127/*"sqrt"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Sqrt_fn));
}

// public Sqrt New(Fuse.Reactive.Expression operand) [static] :298
Sqrt* Sqrt::New1(::g::Fuse::Reactive::Expression* operand)
{
    Sqrt* obj1 = (Sqrt*)uNew(Sqrt_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Controls.Panels\1.8.1\Window.uno
// -----------------------------------------------------------------------------------------

// private sealed class WindowFunction.Subscription :43
// {
static void WindowFunction__Subscription_build(uType* type)
{
    ::STRINGS[128] = uString::Const("No RootViewport found in this context");
    ::STRINGS[129] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Controls.Panels\\1.8.1\\Window.uno");
    ::STRINGS[124] = uString::Const(".ctor");
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    type->SetDependencies(
        ::g::Fuse::Reactive::WindowCaps_typeof());
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(WindowFunction__Subscription_type, interface0));
    type->SetFields(0,
        ::g::Fuse::Reactive::WindowFunction_typeof(), offsetof(WindowFunction__Subscription, _func), 0,
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(WindowFunction__Subscription, _listener), 0,
        ::g::Fuse::RootViewport_typeof(), offsetof(WindowFunction__Subscription, _rootViewport), 0,
        ::g::Fuse::Reactive::WindowCaps_typeof(), offsetof(WindowFunction__Subscription, _windowCaps), 0);
}

WindowFunction__Subscription_type* WindowFunction__Subscription_typeof()
{
    static uSStrong<WindowFunction__Subscription_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(WindowFunction__Subscription);
    options.TypeSize = sizeof(WindowFunction__Subscription_type);
    type = (WindowFunction__Subscription_type*)uClassType::New("Fuse.Reactive.WindowFunction.Subscription", options);
    type->fp_build_ = WindowFunction__Subscription_build;
    type->interface0.fp_Dispose = (void(*)(uObject*))WindowFunction__Subscription__Dispose_fn;
    return type;
}

// public Subscription(Fuse.Reactive.WindowFunction func, Fuse.RootViewport rv, Fuse.Reactive.IListener listener) :50
void WindowFunction__Subscription__ctor__fn(WindowFunction__Subscription* __this, ::g::Fuse::Reactive::WindowFunction* func, ::g::Fuse::RootViewport* rv, uObject* listener)
{
    __this->ctor_(func, rv, listener);
}

// public void Dispose() :69
void WindowFunction__Subscription__Dispose_fn(WindowFunction__Subscription* __this)
{
    __this->Dispose();
}

// public void Init() :60
void WindowFunction__Subscription__Init_fn(WindowFunction__Subscription* __this)
{
    __this->Init();
}

// public Subscription New(Fuse.Reactive.WindowFunction func, Fuse.RootViewport rv, Fuse.Reactive.IListener listener) :50
void WindowFunction__Subscription__New1_fn(::g::Fuse::Reactive::WindowFunction* func, ::g::Fuse::RootViewport* rv, uObject* listener, WindowFunction__Subscription** __retval)
{
    *__retval = WindowFunction__Subscription::New1(func, rv, listener);
}

// public Subscription(Fuse.Reactive.WindowFunction func, Fuse.RootViewport rv, Fuse.Reactive.IListener listener) [instance] :50
void WindowFunction__Subscription::ctor_(::g::Fuse::Reactive::WindowFunction* func, ::g::Fuse::RootViewport* rv, uObject* listener)
{
    _func = func;
    _listener = listener;
    _rootViewport = rv;

    if (rv == NULL)
        ::g::Fuse::Diagnostics::UserError(::STRINGS[128/*"No RootView...*/], this, ::STRINGS[129/*"C:\\Users\\...*/], 57, ::STRINGS[124/*".ctor"*/], NULL);
}

// public void Dispose() [instance] :69
void WindowFunction__Subscription::Dispose()
{
    uStackFrame __("Fuse.Reactive.WindowFunction.Subscription", "Dispose()");

    if (_windowCaps != NULL)
    {
        uPtr(_windowCaps)->Detach();
        _windowCaps = NULL;
    }

    _rootViewport = NULL;
    _func = NULL;
    _listener = NULL;
}

// public void Init() [instance] :60
void WindowFunction__Subscription::Init()
{
    uStackFrame __("Fuse.Reactive.WindowFunction.Subscription", "Init()");

    if (_rootViewport == NULL)
        return;

    _windowCaps = ::g::Fuse::Reactive::WindowCaps::Attach(_rootViewport);
    ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_func, _windowCaps);
}

// public Subscription New(Fuse.Reactive.WindowFunction func, Fuse.RootViewport rv, Fuse.Reactive.IListener listener) [static] :50
WindowFunction__Subscription* WindowFunction__Subscription::New1(::g::Fuse::Reactive::WindowFunction* func, ::g::Fuse::RootViewport* rv, uObject* listener)
{
    WindowFunction__Subscription* obj1 = (WindowFunction__Subscription*)uNew(WindowFunction__Subscription_typeof());
    obj1->ctor_(func, rv, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\VarArgFunction.uno
// ------------------------------------------------------------------------------------------------------

// protected abstract class VarArgFunction.Subscription :32
// {
static void VarArgFunction__Subscription_build(uType* type)
{
    ::STRINGS[130] = uString::Const("VarArgFunction.Subscription.ClearData() should be implemented");
    ::STRINGS[131] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Expressions\\1.8.1\\VarArgFunction.uno");
    ::STRINGS[132] = uString::Const("ClearData");
    ::TYPES[64] = ::g::Uno::Collections::EnumerableExtensions_typeof()->MakeMethod(8/*ToArray<Fuse.Reactive.Expression>*/, ::g::Fuse::Reactive::Expression_typeof(), NULL);
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(VarArgFunction__Subscription_type, interface0),
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(VarArgFunction__Subscription_type, interface1));
    type->SetFields(5,
        ::g::Fuse::Reactive::VarArgFunction_typeof(), offsetof(VarArgFunction__Subscription, _func), 0,
        ::g::Fuse::Reactive::IContext_typeof(), offsetof(VarArgFunction__Subscription, _context), 0);
}

VarArgFunction__Subscription_type* VarArgFunction__Subscription_typeof()
{
    static uSStrong<VarArgFunction__Subscription_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ExpressionSubscriber_typeof();
    options.FieldCount = 7;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(VarArgFunction__Subscription);
    options.TypeSize = sizeof(VarArgFunction__Subscription_type);
    type = (VarArgFunction__Subscription_type*)uClassType::New("Fuse.Reactive.VarArgFunction.Subscription", options);
    type->fp_build_ = VarArgFunction__Subscription_build;
    type->fp_Dispose = (void(*)(::g::Fuse::Reactive::InnerListener*))VarArgFunction__Subscription__Dispose_fn;
    type->fp_OnArguments = (void(*)(::g::Fuse::Reactive::ExpressionSubscriber*, uArray*))VarArgFunction__Subscription__OnArguments_fn;
    type->fp_OnClearData = (void(*)(::g::Fuse::Reactive::ExpressionSubscriber*))VarArgFunction__Subscription__OnClearData_fn;
    type->fp_OnNewArguments = VarArgFunction__Subscription__OnNewArguments_fn;
    type->fp_OnNewPartialArguments = VarArgFunction__Subscription__OnNewPartialArguments_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))VarArgFunction__Subscription__Dispose_fn;
    return type;
}

// protected Subscription(Fuse.Reactive.VarArgFunction func) :47
void VarArgFunction__Subscription__ctor_2_fn(VarArgFunction__Subscription* __this, ::g::Fuse::Reactive::VarArgFunction* func)
{
    __this->ctor_2(func);
}

// protected void ClearData() :67
void VarArgFunction__Subscription__ClearData_fn(VarArgFunction__Subscription* __this)
{
    __this->ClearData();
}

// public override void Dispose() :90
void VarArgFunction__Subscription__Dispose_fn(VarArgFunction__Subscription* __this)
{
    uStackFrame __("Fuse.Reactive.VarArgFunction.Subscription", "Dispose()");
    ::g::Fuse::Reactive::ExpressionSubscriber__Dispose_fn(__this);
    __this->_func = NULL;
    __this->_context = NULL;
}

// protected override sealed void OnArguments(Fuse.Reactive.Expression.Argument[] args) :73
void VarArgFunction__Subscription__OnArguments_fn(VarArgFunction__Subscription* __this, uArray* args)
{
    uStackFrame __("Fuse.Reactive.VarArgFunction.Subscription", "OnArguments(Fuse.Reactive.Expression.Argument[])");
    bool all = true;

    for (int32_t i = 0; i < uPtr(args)->Length(); i++)
        if (!uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->HasValue())
        {
            all = false;
            break;
        }

    __this->OnNewPartialArguments(args);

    if (all)
        __this->OnNewArguments(args);
}

// internal override sealed void OnClearData() :62
void VarArgFunction__Subscription__OnClearData_fn(VarArgFunction__Subscription* __this)
{
    uStackFrame __("Fuse.Reactive.VarArgFunction.Subscription", "OnClearData()");
    __this->ClearData();
}

// protected virtual void OnNewArguments(Fuse.Reactive.Expression.Argument[] args) :98
void VarArgFunction__Subscription__OnNewArguments_fn(VarArgFunction__Subscription* __this, uArray* args)
{
}

// protected virtual void OnNewPartialArguments(Fuse.Reactive.Expression.Argument[] args) :97
void VarArgFunction__Subscription__OnNewPartialArguments_fn(VarArgFunction__Subscription* __this, uArray* args)
{
}

// protected Subscription(Fuse.Reactive.VarArgFunction func) [instance] :47
void VarArgFunction__Subscription::ctor_2(::g::Fuse::Reactive::VarArgFunction* func)
{
    uStackFrame __("Fuse.Reactive.VarArgFunction.Subscription", ".ctor(Fuse.Reactive.VarArgFunction)");
    ctor_1((uArray*)::g::Uno::Collections::EnumerableExtensions::ToArray(::TYPES[64/*Uno.Collections.EnumerableExtensions.ToArray<Fuse.Reactive.Expression>*/], uPtr(func)->Arguments()), 1024, NULL);
    _func = func;
}

// protected void ClearData() [instance] :67
void VarArgFunction__Subscription::ClearData()
{
    ::g::Fuse::Diagnostics::UserError(::STRINGS[130/*"VarArgFunct...*/], this, ::STRINGS[131/*"C:\\Users\\...*/], 70, ::STRINGS[132/*"ClearData"*/], NULL);
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Parameter.uno
// -------------------------------------------------------------------------------------------------

// private sealed class Parameter.Subscription :31
// {
static void Parameter__Subscription_build(uType* type)
{
    ::STRINGS[133] = uString::Const("Failed to fetch parameter: ");
    ::STRINGS[134] = uString::Const("Failed to parse parameter: ");
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    ::TYPES[32] = ::g::Uno::Exception_typeof();
    ::TYPES[65] = ::g::Fuse::Visual_typeof();
    ::TYPES[66] = ::g::Uno::EventHandler_typeof();
    type->SetInterfaces(
        ::TYPES[3/*Uno.IDisposable*/], offsetof(::g::Fuse::Reactive::InnerListener_type, interface0),
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(::g::Fuse::Reactive::InnerListener_type, interface1));
    type->SetFields(2,
        ::g::Fuse::Reactive::Parameter_typeof(), offsetof(Parameter__Subscription, _parameter), 0,
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(Parameter__Subscription, _listener), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(Parameter__Subscription, _sub), 0,
        ::TYPES[65/*Fuse.Visual*/], offsetof(Parameter__Subscription, _visual), 0);
}

::g::Fuse::Reactive::InnerListener_type* Parameter__Subscription_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::InnerListener_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InnerListener_typeof();
    options.FieldCount = 6;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(Parameter__Subscription);
    options.TypeSize = sizeof(::g::Fuse::Reactive::InnerListener_type);
    type = (::g::Fuse::Reactive::InnerListener_type*)uClassType::New("Fuse.Reactive.Parameter.Subscription", options);
    type->fp_build_ = Parameter__Subscription_build;
    type->fp_Dispose = (void(*)(::g::Fuse::Reactive::InnerListener*))Parameter__Subscription__Dispose_fn;
    type->fp_OnLostData = (void(*)(::g::Fuse::Reactive::InnerListener*, uObject*))Parameter__Subscription__OnLostData_fn;
    type->fp_OnNewData = (void(*)(::g::Fuse::Reactive::InnerListener*, uObject*, uObject*))Parameter__Subscription__OnNewData_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))Parameter__Subscription__Dispose_fn;
    return type;
}

// public Subscription(Fuse.Reactive.Parameter parameter, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :37
void Parameter__Subscription__ctor_1_fn(Parameter__Subscription* __this, ::g::Fuse::Reactive::Parameter* parameter, uObject* context, uObject* listener)
{
    __this->ctor_1(parameter, context, listener);
}

// public override sealed void Dispose() :44
void Parameter__Subscription__Dispose_fn(Parameter__Subscription* __this)
{
    uStackFrame __("Fuse.Reactive.Parameter.Subscription", "Dispose()");
    __this->UnsubscribeVisual();
    __this->_listener = NULL;

    if (__this->_sub != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(__this->_sub), ::TYPES[3/*Uno.IDisposable*/]));
        __this->_sub = NULL;
    }

    ::g::Fuse::Reactive::InnerListener__Dispose_fn(__this);
}

// public Subscription New(Fuse.Reactive.Parameter parameter, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :37
void Parameter__Subscription__New1_fn(::g::Fuse::Reactive::Parameter* parameter, uObject* context, uObject* listener, Parameter__Subscription** __retval)
{
    *__retval = Parameter__Subscription::New1(parameter, context, listener);
}

// protected override sealed void OnLostData(Fuse.Reactive.IExpression source) :87
void Parameter__Subscription__OnLostData_fn(Parameter__Subscription* __this, uObject* source)
{
    uStackFrame __("Fuse.Reactive.Parameter.Subscription", "OnLostData(Fuse.Reactive.IExpression)");
    __this->ClearDiagnostic();
    __this->UnsubscribeVisual();
    ::g::Fuse::Reactive::IListener::OnLostData(uInterface(uPtr(__this->_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)__this->_parameter);
}

// protected override sealed void OnNewData(Fuse.Reactive.IExpression source, object obj) :67
void Parameter__Subscription__OnNewData_fn(Parameter__Subscription* __this, uObject* source, uObject* obj)
{
    uStackFrame __("Fuse.Reactive.Parameter.Subscription", "OnNewData(Fuse.Reactive.IExpression,object)");
    __this->ClearDiagnostic();
    __this->UnsubscribeVisual();

    try
    {
        {
            __this->_visual = uCast< ::g::Fuse::Visual*>(obj, ::TYPES[65/*Fuse.Visual*/]);
            uPtr(__this->_visual)->add_ParameterChanged(uDelegate::New(::TYPES[66/*Uno.EventHandler*/], (void*)Parameter__Subscription__OnParameterChanged_fn, __this));
        }
    }

    catch (const uThrowable& __t)
    {
        ::g::Uno::Exception* e = __t.Exception;
        __this->SetDiagnostic(::g::Uno::String::op_Addition2(::STRINGS[133/*"Failed to f...*/], uPtr(e)->Message()), __this->_parameter);
        return;
    }

    __this->OnParameterChanged(NULL, NULL);
}

// private void OnParameterChanged(object sender, Uno.EventArgs args) :94
void Parameter__Subscription__OnParameterChanged_fn(Parameter__Subscription* __this, uObject* sender, ::g::Uno::EventArgs* args)
{
    __this->OnParameterChanged(sender, args);
}

// private void UnsubscribeVisual() :56
void Parameter__Subscription__UnsubscribeVisual_fn(Parameter__Subscription* __this)
{
    __this->UnsubscribeVisual();
}

// public Subscription(Fuse.Reactive.Parameter parameter, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) [instance] :37
void Parameter__Subscription::ctor_1(::g::Fuse::Reactive::Parameter* parameter, uObject* context, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.Parameter.Subscription", ".ctor(Fuse.Reactive.Parameter,Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    ctor_();
    _parameter = parameter;
    _listener = listener;
    _sub = uPtr(uPtr(_parameter)->Visual)->Subscribe(context, (uObject*)this);
}

// private void OnParameterChanged(object sender, Uno.EventArgs args) [instance] :94
void Parameter__Subscription::OnParameterChanged(uObject* sender, ::g::Uno::EventArgs* args)
{
    uStackFrame __("Fuse.Reactive.Parameter.Subscription", "OnParameterChanged(object,Uno.EventArgs)");

    if (_visual == NULL)
        return;

    if (::g::Uno::String::op_Equality(uPtr(_visual)->Parameter(), NULL))
        return;

    ClearDiagnostic();
    uObject* data = NULL;

    try
    {
        {
            data = ::g::Fuse::Json::Parse(uPtr(_visual)->Parameter());
        }
    }

    catch (const uThrowable& __t)
    {
        ::g::Uno::Exception* e = __t.Exception;
        SetDiagnostic(::g::Uno::String::op_Addition2(::STRINGS[134/*"Failed to p...*/], uPtr(e)->Message()), _parameter);
        return;
    }

    ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_parameter, data);
}

// private void UnsubscribeVisual() [instance] :56
void Parameter__Subscription::UnsubscribeVisual()
{
    uStackFrame __("Fuse.Reactive.Parameter.Subscription", "UnsubscribeVisual()");

    if (_visual != NULL)
    {
        uPtr(_visual)->remove_ParameterChanged(uDelegate::New(::TYPES[66/*Uno.EventHandler*/], (void*)Parameter__Subscription__OnParameterChanged_fn, this));
        _visual = NULL;
    }
}

// public Subscription New(Fuse.Reactive.Parameter parameter, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) [static] :37
Parameter__Subscription* Parameter__Subscription::New1(::g::Fuse::Reactive::Parameter* parameter, uObject* context, uObject* listener)
{
    Parameter__Subscription* obj1 = (Parameter__Subscription*)uNew(Parameter__Subscription_typeof());
    obj1->ctor_1(parameter, context, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\PlatformFunctions.uno
// ---------------------------------------------------------------------------------------------------------

// private sealed class PlatformFunction.Subscription :33
// {
static void PlatformFunction__Subscription_build(uType* type)
{
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(PlatformFunction__Subscription_type, interface0));
    type->SetFields(0,
        ::g::Fuse::Reactive::PlatformFunction_typeof(), offsetof(PlatformFunction__Subscription, _func), 0,
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(PlatformFunction__Subscription, _listener), 0);
}

PlatformFunction__Subscription_type* PlatformFunction__Subscription_typeof()
{
    static uSStrong<PlatformFunction__Subscription_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 2;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(PlatformFunction__Subscription);
    options.TypeSize = sizeof(PlatformFunction__Subscription_type);
    type = (PlatformFunction__Subscription_type*)uClassType::New("Fuse.Reactive.PlatformFunction.Subscription", options);
    type->fp_build_ = PlatformFunction__Subscription_build;
    type->interface0.fp_Dispose = (void(*)(uObject*))PlatformFunction__Subscription__Dispose_fn;
    return type;
}

// public Subscription(Fuse.Reactive.PlatformFunction func, Fuse.Reactive.IListener listener) :38
void PlatformFunction__Subscription__ctor__fn(PlatformFunction__Subscription* __this, ::g::Fuse::Reactive::PlatformFunction* func, uObject* listener)
{
    __this->ctor_(func, listener);
}

// public void Dispose() :49
void PlatformFunction__Subscription__Dispose_fn(PlatformFunction__Subscription* __this)
{
    __this->Dispose();
}

// public void Init() :44
void PlatformFunction__Subscription__Init_fn(PlatformFunction__Subscription* __this)
{
    __this->Init();
}

// public Subscription New(Fuse.Reactive.PlatformFunction func, Fuse.Reactive.IListener listener) :38
void PlatformFunction__Subscription__New1_fn(::g::Fuse::Reactive::PlatformFunction* func, uObject* listener, PlatformFunction__Subscription** __retval)
{
    *__retval = PlatformFunction__Subscription::New1(func, listener);
}

// public Subscription(Fuse.Reactive.PlatformFunction func, Fuse.Reactive.IListener listener) [instance] :38
void PlatformFunction__Subscription::ctor_(::g::Fuse::Reactive::PlatformFunction* func, uObject* listener)
{
    _func = func;
    _listener = listener;
}

// public void Dispose() [instance] :49
void PlatformFunction__Subscription::Dispose()
{
    _func = NULL;
    _listener = NULL;
}

// public void Init() [instance] :44
void PlatformFunction__Subscription::Init()
{
    uStackFrame __("Fuse.Reactive.PlatformFunction.Subscription", "Init()");
    ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_func, uBox(::TYPES[12/*bool*/], uPtr(_func)->GetResult()));
}

// public Subscription New(Fuse.Reactive.PlatformFunction func, Fuse.Reactive.IListener listener) [static] :38
PlatformFunction__Subscription* PlatformFunction__Subscription::New1(::g::Fuse::Reactive::PlatformFunction* func, uObject* listener)
{
    PlatformFunction__Subscription* obj1 = (PlatformFunction__Subscription*)uNew(PlatformFunction__Subscription_typeof());
    obj1->ctor_(func, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\DataFunction.uno
// -------------------------------------------------------------------------------------------------

// private sealed class DataFunction.Subscription :40
// {
static void DataFunction__Subscription_build(uType* type)
{
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(DataFunction__Subscription_type, interface0),
        ::g::Fuse::Node__IDataListener_typeof(), offsetof(DataFunction__Subscription_type, interface1));
    type->SetFields(0,
        ::g::Fuse::Reactive::DataFunction_typeof(), offsetof(DataFunction__Subscription, _expr), 0,
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(DataFunction__Subscription, _listener), 0,
        ::g::Fuse::Node_typeof(), offsetof(DataFunction__Subscription, _node), 0,
        ::g::Fuse::Node__NodeDataSubscription_typeof(), offsetof(DataFunction__Subscription, _dataSub), 0);
}

DataFunction__Subscription_type* DataFunction__Subscription_typeof()
{
    static uSStrong<DataFunction__Subscription_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 4;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(DataFunction__Subscription);
    options.TypeSize = sizeof(DataFunction__Subscription_type);
    type = (DataFunction__Subscription_type*)uClassType::New("Fuse.Reactive.DataFunction.Subscription", options);
    type->fp_build_ = DataFunction__Subscription_build;
    type->interface1.fp_OnDataChanged = (void(*)(uObject*))DataFunction__Subscription__FuseNodeIDataListenerOnDataChanged_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))DataFunction__Subscription__Dispose_fn;
    return type;
}

// public Subscription(Fuse.Reactive.DataFunction expr, Fuse.Reactive.IListener listener, Fuse.Node node) :48
void DataFunction__Subscription__ctor__fn(DataFunction__Subscription* __this, ::g::Fuse::Reactive::DataFunction* expr, uObject* listener, ::g::Fuse::Node* node)
{
    __this->ctor_(expr, listener, node);
}

// public void Dispose() :77
void DataFunction__Subscription__Dispose_fn(DataFunction__Subscription* __this)
{
    __this->Dispose();
}

// private void Fuse.Node.IDataListener.OnDataChanged() :61
void DataFunction__Subscription__FuseNodeIDataListenerOnDataChanged_fn(DataFunction__Subscription* __this)
{
    uStackFrame __("Fuse.Reactive.DataFunction.Subscription", "Fuse.Node.IDataListener.OnDataChanged()");
    __this->UpdateData();
}

// public void Init() :55
void DataFunction__Subscription__Init_fn(DataFunction__Subscription* __this)
{
    __this->Init();
}

// public Subscription New(Fuse.Reactive.DataFunction expr, Fuse.Reactive.IListener listener, Fuse.Node node) :48
void DataFunction__Subscription__New1_fn(::g::Fuse::Reactive::DataFunction* expr, uObject* listener, ::g::Fuse::Node* node, DataFunction__Subscription** __retval)
{
    *__retval = DataFunction__Subscription::New1(expr, listener, node);
}

// private void UpdateData() :66
void DataFunction__Subscription__UpdateData_fn(DataFunction__Subscription* __this)
{
    __this->UpdateData();
}

// public Subscription(Fuse.Reactive.DataFunction expr, Fuse.Reactive.IListener listener, Fuse.Node node) [instance] :48
void DataFunction__Subscription::ctor_(::g::Fuse::Reactive::DataFunction* expr, uObject* listener, ::g::Fuse::Node* node)
{
    _expr = expr;
    _listener = listener;
    _node = node;
}

// public void Dispose() [instance] :77
void DataFunction__Subscription::Dispose()
{
    uStackFrame __("Fuse.Reactive.DataFunction.Subscription", "Dispose()");

    if (_dataSub != NULL)
    {
        uPtr(_dataSub)->Dispose();
        _dataSub = NULL;
    }

    _expr = NULL;
    _listener = NULL;
    _node = NULL;
}

// public void Init() [instance] :55
void DataFunction__Subscription::Init()
{
    uStackFrame __("Fuse.Reactive.DataFunction.Subscription", "Init()");
    _dataSub = uPtr(_node)->SubscribePrimeDataContext((uObject*)this);
    UpdateData();
}

// private void UpdateData() [instance] :66
void DataFunction__Subscription::UpdateData()
{
    uStackFrame __("Fuse.Reactive.DataFunction.Subscription", "UpdateData()");

    if (_dataSub == NULL)
        return;

    if (!uPtr(_dataSub)->HasData())
        ::g::Fuse::Reactive::IListener::OnLostData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_expr);
    else
        ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_expr, uPtr(_dataSub)->Data());
}

// public Subscription New(Fuse.Reactive.DataFunction expr, Fuse.Reactive.IListener listener, Fuse.Node node) [static] :48
DataFunction__Subscription* DataFunction__Subscription::New1(::g::Fuse::Reactive::DataFunction* expr, uObject* listener, ::g::Fuse::Node* node)
{
    DataFunction__Subscription* obj1 = (DataFunction__Subscription*)uNew(DataFunction__Subscription_typeof());
    obj1->ctor_(expr, listener, node);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Property.uno
// ------------------------------------------------------------------------------------------------

// private sealed class Property.Subscription :25
// {
static void Property__Subscription_build(uType* type)
{
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(Property__Subscription_type, interface0),
        ::g::Fuse::Reactive::IWriteable_typeof(), offsetof(Property__Subscription_type, interface1),
        ::g::Uno::IDisposable_typeof(), offsetof(Property__Subscription_type, interface2));
    type->SetFields(0,
        ::g::Fuse::Reactive::Property_typeof(), offsetof(Property__Subscription, _prop), 0,
        ::g::Uno::UX::PropertyObject_typeof(), offsetof(Property__Subscription, _object), 0,
        ::g::Uno::UX::PropertyAccessor_typeof(), offsetof(Property__Subscription, _accessor), 0,
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(Property__Subscription, _listener), 0);
}

Property__Subscription_type* Property__Subscription_typeof()
{
    static uSStrong<Property__Subscription_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 4;
    options.InterfaceCount = 3;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(Property__Subscription);
    options.TypeSize = sizeof(Property__Subscription_type);
    type = (Property__Subscription_type*)uClassType::New("Fuse.Reactive.Property.Subscription", options);
    type->fp_build_ = Property__Subscription_build;
    type->interface0.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))Property__Subscription__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface1.fp_TrySetExclusive = (void(*)(uObject*, uObject*, bool*))Property__Subscription__TrySetExclusive_fn;
    type->interface2.fp_Dispose = (void(*)(uObject*))Property__Subscription__Dispose_fn;
    return type;
}

// public Subscription(Fuse.Reactive.Property prop, Uno.UX.PropertyObject obj, Uno.UX.PropertyAccessor accessor, Fuse.Reactive.IListener listener) :32
void Property__Subscription__ctor__fn(Property__Subscription* __this, ::g::Fuse::Reactive::Property* prop, ::g::Uno::UX::PropertyObject* obj, ::g::Uno::UX::PropertyAccessor* accessor, uObject* listener)
{
    __this->ctor_(prop, obj, accessor, listener);
}

// public void Dispose() :55
void Property__Subscription__Dispose_fn(Property__Subscription* __this)
{
    __this->Dispose();
}

// public Subscription New(Fuse.Reactive.Property prop, Uno.UX.PropertyObject obj, Uno.UX.PropertyAccessor accessor, Fuse.Reactive.IListener listener) :32
void Property__Subscription__New1_fn(::g::Fuse::Reactive::Property* prop, ::g::Uno::UX::PropertyObject* obj, ::g::Uno::UX::PropertyAccessor* accessor, uObject* listener, Property__Subscription** __retval)
{
    *__retval = Property__Subscription::New1(prop, obj, accessor, listener);
}

// private void PushValue() :68
void Property__Subscription__PushValue_fn(Property__Subscription* __this)
{
    __this->PushValue();
}

// public bool TrySetExclusive(object value) :44
void Property__Subscription__TrySetExclusive_fn(Property__Subscription* __this, uObject* value, bool* __retval)
{
    *__retval = __this->TrySetExclusive(value);
}

// private void Uno.UX.IPropertyListener.OnPropertyChanged(Uno.UX.PropertyObject obj, Uno.UX.Selector prop) :63
void Property__Subscription__UnoUXIPropertyListenerOnPropertyChanged_fn(Property__Subscription* __this, ::g::Uno::UX::PropertyObject* obj, ::g::Uno::UX::Selector* prop)
{
    uStackFrame __("Fuse.Reactive.Property.Subscription", "Uno.UX.IPropertyListener.OnPropertyChanged(Uno.UX.PropertyObject,Uno.UX.Selector)");
    ::g::Uno::UX::Selector prop_ = *prop;

    if (::g::Uno::UX::Selector__op_Equality(prop_, uPtr(__this->_accessor)->Name()))
        __this->PushValue();
}

// public Subscription(Fuse.Reactive.Property prop, Uno.UX.PropertyObject obj, Uno.UX.PropertyAccessor accessor, Fuse.Reactive.IListener listener) [instance] :32
void Property__Subscription::ctor_(::g::Fuse::Reactive::Property* prop, ::g::Uno::UX::PropertyObject* obj, ::g::Uno::UX::PropertyAccessor* accessor, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.Property.Subscription", ".ctor(Fuse.Reactive.Property,Uno.UX.PropertyObject,Uno.UX.PropertyAccessor,Fuse.Reactive.IListener)");
    _prop = prop;
    _listener = listener;
    _accessor = accessor;
    _object = obj;
    uPtr(_object)->AddPropertyListener((uObject*)this);
    PushValue();
}

// public void Dispose() [instance] :55
void Property__Subscription::Dispose()
{
    uStackFrame __("Fuse.Reactive.Property.Subscription", "Dispose()");
    uPtr(_object)->RemovePropertyListener((uObject*)this);
    _accessor = NULL;
    _object = NULL;
    _listener = NULL;
}

// private void PushValue() [instance] :68
void Property__Subscription::PushValue()
{
    uStackFrame __("Fuse.Reactive.Property.Subscription", "PushValue()");
    ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)_prop, uPtr(_accessor)->GetAsObject(_object));
}

// public bool TrySetExclusive(object value) [instance] :44
bool Property__Subscription::TrySetExclusive(uObject* value)
{
    uStackFrame __("Fuse.Reactive.Property.Subscription", "TrySetExclusive(object)");
    uObject* res;

    if (::g::Fuse::Marshal::TryConvertTo(uPtr(_accessor)->PropertyType(), value, &res, _object))
    {
        uPtr(_accessor)->SetAsObject(_object, res, (uObject*)this);
        return true;
    }

    return false;
}

// public Subscription New(Fuse.Reactive.Property prop, Uno.UX.PropertyObject obj, Uno.UX.PropertyAccessor accessor, Fuse.Reactive.IListener listener) [static] :32
Property__Subscription* Property__Subscription::New1(::g::Fuse::Reactive::Property* prop, ::g::Uno::UX::PropertyObject* obj, ::g::Uno::UX::PropertyAccessor* accessor, uObject* listener)
{
    Property__Subscription* obj1 = (Property__Subscription*)uNew(Property__Subscription_typeof());
    obj1->ctor_(prop, obj, accessor, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Let.uno
// ----------------------------------------------------------------------------------------

// private sealed class LetObservable.Subscription :209
// {
static void LetObservable__Subscription_build(uType* type)
{
    ::STRINGS[135] = uString::Const("Unsupported");
    ::STRINGS[93] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Bindings\\1.8.1\\Let.uno");
    ::STRINGS[136] = uString::Const("ClearExclusive");
    ::STRINGS[137] = uString::Const("ReplaceAllExclusive");
    type->SetInterfaces(
        ::g::Fuse::Reactive::ISubscription_typeof(), offsetof(LetObservable__Subscription_type, interface0),
        ::g::Uno::IDisposable_typeof(), offsetof(LetObservable__Subscription_type, interface1));
    type->SetFields(0,
        ::g::Fuse::Reactive::LetObservable_typeof(), offsetof(LetObservable__Subscription, Source), 0,
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(LetObservable__Subscription, Observer), 0);
}

LetObservable__Subscription_type* LetObservable__Subscription_typeof()
{
    static uSStrong<LetObservable__Subscription_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 2;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(LetObservable__Subscription);
    options.TypeSize = sizeof(LetObservable__Subscription_type);
    type = (LetObservable__Subscription_type*)uClassType::New("Fuse.Reactive.LetObservable.Subscription", options);
    type->fp_build_ = LetObservable__Subscription_build;
    type->fp_ctor_ = (void*)LetObservable__Subscription__New1_fn;
    type->interface0.fp_ClearExclusive = (void(*)(uObject*))LetObservable__Subscription__ClearExclusive_fn;
    type->interface0.fp_SetExclusive = (void(*)(uObject*, uObject*))LetObservable__Subscription__SetExclusive1_fn;
    type->interface0.fp_ReplaceAllExclusive = (void(*)(uObject*, uObject*))LetObservable__Subscription__ReplaceAllExclusive_fn;
    type->interface1.fp_Dispose = (void(*)(uObject*))LetObservable__Subscription__Dispose_fn;
    return type;
}

// public generated Subscription() :209
void LetObservable__Subscription__ctor__fn(LetObservable__Subscription* __this)
{
    __this->ctor_();
}

// public void ClearExclusive() :219
void LetObservable__Subscription__ClearExclusive_fn(LetObservable__Subscription* __this)
{
    __this->ClearExclusive();
}

// public void Dispose() :214
void LetObservable__Subscription__Dispose_fn(LetObservable__Subscription* __this)
{
    __this->Dispose();
}

// public generated Subscription New() :209
void LetObservable__Subscription__New1_fn(LetObservable__Subscription** __retval)
{
    *__retval = LetObservable__Subscription::New1();
}

// public void ReplaceAllExclusive(Fuse.IArray values) :224
void LetObservable__Subscription__ReplaceAllExclusive_fn(LetObservable__Subscription* __this, uObject* values)
{
    __this->ReplaceAllExclusive(values);
}

// public void SetExclusive(object newValue) :220
void LetObservable__Subscription__SetExclusive1_fn(LetObservable__Subscription* __this, uObject* newValue)
{
    __this->SetExclusive1(newValue);
}

// public generated Subscription() [instance] :209
void LetObservable__Subscription::ctor_()
{
}

// public void ClearExclusive() [instance] :219
void LetObservable__Subscription::ClearExclusive()
{
    ::g::Fuse::Diagnostics::InternalError(::STRINGS[135/*"Unsupported"*/], this, ::STRINGS[93/*"C:\\Users\\...*/], 219, ::STRINGS[136/*"ClearExclus...*/]);
}

// public void Dispose() [instance] :214
void LetObservable__Subscription::Dispose()
{
    uStackFrame __("Fuse.Reactive.LetObservable.Subscription", "Dispose()");
    uPtr(Source)->Unsubscribe(Observer);
}

// public void ReplaceAllExclusive(Fuse.IArray values) [instance] :224
void LetObservable__Subscription::ReplaceAllExclusive(uObject* values)
{
    ::g::Fuse::Diagnostics::InternalError(::STRINGS[135/*"Unsupported"*/], this, ::STRINGS[93/*"C:\\Users\\...*/], 224, ::STRINGS[137/*"ReplaceAllE...*/]);
}

// public void SetExclusive(object newValue) [instance] :220
void LetObservable__Subscription::SetExclusive1(uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.LetObservable.Subscription", "SetExclusive(object)");
    uPtr(uPtr(Source)->_let)->SetObjectValue(newValue, (uObject*)uPtr(Source)->_let);
}

// public generated Subscription New() [static] :209
LetObservable__Subscription* LetObservable__Subscription::New1()
{
    LetObservable__Subscription* obj1 = (LetObservable__Subscription*)uNew(LetObservable__Subscription_typeof());
    obj1->ctor_();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Member.uno
// ----------------------------------------------------------------------------------------------

// private sealed class Member.Subscription :30
// {
static void Member__Subscription_build(uType* type)
{
    ::STRINGS[40] = uString::Const("'");
    ::STRINGS[138] = uString::Const("' does not contain property '");
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    ::TYPES[36] = ::g::Fuse::Reactive::IPropertySubscription_typeof();
    ::TYPES[50] = ::g::Fuse::IObject_typeof();
    ::TYPES[35] = ::g::Fuse::Reactive::IObservableObject_typeof();
    type->SetInterfaces(
        ::TYPES[3/*Uno.IDisposable*/], offsetof(Member__Subscription_type, interface0),
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(Member__Subscription_type, interface1),
        ::g::Fuse::Reactive::IPropertyObserver_typeof(), offsetof(Member__Subscription_type, interface2),
        ::g::Fuse::Reactive::IWriteable_typeof(), offsetof(Member__Subscription_type, interface3));
    type->SetFields(2,
        ::g::Fuse::Reactive::Member_typeof(), offsetof(Member__Subscription, _member), 0,
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(Member__Subscription, _listener), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(Member__Subscription, _objectSub), 0,
        ::TYPES[36/*Fuse.Reactive.IPropertySubscription*/], offsetof(Member__Subscription, _obsObjSub), 0);
}

Member__Subscription_type* Member__Subscription_typeof()
{
    static uSStrong<Member__Subscription_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InnerListener_typeof();
    options.FieldCount = 6;
    options.InterfaceCount = 4;
    options.ObjectSize = sizeof(Member__Subscription);
    options.TypeSize = sizeof(Member__Subscription_type);
    type = (Member__Subscription_type*)uClassType::New("Fuse.Reactive.Member.Subscription", options);
    type->fp_build_ = Member__Subscription_build;
    type->fp_Dispose = (void(*)(::g::Fuse::Reactive::InnerListener*))Member__Subscription__Dispose_fn;
    type->fp_OnLostData = (void(*)(::g::Fuse::Reactive::InnerListener*, uObject*))Member__Subscription__OnLostData_fn;
    type->fp_OnNewData = (void(*)(::g::Fuse::Reactive::InnerListener*, uObject*, uObject*))Member__Subscription__OnNewData_fn;
    type->interface2.fp_OnPropertyChanged = (void(*)(uObject*, uObject*, uString*, uObject*))Member__Subscription__FuseReactiveIPropertyObserverOnPropertyChanged_fn;
    type->interface3.fp_TrySetExclusive = (void(*)(uObject*, uObject*, bool*))Member__Subscription__FuseReactiveIWriteableTrySetExclusive_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))Member__Subscription__Dispose_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnLostData_fn;
    return type;
}

// public Subscription(Fuse.Reactive.Member member, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :36
void Member__Subscription__ctor_1_fn(Member__Subscription* __this, ::g::Fuse::Reactive::Member* member, uObject* context, uObject* listener)
{
    __this->ctor_1(member, context, listener);
}

// public override sealed void Dispose() :95
void Member__Subscription__Dispose_fn(Member__Subscription* __this)
{
    uStackFrame __("Fuse.Reactive.Member.Subscription", "Dispose()");

    if (__this->_objectSub != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(__this->_objectSub), ::TYPES[3/*Uno.IDisposable*/]));
        __this->_objectSub = NULL;
    }

    __this->DisposeObservableObjectSubscription();
    ::g::Fuse::Reactive::InnerListener__Dispose_fn(__this);
}

// private void DisposeObservableObjectSubscription() :45
void Member__Subscription__DisposeObservableObjectSubscription_fn(Member__Subscription* __this)
{
    __this->DisposeObservableObjectSubscription();
}

// private void Fuse.Reactive.IPropertyObserver.OnPropertyChanged(Uno.IDisposable sub, string propName, object newValue) :81
void Member__Subscription__FuseReactiveIPropertyObserverOnPropertyChanged_fn(Member__Subscription* __this, uObject* sub, uString* propName, uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.Member.Subscription", "Fuse.Reactive.IPropertyObserver.OnPropertyChanged(Uno.IDisposable,string,object)");

    if (__this->_obsObjSub != sub)
        return;

    if (::g::Uno::String::op_Inequality(propName, uPtr(__this->_member)->Name()))
        return;

    ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(__this->_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)__this->_member, newValue);
}

// private bool Fuse.Reactive.IWriteable.TrySetExclusive(object newObj) :88
void Member__Subscription__FuseReactiveIWriteableTrySetExclusive_fn(Member__Subscription* __this, uObject* newObj, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.Member.Subscription", "Fuse.Reactive.IWriteable.TrySetExclusive(object)");

    if (__this->_obsObjSub != NULL)
        return *__retval = ::g::Fuse::Reactive::IPropertySubscription::TrySetExclusive(uInterface(uPtr(__this->_obsObjSub), ::TYPES[36/*Fuse.Reactive.IPropertySubscription*/]), uPtr(__this->_member)->Name(), newObj), void();

    return *__retval = false, void();
}

// public Subscription New(Fuse.Reactive.Member member, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :36
void Member__Subscription__New1_fn(::g::Fuse::Reactive::Member* member, uObject* context, uObject* listener, Member__Subscription** __retval)
{
    *__retval = Member__Subscription::New1(member, context, listener);
}

// protected override sealed void OnLostData(Fuse.Reactive.IExpression source) :76
void Member__Subscription__OnLostData_fn(Member__Subscription* __this, uObject* source)
{
    uStackFrame __("Fuse.Reactive.Member.Subscription", "OnLostData(Fuse.Reactive.IExpression)");
    __this->DisposeObservableObjectSubscription();
}

// protected override sealed void OnNewData(Fuse.Reactive.IExpression source, object obj) :54
void Member__Subscription__OnNewData_fn(Member__Subscription* __this, uObject* source, uObject* obj)
{
    uStackFrame __("Fuse.Reactive.Member.Subscription", "OnNewData(Fuse.Reactive.IExpression,object)");
    __this->DisposeObservableObjectSubscription();
    __this->ClearDiagnostic();
    uObject* io = uAs<uObject*>(obj, ::TYPES[50/*Fuse.IObject*/]);

    if ((io != NULL) && ::g::Fuse::IObject::ContainsKey(uInterface(uPtr(io), ::TYPES[50/*Fuse.IObject*/]), uPtr(__this->_member)->Name()))
    {
        uObject* obsObj = uAs<uObject*>(io, ::TYPES[35/*Fuse.Reactive.IObservableObject*/]);

        if (obsObj != NULL)
            __this->_obsObjSub = ::g::Fuse::Reactive::IObservableObject::Subscribe(uInterface(uPtr(obsObj), ::TYPES[35/*Fuse.Reactive.IObservableObject*/]), (uObject*)__this);

        ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(__this->_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)__this->_member, ::g::Fuse::IObject::Item(uInterface(uPtr(io), ::TYPES[50/*Fuse.IObject*/]), uPtr(__this->_member)->Name()));
    }
    else
    {
        __this->SetDiagnostic(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::g::Uno::String::op_Addition2(::STRINGS[40/*"'"*/], ::g::Uno::Object::ToString(uPtr(uPtr(__this->_member)->BaseObject()))), ::STRINGS[138/*"' does not ...*/]), uPtr(__this->_member)->Name()), ::STRINGS[40/*"'"*/]), __this->_member);
        ::g::Fuse::Reactive::IListener::OnLostData(uInterface(uPtr(__this->_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)__this->_member);
    }
}

// public Subscription(Fuse.Reactive.Member member, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) [instance] :36
void Member__Subscription::ctor_1(::g::Fuse::Reactive::Member* member, uObject* context, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.Member.Subscription", ".ctor(Fuse.Reactive.Member,Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    ctor_();
    _listener = listener;
    _member = member;
    _objectSub = uPtr(uPtr(_member)->BaseObject())->Subscribe(context, (uObject*)this);
}

// private void DisposeObservableObjectSubscription() [instance] :45
void Member__Subscription::DisposeObservableObjectSubscription()
{
    uStackFrame __("Fuse.Reactive.Member.Subscription", "DisposeObservableObjectSubscription()");

    if (_obsObjSub != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_obsObjSub), ::TYPES[3/*Uno.IDisposable*/]));
        _obsObjSub = NULL;
    }
}

// public Subscription New(Fuse.Reactive.Member member, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) [static] :36
Member__Subscription* Member__Subscription::New1(::g::Fuse::Reactive::Member* member, uObject* context, uObject* listener)
{
    Member__Subscription* obj1 = (Member__Subscription*)uNew(Member__Subscription_typeof());
    obj1->ctor_1(member, context, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Snapshot.uno
// ------------------------------------------------------------------------------------------------

// private sealed class Snapshot.Subscription :23
// {
static void Snapshot__Subscription_build(uType* type)
{
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    type->SetInterfaces(
        ::TYPES[3/*Uno.IDisposable*/], offsetof(Snapshot__Subscription_type, interface0),
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(Snapshot__Subscription_type, interface1));
    type->SetFields(0,
        ::g::Fuse::Reactive::Snapshot_typeof(), offsetof(Snapshot__Subscription, _snap), 0,
        ::TYPES[26/*Fuse.Reactive.IListener*/], offsetof(Snapshot__Subscription, _listener), 0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(Snapshot__Subscription, _sub), 0);
}

Snapshot__Subscription_type* Snapshot__Subscription_typeof()
{
    static uSStrong<Snapshot__Subscription_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 3;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(Snapshot__Subscription);
    options.TypeSize = sizeof(Snapshot__Subscription_type);
    type = (Snapshot__Subscription_type*)uClassType::New("Fuse.Reactive.Snapshot.Subscription", options);
    type->fp_build_ = Snapshot__Subscription_build;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))Snapshot__Subscription__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))Snapshot__Subscription__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))Snapshot__Subscription__Dispose_fn;
    return type;
}

// public Subscription(Fuse.Reactive.Snapshot snap, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :29
void Snapshot__Subscription__ctor__fn(Snapshot__Subscription* __this, ::g::Fuse::Reactive::Snapshot* snap, uObject* context, uObject* listener)
{
    __this->ctor_(snap, context, listener);
}

// public void Dispose() :36
void Snapshot__Subscription__Dispose_fn(Snapshot__Subscription* __this)
{
    __this->Dispose();
}

// private void Fuse.Reactive.IListener.OnLostData(Fuse.Reactive.IExpression source) :54
void Snapshot__Subscription__FuseReactiveIListenerOnLostData_fn(Snapshot__Subscription* __this, uObject* source)
{
}

// private void Fuse.Reactive.IListener.OnNewData(Fuse.Reactive.IExpression source, object value) :46
void Snapshot__Subscription__FuseReactiveIListenerOnNewData_fn(Snapshot__Subscription* __this, uObject* source, uObject* value)
{
    uStackFrame __("Fuse.Reactive.Snapshot.Subscription", "Fuse.Reactive.IListener.OnNewData(Fuse.Reactive.IExpression,object)");

    if (__this->_listener != NULL)
        ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(__this->_listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)__this->_snap, value);

    __this->Dispose();
}

// public Subscription New(Fuse.Reactive.Snapshot snap, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :29
void Snapshot__Subscription__New1_fn(::g::Fuse::Reactive::Snapshot* snap, uObject* context, uObject* listener, Snapshot__Subscription** __retval)
{
    *__retval = Snapshot__Subscription::New1(snap, context, listener);
}

// public Subscription(Fuse.Reactive.Snapshot snap, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) [instance] :29
void Snapshot__Subscription::ctor_(::g::Fuse::Reactive::Snapshot* snap, uObject* context, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.Snapshot.Subscription", ".ctor(Fuse.Reactive.Snapshot,Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    _snap = snap;
    _listener = listener;
    _sub = uPtr(uPtr(_snap)->Source())->Subscribe(context, (uObject*)this);
}

// public void Dispose() [instance] :36
void Snapshot__Subscription::Dispose()
{
    uStackFrame __("Fuse.Reactive.Snapshot.Subscription", "Dispose()");
    _listener = NULL;

    if (_sub != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_sub), ::TYPES[3/*Uno.IDisposable*/]));
        _sub = NULL;
    }
}

// public Subscription New(Fuse.Reactive.Snapshot snap, Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) [static] :29
Snapshot__Subscription* Snapshot__Subscription::New1(::g::Fuse::Reactive::Snapshot* snap, uObject* context, uObject* listener)
{
    Snapshot__Subscription* obj1 = (Snapshot__Subscription*)uNew(Snapshot__Subscription_typeof());
    obj1->ctor_(snap, context, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\ExpressionListener.uno
// ----------------------------------------------------------------------------------------------------------

// private sealed class ComputeExpression.Subscription :329
// {
static void ComputeExpression__Subscription_build(uType* type)
{
    ::STRINGS[139] = uString::Const("Failed to compute value for (");
    ::STRINGS[17] = uString::Const(",");
    ::STRINGS[140] = uString::Const("undefined");
    ::STRINGS[141] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Expressions\\1.8.1\\ExpressionListener.uno");
    ::STRINGS[142] = uString::Const("OnArguments");
    ::TYPES[67] = ::g::Fuse::Reactive::UnaryOperator_typeof();
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(::g::Fuse::Reactive::ExpressionListener_type, interface0),
        ::g::Fuse::Reactive::IListener_typeof(), offsetof(::g::Fuse::Reactive::ExpressionListener_type, interface1));
    type->SetFields(9,
        ::g::Fuse::Reactive::ComputeExpression_typeof(), offsetof(ComputeExpression__Subscription, _expr), 0);
}

::g::Fuse::Reactive::ExpressionListener_type* ComputeExpression__Subscription_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::ExpressionListener_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ExpressionListener_typeof();
    options.FieldCount = 10;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(ComputeExpression__Subscription);
    options.TypeSize = sizeof(::g::Fuse::Reactive::ExpressionListener_type);
    type = (::g::Fuse::Reactive::ExpressionListener_type*)uClassType::New("Fuse.Reactive.ComputeExpression.Subscription", options);
    type->fp_build_ = ComputeExpression__Subscription_build;
    type->fp_OnArguments = (void(*)(::g::Fuse::Reactive::ExpressionSubscriber*, uArray*))ComputeExpression__Subscription__OnArguments_fn;
    type->fp_OnClearData = (void(*)(::g::Fuse::Reactive::ExpressionSubscriber*))ComputeExpression__Subscription__OnClearData_fn;
    type->interface1.fp_OnNewData = (void(*)(uObject*, uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnNewData_fn;
    type->interface1.fp_OnLostData = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::InnerListener__FuseReactiveIListenerOnLostData_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))::g::Fuse::Reactive::ExpressionListener__Dispose_fn;
    return type;
}

// public Subscription(Fuse.Reactive.ComputeExpression expr, Fuse.Reactive.IListener listener) :333
void ComputeExpression__Subscription__ctor_3_fn(ComputeExpression__Subscription* __this, ::g::Fuse::Reactive::ComputeExpression* expr, uObject* listener)
{
    __this->ctor_3(expr, listener);
}

// public Subscription New(Fuse.Reactive.ComputeExpression expr, Fuse.Reactive.IListener listener) :333
void ComputeExpression__Subscription__New1_fn(::g::Fuse::Reactive::ComputeExpression* expr, uObject* listener, ComputeExpression__Subscription** __retval)
{
    *__retval = ComputeExpression__Subscription::New1(expr, listener);
}

// protected override sealed void OnArguments(Fuse.Reactive.Expression.Argument[] args) :339
void ComputeExpression__Subscription__OnArguments_fn(ComputeExpression__Subscription* __this, uArray* args)
{
    uStackFrame __("Fuse.Reactive.ComputeExpression.Subscription", "OnArguments(Fuse.Reactive.Expression.Argument[])");

    if ((uPtr(__this->_expr)->_flags & 2048) == 2048)
    {
        uPtr(uCast< ::g::Fuse::Reactive::UnaryOperator*>(__this->_expr, ::TYPES[67/*Fuse.Reactive.UnaryOperator*/]))->InternalOnNewOperand(__this->Listener(), uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(0))->Value());
        return;
    }

    uObject* result;

    if (uPtr(__this->_expr)->TryCompute(args, &result))
        __this->SetData(result);
    else
    {
        if (!((uPtr(__this->_expr)->_flags & 32) == 32))
        {
            uString* msg = ::STRINGS[139/*"Failed to c...*/];

            for (int32_t i = 0; i < uPtr(args)->Length(); ++i)
            {
                if (i > 0)
                    msg = ::g::Uno::String::op_Addition2(msg, ::STRINGS[17/*","*/]);

                if (uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->HasValue())
                    msg = ::g::Uno::String::op_Addition1(msg, uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(i))->Value());
                else
                    msg = ::g::Uno::String::op_Addition2(msg, ::STRINGS[140/*"undefined"*/]);
            }

            ::g::Fuse::Diagnostics::UserWarning(msg, __this->_expr, ::STRINGS[141/*"C:\\Users\\...*/], 366, ::STRINGS[142/*"OnArguments"*/]);
        }

        __this->OnClearData();
    }
}

// internal override sealed void OnClearData() :372
void ComputeExpression__Subscription__OnClearData_fn(ComputeExpression__Subscription* __this)
{
    uStackFrame __("Fuse.Reactive.ComputeExpression.Subscription", "OnClearData()");

    if ((uPtr(__this->_expr)->_flags & 2048) == 2048)
        uPtr(uCast< ::g::Fuse::Reactive::UnaryOperator*>(__this->_expr, ::TYPES[67/*Fuse.Reactive.UnaryOperator*/]))->InternalOnLostOperand(__this->Listener());
    else
        ::g::Fuse::Reactive::ExpressionListener__OnClearData_fn(__this);
}

// public Subscription(Fuse.Reactive.ComputeExpression expr, Fuse.Reactive.IListener listener) [instance] :333
void ComputeExpression__Subscription::ctor_3(::g::Fuse::Reactive::ComputeExpression* expr, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.ComputeExpression.Subscription", ".ctor(Fuse.Reactive.ComputeExpression,Fuse.Reactive.IListener)");
    ctor_2(expr, listener, uPtr(expr)->_args, uPtr(expr)->EffectiveFlags());
    _expr = expr;
}

// public Subscription New(Fuse.Reactive.ComputeExpression expr, Fuse.Reactive.IListener listener) [static] :333
ComputeExpression__Subscription* ComputeExpression__Subscription::New1(::g::Fuse::Reactive::ComputeExpression* expr, uObject* listener)
{
    ComputeExpression__Subscription* obj1 = (ComputeExpression__Subscription*)uNew(ComputeExpression__Subscription_typeof());
    obj1->ctor_3(expr, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\Operators.uno
// -------------------------------------------------------------------------------------------------

// public sealed class Subtract :65
// {
static void Subtract_build(uType* type)
{
    ::STRINGS[143] = uString::Const("-");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::BinaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Subtract__New1_fn, 0, true, type, 2, ::g::Fuse::Reactive::Expression_typeof(), ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::BinaryOperator_type* Subtract_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::BinaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::InfixOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(Subtract);
    options.TypeSize = sizeof(::g::Fuse::Reactive::BinaryOperator_type);
    type = (::g::Fuse::Reactive::BinaryOperator_type*)uClassType::New("Fuse.Reactive.Subtract", options);
    type->fp_build_ = Subtract_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::BinaryOperator*, uObject*, uObject*, uObject**, bool*))Subtract__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Subtract(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :68
void Subtract__ctor_6_fn(Subtract* __this, ::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    __this->ctor_6(left, right);
}

// public Subtract New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) :68
void Subtract__New1_fn(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right, Subtract** __retval)
{
    *__retval = Subtract::New1(left, right);
}

// protected override sealed bool TryCompute(object left, object right, object& result) :70
void Subtract__TryCompute1_fn(Subtract* __this, uObject* left, uObject* right, uObject** result, bool* __retval)
{
    return *__retval = ::g::Fuse::Marshal::TrySubtract(left, right, result), void();
}

// public Subtract(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [instance] :68
void Subtract::ctor_6(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    uStackFrame __("Fuse.Reactive.Subtract", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression)");
    ctor_5(left, right, ::STRINGS[143/*"-"*/], 0);
}

// public Subtract New(Fuse.Reactive.Expression left, Fuse.Reactive.Expression right) [static] :68
Subtract* Subtract::New1(::g::Fuse::Reactive::Expression* left, ::g::Fuse::Reactive::Expression* right)
{
    Subtract* obj1 = (Subtract*)uNew(Subtract_typeof());
    obj1->ctor_6(left, right);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Tan :213
// {
static void Tan_build(uType* type)
{
    ::STRINGS[144] = uString::Const("tan");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Tan__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Tan_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Tan);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Tan", options);
    type->fp_build_ = Tan_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Tan(Fuse.Reactive.Expression operand) :216
void Tan__ctor_5_fn(Tan* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Tan New(Fuse.Reactive.Expression operand) :216
void Tan__New1_fn(::g::Fuse::Reactive::Expression* operand, Tan** __retval)
{
    *__retval = Tan::New1(operand);
}

// public Tan(Fuse.Reactive.Expression operand) [instance] :216
void Tan::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[144/*"tan"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)::g::Uno::Math__Tan_fn));
}

// public Tan New(Fuse.Reactive.Expression operand) [static] :216
Tan* Tan::New1(::g::Fuse::Reactive::Expression* operand)
{
    Tan* obj1 = (Tan*)uNew(Tan_typeof());
    obj1->ctor_5(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Instantiator.uno
// -------------------------------------------------------------------------------------------------

// internal struct TemplateMatch :82
// {
static void TemplateMatch_build(uType* type)
{
    type->SetFields(0,
        ::g::Uno::Bool_typeof(), offsetof(TemplateMatch, All), 0,
        ::g::Uno::UX::Template_typeof(), offsetof(TemplateMatch, Template), 0);
}

uStructType* TemplateMatch_typeof()
{
    static uSStrong<uStructType*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 2;
    options.Alignment = alignof(TemplateMatch);
    options.ValueSize = sizeof(TemplateMatch);
    options.TypeSize = sizeof(uStructType);
    type = uStructType::New("Fuse.Reactive.TemplateMatch", options);
    type->fp_build_ = TemplateMatch_build;
    return type;
}

// public bool Matches(Fuse.Reactive.TemplateMatch b) :89
void TemplateMatch__Matches_fn(TemplateMatch* __this, TemplateMatch* b, bool* __retval)
{
    *__retval = __this->Matches(*b);
}

// public bool Matches(Fuse.Reactive.TemplateMatch b) [instance] :89
bool TemplateMatch::Matches(TemplateMatch b)
{
    if (All != b.All)
        return false;

    return Template == b.Template;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\TernaryOperator.uno
// -------------------------------------------------------------------------------------------------------

// public abstract class TernaryOperator :8
// {
static void TernaryOperator_build(uType* type)
{
    ::STRINGS[11] = uString::Const(" No `TryCompute`, or a deprecated form, overriden. Migrate your code to override the one with `bool` return. ");
    ::STRINGS[145] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Expressions\\1.8.1\\TernaryOperator.uno");
    ::STRINGS[13] = uString::Const("TryCompute");
    ::TYPES[10] = ::g::Fuse::Reactive::Expression_typeof()->Array();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(TernaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(3,
        new uFunction("get_First", NULL, (void*)TernaryOperator__get_First_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0),
        new uFunction("get_Second", NULL, (void*)TernaryOperator__get_Second_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0),
        new uFunction("get_Third", NULL, (void*)TernaryOperator__get_Third_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0));
}

TernaryOperator_type* TernaryOperator_typeof()
{
    static uSStrong<TernaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ComputeExpression_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(TernaryOperator);
    options.TypeSize = sizeof(TernaryOperator_type);
    type = (TernaryOperator_type*)uClassType::New("Fuse.Reactive.TernaryOperator", options);
    type->fp_build_ = TernaryOperator_build;
    type->fp_GetFlags = (void(*)(::g::Fuse::Reactive::ComputeExpression*, int32_t*))TernaryOperator__GetFlags_fn;
    type->fp_TryCompute = (void(*)(::g::Fuse::Reactive::ComputeExpression*, uArray*, uObject**, bool*))TernaryOperator__TryCompute_fn;
    type->fp_TryCompute1 = TernaryOperator__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// protected TernaryOperator(Fuse.Reactive.Expression first, Fuse.Reactive.Expression second, Fuse.Reactive.Expression third, [Fuse.Reactive.ComputeExpression.Flags flags]) :14
void TernaryOperator__ctor_2_fn(TernaryOperator* __this, ::g::Fuse::Reactive::Expression* first, ::g::Fuse::Reactive::Expression* second, ::g::Fuse::Reactive::Expression* third, int32_t* flags)
{
    __this->ctor_2(first, second, third, *flags);
}

// protected object Compute(object first, object second, object third) :42
void TernaryOperator__Compute_fn(TernaryOperator* __this, uObject* first, uObject* second, uObject* third, uObject** __retval)
{
    *__retval = __this->Compute(first, second, third);
}

// public Fuse.Reactive.Expression get_First() :10
void TernaryOperator__get_First_fn(TernaryOperator* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->First();
}

// internal override sealed Fuse.Reactive.ComputeExpression.Flags GetFlags() :20
void TernaryOperator__GetFlags_fn(TernaryOperator* __this, int32_t* __retval)
{
    return *__retval = ((0 | (__this->IsFirstOptional() ? 1 : 0)) | (__this->IsSecondOptional() ? 2 : 0)) | (__this->IsThirdOptional() ? 4 : 0), void();
}

// protected bool get_IsFirstOptional() :30
void TernaryOperator__get_IsFirstOptional_fn(TernaryOperator* __this, bool* __retval)
{
    *__retval = __this->IsFirstOptional();
}

// protected bool get_IsSecondOptional() :31
void TernaryOperator__get_IsSecondOptional_fn(TernaryOperator* __this, bool* __retval)
{
    *__retval = __this->IsSecondOptional();
}

// protected bool get_IsThirdOptional() :32
void TernaryOperator__get_IsThirdOptional_fn(TernaryOperator* __this, bool* __retval)
{
    *__retval = __this->IsThirdOptional();
}

// public Fuse.Reactive.Expression get_Second() :11
void TernaryOperator__get_Second_fn(TernaryOperator* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->Second();
}

// public Fuse.Reactive.Expression get_Third() :12
void TernaryOperator__get_Third_fn(TernaryOperator* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->Third();
}

// protected override sealed bool TryCompute(Fuse.Reactive.Expression.Argument[] args, object& result) :44
void TernaryOperator__TryCompute_fn(TernaryOperator* __this, uArray* args, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.TernaryOperator", "TryCompute(Fuse.Reactive.Expression.Argument[],object&)");
    return *__retval = __this->TryCompute1(uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(0))->Value(), uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(1))->Value(), uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(2))->Value(), result), void();
}

// protected virtual bool TryCompute(object first, object second, object third, object& result) :34
void TernaryOperator__TryCompute1_fn(TernaryOperator* __this, uObject* first, uObject* second, uObject* third, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.TernaryOperator", "TryCompute(object,object,object,object&)");
    ::g::Fuse::Diagnostics::Deprecated(::STRINGS[11/*" No `TryCom...*/], __this, ::STRINGS[145/*"C:\\Users\\...*/], 36, ::STRINGS[13/*"TryCompute"*/]);
    *result = __this->Compute(first, second, third);
    return *__retval = true, void();
}

// protected TernaryOperator(Fuse.Reactive.Expression first, Fuse.Reactive.Expression second, Fuse.Reactive.Expression third, [Fuse.Reactive.ComputeExpression.Flags flags]) [instance] :14
void TernaryOperator::ctor_2(::g::Fuse::Reactive::Expression* first, ::g::Fuse::Reactive::Expression* second, ::g::Fuse::Reactive::Expression* third, int32_t flags)
{
    uStackFrame __("Fuse.Reactive.TernaryOperator", ".ctor(Fuse.Reactive.Expression,Fuse.Reactive.Expression,Fuse.Reactive.Expression,[Fuse.Reactive.ComputeExpression.Flags])");
    ctor_1(uArray::Init< ::g::Fuse::Reactive::Expression*>(::TYPES[10/*Fuse.Reactive.Expression[]*/], 3, first, second, third), flags, NULL);
}

// protected object Compute(object first, object second, object third) [instance] :42
uObject* TernaryOperator::Compute(uObject* first, uObject* second, uObject* third)
{
    return NULL;
}

// public Fuse.Reactive.Expression get_First() [instance] :10
::g::Fuse::Reactive::Expression* TernaryOperator::First()
{
    uStackFrame __("Fuse.Reactive.TernaryOperator", "get_First()");
    return GetArgument(0);
}

// protected bool get_IsFirstOptional() [instance] :30
bool TernaryOperator::IsFirstOptional()
{
    return false;
}

// protected bool get_IsSecondOptional() [instance] :31
bool TernaryOperator::IsSecondOptional()
{
    return false;
}

// protected bool get_IsThirdOptional() [instance] :32
bool TernaryOperator::IsThirdOptional()
{
    return false;
}

// public Fuse.Reactive.Expression get_Second() [instance] :11
::g::Fuse::Reactive::Expression* TernaryOperator::Second()
{
    uStackFrame __("Fuse.Reactive.TernaryOperator", "get_Second()");
    return GetArgument(1);
}

// public Fuse.Reactive.Expression get_Third() [instance] :12
::g::Fuse::Reactive::Expression* TernaryOperator::Third()
{
    uStackFrame __("Fuse.Reactive.TernaryOperator", "get_Third()");
    return GetArgument(2);
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\ConversionFunctions.uno
// -----------------------------------------------------------------------------------------------------------

// public sealed class ToFloat :8
// {
static void ToFloat_build(uType* type)
{
    ::STRINGS[146] = uString::Const("float");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)ToFloat__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* ToFloat_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(ToFloat);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.ToFloat", options);
    type->fp_build_ = ToFloat_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public ToFloat(Fuse.Reactive.Expression operand) :11
void ToFloat__ctor_5_fn(ToFloat* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public ToFloat New(Fuse.Reactive.Expression operand) :11
void ToFloat__New1_fn(::g::Fuse::Reactive::Expression* operand, ToFloat** __retval)
{
    *__retval = ToFloat::New1(operand);
}

// internal static double Op(double v) :14
void ToFloat__Op_fn(double* v, double* __retval)
{
    *__retval = ToFloat::Op(*v);
}

// public ToFloat(Fuse.Reactive.Expression operand) [instance] :11
void ToFloat::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[146/*"float"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)ToFloat__Op_fn));
}

// public ToFloat New(Fuse.Reactive.Expression operand) [static] :11
ToFloat* ToFloat::New1(::g::Fuse::Reactive::Expression* operand)
{
    ToFloat* obj1 = (ToFloat*)uNew(ToFloat_typeof());
    obj1->ctor_5(operand);
    return obj1;
}

// internal static double Op(double v) [static] :14
double ToFloat::Op(double v)
{
    return v;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\StringFunctions.uno
// -------------------------------------------------------------------------------------------------------

// public sealed class ToLower :21
// {
static void ToLower_build(uType* type)
{
    ::STRINGS[147] = uString::Const("toLower");
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)ToLower__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* ToLower_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(ToLower);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.ToLower", options);
    type->fp_build_ = ToLower_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::UnaryOperator*, uObject*, uObject**, bool*))ToLower__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public ToLower(Fuse.Reactive.Expression value) :24
void ToLower__ctor_4_fn(ToLower* __this, ::g::Fuse::Reactive::Expression* value)
{
    __this->ctor_4(value);
}

// public ToLower New(Fuse.Reactive.Expression value) :24
void ToLower__New1_fn(::g::Fuse::Reactive::Expression* value, ToLower** __retval)
{
    *__retval = ToLower::New1(value);
}

// protected override sealed bool TryCompute(object s, object& result) :25
void ToLower__TryCompute1_fn(ToLower* __this, uObject* s, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.ToLower", "TryCompute(object,object&)");
    *result = NULL;

    if (s == NULL)
        return *__retval = false, void();

    *result = ::g::Uno::String::ToLower(uPtr(::g::Uno::Object::ToString(uPtr(s))));
    return *__retval = true, void();
}

// public ToLower(Fuse.Reactive.Expression value) [instance] :24
void ToLower::ctor_4(::g::Fuse::Reactive::Expression* value)
{
    ctor_3(value, ::STRINGS[147/*"toLower"*/], 0);
}

// public ToLower New(Fuse.Reactive.Expression value) [static] :24
ToLower* ToLower::New1(::g::Fuse::Reactive::Expression* value)
{
    ToLower* obj1 = (ToLower*)uNew(ToLower_typeof());
    obj1->ctor_4(value);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\ConversionFunctions.uno
// -----------------------------------------------------------------------------------------------------------

// public sealed class ToSize :51
// {
static void ToSize_build(uType* type)
{
    ::STRINGS[148] = uString::Const("size");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)ToSize__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* ToSize_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(ToSize);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.ToSize", options);
    type->fp_build_ = ToSize_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::UnaryOperator*, uObject*, uObject**, bool*))ToSize__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public ToSize(Fuse.Reactive.Expression operand) :54
void ToSize__ctor_4_fn(ToSize* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_4(operand);
}

// public ToSize New(Fuse.Reactive.Expression operand) :54
void ToSize__New1_fn(::g::Fuse::Reactive::Expression* operand, ToSize** __retval)
{
    *__retval = ToSize::New1(operand);
}

// protected override sealed bool TryCompute(object operand, object& result) :57
void ToSize__TryCompute1_fn(ToSize* __this, uObject* operand, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.ToSize", "TryCompute(object,object&)");
    *result = NULL;

    if (operand == NULL)
        return *__retval = false, void();

    ::g::Uno::UX::Size2 r;
    int32_t rc;

    if (!::g::Fuse::Marshal::TryToSize21(operand, &r, &rc))
        return *__retval = false, void();

    if (rc == 1)
        *result = uBox(::g::Uno::UX::Size_typeof(), r.X);
    else
        *result = uBox(::g::Uno::UX::Size2_typeof(), r);

    return *__retval = true, void();
}

// public ToSize(Fuse.Reactive.Expression operand) [instance] :54
void ToSize::ctor_4(::g::Fuse::Reactive::Expression* operand)
{
    ctor_3(operand, ::STRINGS[148/*"size"*/], 0);
}

// public ToSize New(Fuse.Reactive.Expression operand) [static] :54
ToSize* ToSize::New1(::g::Fuse::Reactive::Expression* operand)
{
    ToSize* obj1 = (ToSize*)uNew(ToSize_typeof());
    obj1->ctor_4(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\ConversionFunctions.uno
// -----------------------------------------------------------------------------------------------------------

// public sealed class ToString :22
// {
static void ToString_build(uType* type)
{
    ::STRINGS[52] = uString::Const("string");
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)ToString__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* ToString_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(ToString);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.ToString", options);
    type->fp_build_ = ToString_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::UnaryOperator*, uObject*, uObject**, bool*))ToString__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public ToString(Fuse.Reactive.Expression operand) :25
void ToString__ctor_4_fn(ToString* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_4(operand);
}

// public ToString New(Fuse.Reactive.Expression operand) :25
void ToString__New1_fn(::g::Fuse::Reactive::Expression* operand, ToString** __retval)
{
    *__retval = ToString::New1(operand);
}

// protected override sealed bool TryCompute(object operand, object& result) :28
void ToString__TryCompute1_fn(ToString* __this, uObject* operand, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.ToString", "TryCompute(object,object&)");
    *result = NULL;

    if (operand == NULL)
        return *__retval = false, void();

    *result = ::g::Uno::Object::ToString(uPtr(operand));
    return *__retval = true, void();
}

// public ToString(Fuse.Reactive.Expression operand) [instance] :25
void ToString::ctor_4(::g::Fuse::Reactive::Expression* operand)
{
    ctor_3(operand, ::STRINGS[52/*"string"*/], 0);
}

// public ToString New(Fuse.Reactive.Expression operand) [static] :25
ToString* ToString::New1(::g::Fuse::Reactive::Expression* operand)
{
    ToString* obj1 = (ToString*)uNew(ToString_typeof());
    obj1->ctor_4(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\StringFunctions.uno
// -------------------------------------------------------------------------------------------------------

// public sealed class ToUpper :6
// {
static void ToUpper_build(uType* type)
{
    ::STRINGS[149] = uString::Const("toUpper");
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)ToUpper__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* ToUpper_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(ToUpper);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.ToUpper", options);
    type->fp_build_ = ToUpper_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::UnaryOperator*, uObject*, uObject**, bool*))ToUpper__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public ToUpper(Fuse.Reactive.Expression value) :9
void ToUpper__ctor_4_fn(ToUpper* __this, ::g::Fuse::Reactive::Expression* value)
{
    __this->ctor_4(value);
}

// public ToUpper New(Fuse.Reactive.Expression value) :9
void ToUpper__New1_fn(::g::Fuse::Reactive::Expression* value, ToUpper** __retval)
{
    *__retval = ToUpper::New1(value);
}

// protected override sealed bool TryCompute(object s, object& result) :10
void ToUpper__TryCompute1_fn(ToUpper* __this, uObject* s, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.ToUpper", "TryCompute(object,object&)");
    *result = NULL;

    if (s == NULL)
        return *__retval = false, void();

    *result = ::g::Uno::String::ToUpper(uPtr(::g::Uno::Object::ToString(uPtr(s))));
    return *__retval = true, void();
}

// public ToUpper(Fuse.Reactive.Expression value) [instance] :9
void ToUpper::ctor_4(::g::Fuse::Reactive::Expression* value)
{
    ctor_3(value, ::STRINGS[149/*"toUpper"*/], 0);
}

// public ToUpper New(Fuse.Reactive.Expression value) [static] :9
ToUpper* ToUpper::New1(::g::Fuse::Reactive::Expression* value)
{
    ToUpper* obj1 = (ToUpper*)uNew(ToUpper_typeof());
    obj1->ctor_4(value);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public sealed class Trunc :400
// {
static void Trunc_build(uType* type)
{
    ::STRINGS[150] = uString::Const("trunc");
    ::TYPES[0] = ::g::Fuse::Reactive::UnaryFloatOperator__FloatOp_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(4);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Trunc__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* Trunc_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryFloatOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Trunc);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.Trunc", options);
    type->fp_build_ = Trunc_build;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public Trunc(Fuse.Reactive.Expression operand) :403
void Trunc__ctor_5_fn(Trunc* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_5(operand);
}

// public Trunc New(Fuse.Reactive.Expression operand) :403
void Trunc__New1_fn(::g::Fuse::Reactive::Expression* operand, Trunc** __retval)
{
    *__retval = Trunc::New1(operand);
}

// internal static double Op(double v) :406
void Trunc__Op_fn(double* v, double* __retval)
{
    *__retval = Trunc::Op(*v);
}

// public Trunc(Fuse.Reactive.Expression operand) [instance] :403
void Trunc::ctor_5(::g::Fuse::Reactive::Expression* operand)
{
    ctor_4(operand, ::STRINGS[150/*"trunc"*/], uDelegate::New(::TYPES[0/*Fuse.Reactive.UnaryFloatOperator.FloatOp*/], (void*)Trunc__Op_fn));
}

// public Trunc New(Fuse.Reactive.Expression operand) [static] :403
Trunc* Trunc::New1(::g::Fuse::Reactive::Expression* operand)
{
    Trunc* obj1 = (Trunc*)uNew(Trunc_typeof());
    obj1->ctor_5(operand);
    return obj1;
}

// internal static double Op(double v) [static] :406
double Trunc::Op(double v)
{
    return (v < 0.0) ? ::g::Uno::Math::Ceil(v) : ::g::Uno::Math::Floor(v);
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\MathFunctions.uno
// -----------------------------------------------------------------------------------------------------

// public abstract class UnaryFloatOperator :129
// {
static void UnaryFloatOperator_build(uType* type)
{
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(3,
        UnaryFloatOperator__FloatOp_typeof(), offsetof(UnaryFloatOperator, _op), 0);
}

::g::Fuse::Reactive::UnaryOperator_type* UnaryFloatOperator_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryOperator_typeof();
    options.FieldCount = 4;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(UnaryFloatOperator);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.UnaryFloatOperator", options);
    type->fp_build_ = UnaryFloatOperator_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::UnaryOperator*, uObject*, uObject**, bool*))UnaryFloatOperator__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// internal UnaryFloatOperator(Fuse.Reactive.Expression operand, string name, Fuse.Reactive.UnaryFloatOperator.FloatOp op) :133
void UnaryFloatOperator__ctor_4_fn(UnaryFloatOperator* __this, ::g::Fuse::Reactive::Expression* operand, uString* name, uDelegate* op)
{
    __this->ctor_4(operand, name, op);
}

// protected override sealed bool TryCompute(object operand, object& result) :138
void UnaryFloatOperator__TryCompute1_fn(UnaryFloatOperator* __this, uObject* operand, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.UnaryFloatOperator", "TryCompute(object,object&)");
    double ret1;
    double ret2;
    double ret3;
    double ret4;
    double ret5;
    double ret6;
    double ret7;
    double ret8;
    double ret9;
    double ret10;
    *result = NULL;
    ::g::Uno::Float4 v;
    int32_t size;

    if (::g::Fuse::Marshal::TryToZeroFloat4(operand, &v, &size))

        switch (size)
        {
            case 1:
            {
                *result = uBox(::TYPES[21/*float*/], (float)(uPtr(__this->_op)->Invoke(&ret1, 1, uCRef((double)v.Item(0))), ret1));
                return *__retval = true, void();
            }
            case 2:
            {
                *result = uBox(::g::Uno::Float2_typeof(), ::g::Uno::Float2__New2((float)(uPtr(__this->_op)->Invoke(&ret2, 1, uCRef((double)v.Item(0))), ret2), (float)(uPtr(__this->_op)->Invoke(&ret3, 1, uCRef((double)v.Item(1))), ret3)));
                return *__retval = true, void();
            }
            case 3:
            {
                *result = uBox(::g::Uno::Float3_typeof(), ::g::Uno::Float3__New2((float)(uPtr(__this->_op)->Invoke(&ret4, 1, uCRef((double)v.Item(0))), ret4), (float)(uPtr(__this->_op)->Invoke(&ret5, 1, uCRef((double)v.Item(1))), ret5), (float)(uPtr(__this->_op)->Invoke(&ret6, 1, uCRef((double)v.Item(2))), ret6)));
                return *__retval = true, void();
            }
            case 4:
            {
                *result = uBox(::g::Uno::Float4_typeof(), ::g::Uno::Float4__New2((float)(uPtr(__this->_op)->Invoke(&ret7, 1, uCRef((double)v.Item(0))), ret7), (float)(uPtr(__this->_op)->Invoke(&ret8, 1, uCRef((double)v.Item(1))), ret8), (float)(uPtr(__this->_op)->Invoke(&ret9, 1, uCRef((double)v.Item(2))), ret9), (float)(uPtr(__this->_op)->Invoke(&ret10, 1, uCRef((double)v.Item(3))), ret10)));
                return *__retval = true, void();
            }
        }

    return *__retval = false, void();
}

// internal UnaryFloatOperator(Fuse.Reactive.Expression operand, string name, Fuse.Reactive.UnaryFloatOperator.FloatOp op) [instance] :133
void UnaryFloatOperator::ctor_4(::g::Fuse::Reactive::Expression* operand, uString* name, uDelegate* op)
{
    ctor_3(operand, name, 0);
    _op = op;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\UnaryOperator.uno
// -----------------------------------------------------------------------------------------------------

// public abstract class UnaryOperator :8
// {
static void UnaryOperator_build(uType* type)
{
    ::STRINGS[151] = uString::Const("Failed to compute value: ");
    ::STRINGS[152] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Expressions\\1.8.1\\UnaryOperator.uno");
    ::STRINGS[153] = uString::Const("OnNewOperand");
    ::STRINGS[11] = uString::Const(" No `TryCompute`, or a deprecated form, overriden. Migrate your code to override the one with `bool` return. ");
    ::STRINGS[13] = uString::Const("TryCompute");
    ::TYPES[10] = ::g::Fuse::Reactive::Expression_typeof()->Array();
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(UnaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction("get_Operand", NULL, (void*)UnaryOperator__get_Operand_fn, 0, false, ::g::Fuse::Reactive::Expression_typeof(), 0));
}

UnaryOperator_type* UnaryOperator_typeof()
{
    static uSStrong<UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ComputeExpression_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(UnaryOperator);
    options.TypeSize = sizeof(UnaryOperator_type);
    type = (UnaryOperator_type*)uClassType::New("Fuse.Reactive.UnaryOperator", options);
    type->fp_build_ = UnaryOperator_build;
    type->fp_GetFlags = (void(*)(::g::Fuse::Reactive::ComputeExpression*, int32_t*))UnaryOperator__GetFlags_fn;
    type->fp_TryCompute = (void(*)(::g::Fuse::Reactive::ComputeExpression*, uArray*, uObject**, bool*))UnaryOperator__TryCompute_fn;
    type->fp_TryCompute1 = UnaryOperator__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// protected UnaryOperator(Fuse.Reactive.Expression operand, [Fuse.Reactive.ComputeExpression.Flags flags]) :11
void UnaryOperator__ctor_2_fn(UnaryOperator* __this, ::g::Fuse::Reactive::Expression* operand, int32_t* flags)
{
    __this->ctor_2(operand, *flags);
}

// protected UnaryOperator(Fuse.Reactive.Expression operand, string name, [Fuse.Reactive.ComputeExpression.Flags flags]) :15
void UnaryOperator__ctor_3_fn(UnaryOperator* __this, ::g::Fuse::Reactive::Expression* operand, uString* name, int32_t* flags)
{
    __this->ctor_3(operand, name, *flags);
}

// protected object Compute(object operand) :38
void UnaryOperator__Compute_fn(UnaryOperator* __this, uObject* operand, uObject** __retval)
{
    *__retval = __this->Compute(operand);
}

// internal override sealed Fuse.Reactive.ComputeExpression.Flags GetFlags() :19
void UnaryOperator__GetFlags_fn(UnaryOperator* __this, int32_t* __retval)
{
    return *__retval = __this->IsOperandOptional() ? 1 : 0, void();
}

// internal void InternalOnLostOperand(Fuse.Reactive.IListener listener) :67
void UnaryOperator__InternalOnLostOperand_fn(UnaryOperator* __this, uObject* listener)
{
    __this->InternalOnLostOperand(listener);
}

// internal void InternalOnNewOperand(Fuse.Reactive.IListener listener, object operand) :59
void UnaryOperator__InternalOnNewOperand_fn(UnaryOperator* __this, uObject* listener, uObject* operand)
{
    __this->InternalOnNewOperand(listener, operand);
}

// protected bool get_IsOperandOptional() :24
void UnaryOperator__get_IsOperandOptional_fn(UnaryOperator* __this, bool* __retval)
{
    *__retval = __this->IsOperandOptional();
}

// protected void OnLostOperand(Fuse.Reactive.IListener listener) :63
void UnaryOperator__OnLostOperand_fn(UnaryOperator* __this, uObject* listener)
{
    __this->OnLostOperand(listener);
}

// protected void OnNewOperand(Fuse.Reactive.IListener listener, object operand) :46
void UnaryOperator__OnNewOperand_fn(UnaryOperator* __this, uObject* listener, uObject* operand)
{
    __this->OnNewOperand(listener, operand);
}

// public Fuse.Reactive.Expression get_Operand() :10
void UnaryOperator__get_Operand_fn(UnaryOperator* __this, ::g::Fuse::Reactive::Expression** __retval)
{
    *__retval = __this->Operand();
}

// protected override sealed bool TryCompute(Fuse.Reactive.Expression.Argument[] args, object& result) :40
void UnaryOperator__TryCompute_fn(UnaryOperator* __this, uArray* args, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.UnaryOperator", "TryCompute(Fuse.Reactive.Expression.Argument[],object&)");
    return *__retval = __this->TryCompute1(uPtr(uPtr(args)->Strong< ::g::Fuse::Reactive::Expression__Argument*>(0))->Value(), result), void();
}

// protected virtual bool TryCompute(object operand, object& result) :30
void UnaryOperator__TryCompute1_fn(UnaryOperator* __this, uObject* operand, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.UnaryOperator", "TryCompute(object,object&)");
    ::g::Fuse::Diagnostics::Deprecated(::STRINGS[11/*" No `TryCom...*/], __this, ::STRINGS[152/*"C:\\Users\\...*/], 32, ::STRINGS[13/*"TryCompute"*/]);
    *result = __this->Compute(operand);
    return *__retval = true, void();
}

// protected UnaryOperator(Fuse.Reactive.Expression operand, [Fuse.Reactive.ComputeExpression.Flags flags]) [instance] :11
void UnaryOperator::ctor_2(::g::Fuse::Reactive::Expression* operand, int32_t flags)
{
    uStackFrame __("Fuse.Reactive.UnaryOperator", ".ctor(Fuse.Reactive.Expression,[Fuse.Reactive.ComputeExpression.Flags])");
    ctor_1(uArray::Init< ::g::Fuse::Reactive::Expression*>(::TYPES[10/*Fuse.Reactive.Expression[]*/], 1, operand), flags, NULL);
}

// protected UnaryOperator(Fuse.Reactive.Expression operand, string name, [Fuse.Reactive.ComputeExpression.Flags flags]) [instance] :15
void UnaryOperator::ctor_3(::g::Fuse::Reactive::Expression* operand, uString* name, int32_t flags)
{
    uStackFrame __("Fuse.Reactive.UnaryOperator", ".ctor(Fuse.Reactive.Expression,string,[Fuse.Reactive.ComputeExpression.Flags])");
    ctor_1(uArray::Init< ::g::Fuse::Reactive::Expression*>(::TYPES[10/*Fuse.Reactive.Expression[]*/], 1, operand), flags, name);
}

// protected object Compute(object operand) [instance] :38
uObject* UnaryOperator::Compute(uObject* operand)
{
    return NULL;
}

// internal void InternalOnLostOperand(Fuse.Reactive.IListener listener) [instance] :67
void UnaryOperator::InternalOnLostOperand(uObject* listener)
{
    uStackFrame __("Fuse.Reactive.UnaryOperator", "InternalOnLostOperand(Fuse.Reactive.IListener)");
    OnLostOperand(listener);
}

// internal void InternalOnNewOperand(Fuse.Reactive.IListener listener, object operand) [instance] :59
void UnaryOperator::InternalOnNewOperand(uObject* listener, uObject* operand)
{
    uStackFrame __("Fuse.Reactive.UnaryOperator", "InternalOnNewOperand(Fuse.Reactive.IListener,object)");
    OnNewOperand(listener, operand);
}

// protected bool get_IsOperandOptional() [instance] :24
bool UnaryOperator::IsOperandOptional()
{
    return false;
}

// protected void OnLostOperand(Fuse.Reactive.IListener listener) [instance] :63
void UnaryOperator::OnLostOperand(uObject* listener)
{
    uStackFrame __("Fuse.Reactive.UnaryOperator", "OnLostOperand(Fuse.Reactive.IListener)");
    ::g::Fuse::Reactive::IListener::OnLostData(uInterface(uPtr(listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)this);
}

// protected void OnNewOperand(Fuse.Reactive.IListener listener, object operand) [instance] :46
void UnaryOperator::OnNewOperand(uObject* listener, uObject* operand)
{
    uStackFrame __("Fuse.Reactive.UnaryOperator", "OnNewOperand(Fuse.Reactive.IListener,object)");
    uObject* result;

    if (TryCompute1(operand, &result))
        ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)this, result);
    else
    {
        ::g::Fuse::Diagnostics::UserWarning(::g::Uno::String::op_Addition1(::STRINGS[151/*"Failed to c...*/], operand), this, ::STRINGS[152/*"C:\\Users\\...*/], 55, ::STRINGS[153/*"OnNewOperand"*/]);
        ::g::Fuse::Reactive::IListener::OnLostData(uInterface(uPtr(listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)this);
    }
}

// public Fuse.Reactive.Expression get_Operand() [instance] :10
::g::Fuse::Reactive::Expression* UnaryOperator::Operand()
{
    uStackFrame __("Fuse.Reactive.UnaryOperator", "get_Operand()");
    return GetArgument(0);
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\ObserverMap.uno
// ---------------------------------------------------------------------------------------

// internal sealed class UnmappedView<T> :8
// {
static void UnmappedView_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::IArray_typeof(), offsetof(UnmappedView_type, interface0));
    type->SetFields(0,
        ::g::Fuse::Reactive::ObserverMap_typeof()->MakeType(type->T(0), NULL), offsetof(UnmappedView, _source), 0);
}

UnmappedView_type* UnmappedView_typeof()
{
    static uSStrong<UnmappedView_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 1;
    options.GenericCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(UnmappedView);
    options.TypeSize = sizeof(UnmappedView_type);
    type = (UnmappedView_type*)uClassType::New("Fuse.Reactive.UnmappedView`1", options);
    type->fp_build_ = UnmappedView_build;
    type->interface0.fp_get_Length = (void(*)(uObject*, int32_t*))UnmappedView__get_Length_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uObject**))UnmappedView__get_Item_fn;
    return type;
}

// public UnmappedView(Fuse.Reactive.ObserverMap<T> source) :11
void UnmappedView__ctor__fn(UnmappedView* __this, ::g::Fuse::Reactive::ObserverMap* source)
{
    __this->ctor_(source);
}

// public object get_Item(int index) :17
void UnmappedView__get_Item_fn(UnmappedView* __this, int32_t* index, uObject** __retval)
{
    *__retval = __this->Item(*index);
}

// public int get_Length() :16
void UnmappedView__get_Length_fn(UnmappedView* __this, int32_t* __retval)
{
    *__retval = __this->Length();
}

// public UnmappedView New(Fuse.Reactive.ObserverMap<T> source) :11
void UnmappedView__New1_fn(uType* __type, ::g::Fuse::Reactive::ObserverMap* source, UnmappedView** __retval)
{
    *__retval = UnmappedView::New1(__type, source);
}

// public UnmappedView(Fuse.Reactive.ObserverMap<T> source) [instance] :11
void UnmappedView::ctor_(::g::Fuse::Reactive::ObserverMap* source)
{
    _source = source;
}

// public object get_Item(int index) [instance] :17
uObject* UnmappedView::Item(int32_t index)
{
    uStackFrame __("Fuse.Reactive.UnmappedView`1", "get_Item(int)");
    uObject* ret2;
    return uPtr(_source)->UVUnmap((::g::Uno::Collections::List__get_Item_fn(uPtr((::g::Uno::Collections::List*)uPtr(_source)->_list), uCRef<int32_t>(index), &ret2), ret2));
}

// public int get_Length() [instance] :16
int32_t UnmappedView::Length()
{
    uStackFrame __("Fuse.Reactive.UnmappedView`1", "get_Length()");
    return uPtr((::g::Uno::Collections::List*)uPtr(_source)->_list)->Count();
}

// public UnmappedView New(Fuse.Reactive.ObserverMap<T> source) [static] :11
UnmappedView* UnmappedView::New1(uType* __type, ::g::Fuse::Reactive::ObserverMap* source)
{
    UnmappedView* obj1 = (UnmappedView*)uNew(__type);
    obj1->ctor_(source);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\ValueObserver.uno
// -----------------------------------------------------------------------------------------

// internal sealed class ValueForwarder :106
// {
static void ValueForwarder_build(uType* type)
{
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(::g::Fuse::Reactive::ValueObserver_type, interface0),
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(::g::Fuse::Reactive::ValueObserver_type, interface1));
    type->SetFields(2,
        ValueForwarder__IValueListener_typeof(), offsetof(ValueForwarder, _listener), 0);
}

::g::Fuse::Reactive::ValueObserver_type* ValueForwarder_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::ValueObserver_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ValueObserver_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(ValueForwarder);
    options.TypeSize = sizeof(::g::Fuse::Reactive::ValueObserver_type);
    type = (::g::Fuse::Reactive::ValueObserver_type*)uClassType::New("Fuse.Reactive.ValueForwarder", options);
    type->fp_build_ = ValueForwarder_build;
    type->fp_LostData = (void(*)(::g::Fuse::Reactive::ValueObserver*))ValueForwarder__LostData_fn;
    type->fp_PushData = (void(*)(::g::Fuse::Reactive::ValueObserver*, uObject*))ValueForwarder__PushData_fn;
    type->interface1.fp_OnClear = (void(*)(uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnClear_fn;
    type->interface1.fp_OnSet = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnSet_fn;
    type->interface1.fp_OnAdd = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnAdd_fn;
    type->interface1.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnNewAt_fn;
    type->interface1.fp_OnFailed = (void(*)(uObject*, uString*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnFailed_fn;
    type->interface1.fp_OnNewAll = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnNewAll_fn;
    type->interface1.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface1.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnInsertAt_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))::g::Fuse::Reactive::ValueObserver__Dispose_fn;
    return type;
}

// public ValueForwarder(Fuse.Reactive.IObservable obs, Fuse.Reactive.ValueForwarder.IValueListener listener) :115
void ValueForwarder__ctor_1_fn(ValueForwarder* __this, uObject* obs, uObject* listener)
{
    __this->ctor_1(obs, listener);
}

// protected override sealed void LostData() :125
void ValueForwarder__LostData_fn(ValueForwarder* __this)
{
    uStackFrame __("Fuse.Reactive.ValueForwarder", "LostData()");
    ValueForwarder__IValueListener::LostValue(uInterface(uPtr(__this->_listener), ValueForwarder__IValueListener_typeof()));
}

// public ValueForwarder New(Fuse.Reactive.IObservable obs, Fuse.Reactive.ValueForwarder.IValueListener listener) :115
void ValueForwarder__New1_fn(uObject* obs, uObject* listener, ValueForwarder** __retval)
{
    *__retval = ValueForwarder::New1(obs, listener);
}

// protected override sealed void PushData(object newValue) :121
void ValueForwarder__PushData_fn(ValueForwarder* __this, uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.ValueForwarder", "PushData(object)");
    ValueForwarder__IValueListener::NewValue(uInterface(uPtr(__this->_listener), ValueForwarder__IValueListener_typeof()), newValue);
}

// public ValueForwarder(Fuse.Reactive.IObservable obs, Fuse.Reactive.ValueForwarder.IValueListener listener) [instance] :115
void ValueForwarder::ctor_1(uObject* obs, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.ValueForwarder", ".ctor(Fuse.Reactive.IObservable,Fuse.Reactive.ValueForwarder.IValueListener)");
    ctor_();
    _listener = listener;
    Subscribe(obs);
}

// public ValueForwarder New(Fuse.Reactive.IObservable obs, Fuse.Reactive.ValueForwarder.IValueListener listener) [static] :115
ValueForwarder* ValueForwarder::New1(uObject* obs, uObject* listener)
{
    ValueForwarder* obj1 = (ValueForwarder*)uNew(ValueForwarder_typeof());
    obj1->ctor_1(obs, listener);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive\1.8.1\ValueObserver.uno
// -----------------------------------------------------------------------------------------

// internal abstract class ValueObserver :11
// {
static void ValueObserver_build(uType* type)
{
    ::TYPES[28] = ::g::Fuse::IArray_typeof();
    ::TYPES[30] = ::g::Fuse::Reactive::IObservableArray_typeof();
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    type->SetInterfaces(
        ::TYPES[3/*Uno.IDisposable*/], offsetof(ValueObserver_type, interface0),
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(ValueObserver_type, interface1));
    type->SetFields(0,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(ValueObserver, _obsSub), 0,
        ::g::Fuse::Reactive::IObservable_typeof(), offsetof(ValueObserver, _obs), 0);
}

ValueObserver_type* ValueObserver_typeof()
{
    static uSStrong<ValueObserver_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 2;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(ValueObserver);
    options.TypeSize = sizeof(ValueObserver_type);
    type = (ValueObserver_type*)uClassType::New("Fuse.Reactive.ValueObserver", options);
    type->fp_build_ = ValueObserver_build;
    type->fp_Dispose = ValueObserver__Dispose_fn;
    type->interface1.fp_OnClear = (void(*)(uObject*))ValueObserver__FuseReactiveIObserverOnClear_fn;
    type->interface1.fp_OnSet = (void(*)(uObject*, uObject*))ValueObserver__FuseReactiveIObserverOnSet_fn;
    type->interface1.fp_OnAdd = (void(*)(uObject*, uObject*))ValueObserver__FuseReactiveIObserverOnAdd_fn;
    type->interface1.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))ValueObserver__FuseReactiveIObserverOnNewAt_fn;
    type->interface1.fp_OnFailed = (void(*)(uObject*, uString*))ValueObserver__FuseReactiveIObserverOnFailed_fn;
    type->interface1.fp_OnNewAll = (void(*)(uObject*, uObject*))ValueObserver__FuseReactiveIObserverOnNewAll_fn;
    type->interface1.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))ValueObserver__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface1.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))ValueObserver__FuseReactiveIObserverOnInsertAt_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))ValueObserver__Dispose_fn;
    return type;
}

// protected generated ValueObserver() :11
void ValueObserver__ctor__fn(ValueObserver* __this)
{
    __this->ctor_();
}

// public virtual void Dispose() :51
void ValueObserver__Dispose_fn(ValueObserver* __this)
{
    uStackFrame __("Fuse.Reactive.ValueObserver", "Dispose()");
    __this->Unsubscribe();
}

// private void Fuse.Reactive.IObserver.OnAdd(object addedValue) :69
void ValueObserver__FuseReactiveIObserverOnAdd_fn(ValueObserver* __this, uObject* addedValue)
{
    uStackFrame __("Fuse.Reactive.ValueObserver", "Fuse.Reactive.IObserver.OnAdd(object)");
    __this->PushData(::g::Fuse::IArray::Item(uInterface(uPtr(__this->_obs), ::TYPES[28/*Fuse.IArray*/]), 0));
}

// private void Fuse.Reactive.IObserver.OnClear() :59
void ValueObserver__FuseReactiveIObserverOnClear_fn(ValueObserver* __this)
{
    uStackFrame __("Fuse.Reactive.ValueObserver", "Fuse.Reactive.IObserver.OnClear()");
    __this->LostData();
}

// private void Fuse.Reactive.IObserver.OnFailed(string message) :79
void ValueObserver__FuseReactiveIObserverOnFailed_fn(ValueObserver* __this, uString* message)
{
    uStackFrame __("Fuse.Reactive.ValueObserver", "Fuse.Reactive.IObserver.OnFailed(string)");
    __this->LostData();
}

// private void Fuse.Reactive.IObserver.OnInsertAt(int index, object value) :100
void ValueObserver__FuseReactiveIObserverOnInsertAt_fn(ValueObserver* __this, int32_t* index, uObject* value)
{
    uStackFrame __("Fuse.Reactive.ValueObserver", "Fuse.Reactive.IObserver.OnInsertAt(int,object)");
    __this->PushData(::g::Fuse::IArray::Item(uInterface(uPtr(__this->_obs), ::TYPES[28/*Fuse.IArray*/]), 0));
}

// private void Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray values) :84
void ValueObserver__FuseReactiveIObserverOnNewAll_fn(ValueObserver* __this, uObject* values)
{
    uStackFrame __("Fuse.Reactive.ValueObserver", "Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray)");

    if (::g::Fuse::IArray::Length(uInterface(uPtr(values), ::TYPES[28/*Fuse.IArray*/])) > 0)
        __this->PushData(::g::Fuse::IArray::Item(uInterface(uPtr(__this->_obs), ::TYPES[28/*Fuse.IArray*/]), 0));
    else
        __this->LostData();
}

// private void Fuse.Reactive.IObserver.OnNewAt(int index, object value) :74
void ValueObserver__FuseReactiveIObserverOnNewAt_fn(ValueObserver* __this, int32_t* index, uObject* value)
{
    uStackFrame __("Fuse.Reactive.ValueObserver", "Fuse.Reactive.IObserver.OnNewAt(int,object)");
    __this->PushData(::g::Fuse::IArray::Item(uInterface(uPtr(__this->_obs), ::TYPES[28/*Fuse.IArray*/]), 0));
}

// private void Fuse.Reactive.IObserver.OnRemoveAt(int index) :92
void ValueObserver__FuseReactiveIObserverOnRemoveAt_fn(ValueObserver* __this, int32_t* index)
{
    uStackFrame __("Fuse.Reactive.ValueObserver", "Fuse.Reactive.IObserver.OnRemoveAt(int)");

    if (::g::Fuse::IArray::Length(uInterface(uPtr(__this->_obs), ::TYPES[28/*Fuse.IArray*/])) > 0)
        __this->PushData(::g::Fuse::IArray::Item(uInterface(uPtr(__this->_obs), ::TYPES[28/*Fuse.IArray*/]), 0));
    else
        __this->LostData();
}

// private void Fuse.Reactive.IObserver.OnSet(object newValue) :64
void ValueObserver__FuseReactiveIObserverOnSet_fn(ValueObserver* __this, uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.ValueObserver", "Fuse.Reactive.IObserver.OnSet(object)");
    __this->PushData(newValue);
}

// public Fuse.Reactive.IObservable get_Observable() :16
void ValueObserver__get_Observable_fn(ValueObserver* __this, uObject** __retval)
{
    *__retval = __this->Observable();
}

// protected void Subscribe(Fuse.Reactive.IObservable obs) :31
void ValueObserver__Subscribe_fn(ValueObserver* __this, uObject* obs)
{
    __this->Subscribe(obs);
}

// protected void SubscribeNoPush(Fuse.Reactive.IObservable obs) :38
void ValueObserver__SubscribeNoPush_fn(ValueObserver* __this, uObject* obs)
{
    __this->SubscribeNoPush(obs);
}

// protected void Unsubscribe() :44
void ValueObserver__Unsubscribe_fn(ValueObserver* __this)
{
    __this->Unsubscribe();
}

// protected object get_Value() :20
void ValueObserver__get_Value_fn(ValueObserver* __this, uObject** __retval)
{
    *__retval = __this->Value();
}

// protected generated ValueObserver() [instance] :11
void ValueObserver::ctor_()
{
}

// public Fuse.Reactive.IObservable get_Observable() [instance] :16
uObject* ValueObserver::Observable()
{
    return _obs;
}

// protected void Subscribe(Fuse.Reactive.IObservable obs) [instance] :31
void ValueObserver::Subscribe(uObject* obs)
{
    uStackFrame __("Fuse.Reactive.ValueObserver", "Subscribe(Fuse.Reactive.IObservable)");
    _obs = obs;

    if (::g::Fuse::IArray::Length(uInterface(uPtr(obs), ::TYPES[28/*Fuse.IArray*/])) > 0)
        PushData(::g::Fuse::IArray::Item(uInterface(uPtr(obs), ::TYPES[28/*Fuse.IArray*/]), 0));

    _obsSub = ::g::Fuse::Reactive::IObservableArray::Subscribe(uInterface(uPtr(obs), ::TYPES[30/*Fuse.Reactive.IObservableArray*/]), (uObject*)this);
}

// protected void SubscribeNoPush(Fuse.Reactive.IObservable obs) [instance] :38
void ValueObserver::SubscribeNoPush(uObject* obs)
{
    uStackFrame __("Fuse.Reactive.ValueObserver", "SubscribeNoPush(Fuse.Reactive.IObservable)");
    _obs = obs;
    _obsSub = ::g::Fuse::Reactive::IObservableArray::Subscribe(uInterface(uPtr(obs), ::TYPES[30/*Fuse.Reactive.IObservableArray*/]), (uObject*)this);
}

// protected void Unsubscribe() [instance] :44
void ValueObserver::Unsubscribe()
{
    uStackFrame __("Fuse.Reactive.ValueObserver", "Unsubscribe()");

    if (_obsSub != NULL)
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_obsSub), ::TYPES[3/*Uno.IDisposable*/]));

    _obsSub = NULL;
    _obs = NULL;
}

// protected object get_Value() [instance] :20
uObject* ValueObserver::Value()
{
    uStackFrame __("Fuse.Reactive.ValueObserver", "get_Value()");

    if (_obs == NULL)
        return NULL;

    if (::g::Fuse::IArray::Length(uInterface(uPtr(_obs), ::TYPES[28/*Fuse.IArray*/])) == 0)
        return NULL;

    return ::g::Fuse::IArray::Item(uInterface(uPtr(_obs), ::TYPES[28/*Fuse.IArray*/]), 0);
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\VarArgFunction.uno
// ------------------------------------------------------------------------------------------------------

// public abstract class VarArgFunction :11
// {
static void VarArgFunction_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->SetFields(0,
        ::g::Uno::Collections::List_typeof()->MakeType(::g::Fuse::Reactive::Expression_typeof(), NULL), offsetof(VarArgFunction, _args), 0);
    type->Reflection.SetFunctions(1,
        new uFunction("get_Arguments", NULL, (void*)VarArgFunction__get_Arguments_fn, 0, false, ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Reactive::Expression_typeof(), NULL), 0));
}

::g::Fuse::Reactive::Expression_type* VarArgFunction_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(VarArgFunction);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.VarArgFunction", options);
    type->fp_build_ = VarArgFunction_build;
    return type;
}

// public VarArgFunction() :16
void VarArgFunction__ctor_1_fn(VarArgFunction* __this)
{
    __this->ctor_1();
}

// public Uno.Collections.IList<Fuse.Reactive.Expression> get_Arguments() :14
void VarArgFunction__get_Arguments_fn(VarArgFunction* __this, uObject** __retval)
{
    *__retval = __this->Arguments();
}

// protected string FormatString(string funcName) :19
void VarArgFunction__FormatString_fn(VarArgFunction* __this, uString* funcName, uString** __retval)
{
    *__retval = __this->FormatString(funcName);
}

// public VarArgFunction() [instance] :16
void VarArgFunction::ctor_1()
{
    _args = ((::g::Uno::Collections::List*)::g::Uno::Collections::List::New1(::TYPES[60/*Uno.Collections.List`1*/]->MakeType(::g::Fuse::Reactive::Expression_typeof(), NULL)));
    ctor_();
}

// public Uno.Collections.IList<Fuse.Reactive.Expression> get_Arguments() [instance] :14
uObject* VarArgFunction::Arguments()
{
    uStackFrame __("Fuse.Reactive.VarArgFunction", "get_Arguments()");
    return (uObject*)_args;
}

// protected string FormatString(string funcName) [instance] :19
uString* VarArgFunction::FormatString(uString* funcName)
{
    uStackFrame __("Fuse.Reactive.VarArgFunction", "FormatString(string)");
    ::g::Fuse::Reactive::Expression* ret1;
    uString* q = ::g::Uno::String::op_Addition2(funcName, ::STRINGS[4/*"("*/]);

    for (int32_t i = 0; i < ::g::Uno::Collections::ICollection::Count(uInterface(uPtr(Arguments()), ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Reactive::Expression_typeof(), NULL))); ++i)
    {
        if (i > 0)
            q = ::g::Uno::String::op_Addition2(q, ::STRINGS[17/*","*/]);

        q = ::g::Uno::String::op_Addition2(q, ::g::Uno::Object::ToString(uPtr((::g::Uno::Collections::IList::get_Item_ex(uInterface(uPtr(Arguments()), ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Reactive::Expression_typeof(), NULL)), uCRef<int32_t>(i), &ret1), ret1))));
    }

    q = ::g::Uno::String::op_Addition2(q, ::STRINGS[6/*")"*/]);
    return q;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\VectorFunctions.uno
// -------------------------------------------------------------------------------------------------------

// public sealed class Vector :11
// {
static void Vector_build(uType* type)
{
    ::STRINGS[26] = uString::Const("");
    ::TYPES[26] = ::g::Fuse::Reactive::IListener_typeof();
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::SimpleVarArgFunction_type, interface0));
    type->SetFields(1);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)Vector__New1_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::SimpleVarArgFunction_type* Vector_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::SimpleVarArgFunction_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::SimpleVarArgFunction_typeof();
    options.FieldCount = 1;
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(Vector);
    options.TypeSize = sizeof(::g::Fuse::Reactive::SimpleVarArgFunction_type);
    type = (::g::Fuse::Reactive::SimpleVarArgFunction_type*)uClassType::New("Fuse.Reactive.Vector", options);
    type->fp_build_ = Vector_build;
    type->fp_ctor_ = (void*)Vector__New1_fn;
    type->fp_OnNewArguments = (void(*)(::g::Fuse::Reactive::SimpleVarArgFunction*, uArray*, uObject*))Vector__OnNewArguments_fn;
    type->fp_ToString = (void(*)(uObject*, uString**))Vector__ToString_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::SimpleVarArgFunction__Subscribe_fn;
    return type;
}

// public generated Vector() :11
void Vector__ctor_3_fn(Vector* __this)
{
    __this->ctor_3();
}

// public generated Vector New() :11
void Vector__New1_fn(Vector** __retval)
{
    *__retval = Vector::New1();
}

// protected override sealed void OnNewArguments(Fuse.Reactive.Expression.Argument[] args, Fuse.Reactive.IListener listener) :13
void Vector__OnNewArguments_fn(Vector* __this, uArray* args, uObject* listener)
{
    uStackFrame __("Fuse.Reactive.Vector", "OnNewArguments(Fuse.Reactive.Expression.Argument[],Fuse.Reactive.IListener)");
    ::g::Fuse::Reactive::IListener::OnNewData(uInterface(uPtr(listener), ::TYPES[26/*Fuse.Reactive.IListener*/]), (uObject*)__this, ::g::Fuse::Reactive::Array::New1(args));
}

// public override sealed string ToString() :18
void Vector__ToString_fn(Vector* __this, uString** __retval)
{
    uStackFrame __("Fuse.Reactive.Vector", "ToString()");
    return *__retval = __this->FormatString(::STRINGS[26/*""*/]), void();
}

// public generated Vector() [instance] :11
void Vector::ctor_3()
{
    ctor_2();
}

// public generated Vector New() [static] :11
Vector* Vector::New1()
{
    Vector* obj1 = (Vector*)uNew(Vector_typeof());
    obj1->ctor_3();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\VectorFunctions.uno
// -------------------------------------------------------------------------------------------------------

// public sealed class VectorW :76
// {
static void VectorW_build(uType* type)
{
    ::STRINGS[154] = uString::Const("w");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)VectorW__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* VectorW_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(VectorW);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.VectorW", options);
    type->fp_build_ = VectorW_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::UnaryOperator*, uObject*, uObject**, bool*))VectorW__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public VectorW(Fuse.Reactive.Expression operand) :79
void VectorW__ctor_4_fn(VectorW* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_4(operand);
}

// public VectorW New(Fuse.Reactive.Expression operand) :79
void VectorW__New1_fn(::g::Fuse::Reactive::Expression* operand, VectorW** __retval)
{
    *__retval = VectorW::New1(operand);
}

// protected override sealed bool TryCompute(object operand, object& result) :81
void VectorW__TryCompute1_fn(VectorW* __this, uObject* operand, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.VectorW", "TryCompute(object,object&)");
    *result = NULL;
    ::g::Uno::Float4 v = ::g::Uno::Float4__New1(0.0f);
    int32_t size;

    if (!::g::Fuse::Marshal::TryToZeroFloat4(operand, &v, &size) || (size < 4))
        return *__retval = false, void();

    *result = uBox(::TYPES[21/*float*/], v.W);
    return *__retval = true, void();
}

// public VectorW(Fuse.Reactive.Expression operand) [instance] :79
void VectorW::ctor_4(::g::Fuse::Reactive::Expression* operand)
{
    uStackFrame __("Fuse.Reactive.VectorW", ".ctor(Fuse.Reactive.Expression)");
    ctor_3(operand, ::STRINGS[154/*"w"*/], 0);
}

// public VectorW New(Fuse.Reactive.Expression operand) [static] :79
VectorW* VectorW::New1(::g::Fuse::Reactive::Expression* operand)
{
    VectorW* obj1 = (VectorW*)uNew(VectorW_typeof());
    obj1->ctor_4(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Expressions\1.8.1\VectorFunctions.uno
// -------------------------------------------------------------------------------------------------------

// public sealed class VectorZ :54
// {
static void VectorZ_build(uType* type)
{
    ::STRINGS[155] = uString::Const("z");
    type->SetDependencies(
        ::g::Fuse::Marshal_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::UnaryOperator_type, interface0));
    type->SetFields(3);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)VectorZ__New1_fn, 0, true, type, 1, ::g::Fuse::Reactive::Expression_typeof()));
}

::g::Fuse::Reactive::UnaryOperator_type* VectorZ_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::UnaryOperator_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::UnaryOperator_typeof();
    options.FieldCount = 3;
    options.InterfaceCount = 1;
    options.DependencyCount = 1;
    options.ObjectSize = sizeof(VectorZ);
    options.TypeSize = sizeof(::g::Fuse::Reactive::UnaryOperator_type);
    type = (::g::Fuse::Reactive::UnaryOperator_type*)uClassType::New("Fuse.Reactive.VectorZ", options);
    type->fp_build_ = VectorZ_build;
    type->fp_TryCompute1 = (void(*)(::g::Fuse::Reactive::UnaryOperator*, uObject*, uObject**, bool*))VectorZ__TryCompute1_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))::g::Fuse::Reactive::ComputeExpression__Subscribe_fn;
    return type;
}

// public VectorZ(Fuse.Reactive.Expression operand) :57
void VectorZ__ctor_4_fn(VectorZ* __this, ::g::Fuse::Reactive::Expression* operand)
{
    __this->ctor_4(operand);
}

// public VectorZ New(Fuse.Reactive.Expression operand) :57
void VectorZ__New1_fn(::g::Fuse::Reactive::Expression* operand, VectorZ** __retval)
{
    *__retval = VectorZ::New1(operand);
}

// protected override sealed bool TryCompute(object operand, object& result) :59
void VectorZ__TryCompute1_fn(VectorZ* __this, uObject* operand, uObject** result, bool* __retval)
{
    uStackFrame __("Fuse.Reactive.VectorZ", "TryCompute(object,object&)");
    *result = NULL;
    ::g::Uno::Float4 v = ::g::Uno::Float4__New1(0.0f);
    int32_t size;

    if (!::g::Fuse::Marshal::TryToZeroFloat4(operand, &v, &size) || (size < 3))
        return *__retval = false, void();

    *result = uBox(::TYPES[21/*float*/], v.Z);
    return *__retval = true, void();
}

// public VectorZ(Fuse.Reactive.Expression operand) [instance] :57
void VectorZ::ctor_4(::g::Fuse::Reactive::Expression* operand)
{
    uStackFrame __("Fuse.Reactive.VectorZ", ".ctor(Fuse.Reactive.Expression)");
    ctor_3(operand, ::STRINGS[155/*"z"*/], 0);
}

// public VectorZ New(Fuse.Reactive.Expression operand) [static] :57
VectorZ* VectorZ::New1(::g::Fuse::Reactive::Expression* operand)
{
    VectorZ* obj1 = (VectorZ*)uNew(VectorZ_typeof());
    obj1->ctor_4(operand);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\WhileCount.uno
// -----------------------------------------------------------------------------------------------

// public class WhileCount :44
// {
static void WhileCount_build(uType* type)
{
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(WhileCount_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(WhileCount_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(WhileCount_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(WhileCount_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(WhileCount_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(WhileCount_type, interface5),
        ::g::Fuse::Animations::IUnwrappedPlayerFeedback_typeof(), offsetof(WhileCount_type, interface6),
        ::g::Fuse::Animations::IBasePlayerFeedback_typeof(), offsetof(WhileCount_type, interface7),
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(WhileCount_type, interface8));
    type->SetFields(38,
        uObject_typeof(), offsetof(WhileCount, _items), 0,
        ::g::Uno::Int_typeof(), offsetof(WhileCount, _oldCount), 0,
        ::g::Uno::Int2_typeof(), offsetof(WhileCount, _compare), 0,
        WhileCount__Range_typeof(), offsetof(WhileCount, _low), 0,
        WhileCount__Range_typeof(), offsetof(WhileCount, _high), 0,
        ::g::Uno::IDisposable_typeof(), offsetof(WhileCount, _subscription), 0);
    type->Reflection.SetFunctions(13,
        new uFunction("get_EqualTo", NULL, (void*)WhileCount__get_EqualTo_fn, 0, false, ::g::Uno::Int_typeof(), 0),
        new uFunction("set_EqualTo", NULL, (void*)WhileCount__set_EqualTo_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::Int_typeof()),
        new uFunction("get_GreaterThan", NULL, (void*)WhileCount__get_GreaterThan_fn, 0, false, ::g::Uno::Int_typeof(), 0),
        new uFunction("set_GreaterThan", NULL, (void*)WhileCount__set_GreaterThan_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::Int_typeof()),
        new uFunction("get_GreaterThanEqual", NULL, (void*)WhileCount__get_GreaterThanEqual_fn, 0, false, ::g::Uno::Int_typeof(), 0),
        new uFunction("set_GreaterThanEqual", NULL, (void*)WhileCount__set_GreaterThanEqual_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::Int_typeof()),
        new uFunction("get_Items", NULL, (void*)WhileCount__get_Items_fn, 0, false, uObject_typeof(), 0),
        new uFunction("set_Items", NULL, (void*)WhileCount__set_Items_fn, 0, false, uVoid_typeof(), 1, uObject_typeof()),
        new uFunction("get_LessThan", NULL, (void*)WhileCount__get_LessThan_fn, 0, false, ::g::Uno::Int_typeof(), 0),
        new uFunction("set_LessThan", NULL, (void*)WhileCount__set_LessThan_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::Int_typeof()),
        new uFunction("get_LessThanEqual", NULL, (void*)WhileCount__get_LessThanEqual_fn, 0, false, ::g::Uno::Int_typeof(), 0),
        new uFunction("set_LessThanEqual", NULL, (void*)WhileCount__set_LessThanEqual_fn, 0, false, uVoid_typeof(), 1, ::g::Uno::Int_typeof()),
        new uFunction(".ctor", NULL, (void*)WhileCount__New2_fn, 0, true, type, 0));
}

WhileCount_type* WhileCount_typeof()
{
    static uSStrong<WhileCount_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Triggers::WhileTrigger_typeof();
    options.FieldCount = 44;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(WhileCount);
    options.TypeSize = sizeof(WhileCount_type);
    type = (WhileCount_type*)uClassType::New("Fuse.Reactive.WhileCount", options);
    type->fp_build_ = WhileCount_build;
    type->fp_ctor_ = (void*)WhileCount__New2_fn;
    type->fp_OnRooted = (void(*)(::g::Fuse::Node*))WhileCount__OnRooted_fn;
    type->fp_OnUnrooted = (void(*)(::g::Fuse::Node*))WhileCount__OnUnrooted_fn;
    type->interface8.fp_OnSet = (void(*)(uObject*, uObject*))WhileCount__FuseReactiveIObserverOnSet_fn;
    type->interface8.fp_OnFailed = (void(*)(uObject*, uString*))WhileCount__FuseReactiveIObserverOnFailed_fn;
    type->interface8.fp_OnAdd = (void(*)(uObject*, uObject*))WhileCount__FuseReactiveIObserverOnAdd_fn;
    type->interface8.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))WhileCount__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface8.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))WhileCount__FuseReactiveIObserverOnNewAt_fn;
    type->interface8.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))WhileCount__FuseReactiveIObserverOnInsertAt_fn;
    type->interface8.fp_OnClear = (void(*)(uObject*))WhileCount__FuseReactiveIObserverOnClear_fn;
    type->interface8.fp_OnNewAll = (void(*)(uObject*, uObject*))WhileCount__FuseReactiveIObserverOnNewAll_fn;
    type->interface7.fp_OnPlaybackDone = (void(*)(uObject*, uObject*))::g::Fuse::Triggers::Trigger__FuseAnimationsIBasePlayerFeedbackOnPlaybackDone_fn;
    type->interface7.fp_OnStable = (void(*)(uObject*, uObject*))::g::Fuse::Triggers::Trigger__FuseAnimationsIBasePlayerFeedbackOnStable_fn;
    type->interface6.fp_OnProgressUpdated = (void(*)(uObject*, uObject*, double*, double*, int32_t*))::g::Fuse::Triggers::Trigger__FuseAnimationsIUnwrappedPlayerFeedbackOnProgressUpdated_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public generated WhileCount() :44
void WhileCount__ctor_6_fn(WhileCount* __this)
{
    __this->ctor_6();
}

// private void Assess(int count) :125
void WhileCount__Assess_fn(WhileCount* __this, int32_t* count)
{
    __this->Assess(*count);
}

// public int get_EqualTo() :206
void WhileCount__get_EqualTo_fn(WhileCount* __this, int32_t* __retval)
{
    *__retval = __this->EqualTo();
}

// public void set_EqualTo(int value) :207
void WhileCount__set_EqualTo_fn(WhileCount* __this, int32_t* value)
{
    __this->EqualTo(*value);
}

// private void Fuse.Reactive.IObserver.OnAdd(object addedValue) :226
void WhileCount__FuseReactiveIObserverOnAdd_fn(WhileCount* __this, uObject* addedValue)
{
    __this->Assess(__this->_oldCount + 1);
}

// private void Fuse.Reactive.IObserver.OnClear() :244
void WhileCount__FuseReactiveIObserverOnClear_fn(WhileCount* __this)
{
    __this->Assess(0);
}

// private void Fuse.Reactive.IObserver.OnFailed(string message) :222
void WhileCount__FuseReactiveIObserverOnFailed_fn(WhileCount* __this, uString* message)
{
    __this->Assess(0);
}

// private void Fuse.Reactive.IObserver.OnInsertAt(int index, object value) :239
void WhileCount__FuseReactiveIObserverOnInsertAt_fn(WhileCount* __this, int32_t* index, uObject* value)
{
    __this->Assess(__this->_oldCount + 1);
}

// private void Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray values) :249
void WhileCount__FuseReactiveIObserverOnNewAll_fn(WhileCount* __this, uObject* values)
{
    uStackFrame __("Fuse.Reactive.WhileCount", "Fuse.Reactive.IObserver.OnNewAll(Fuse.IArray)");
    __this->Assess(::g::Fuse::IArray::Length(uInterface(uPtr(values), ::TYPES[28/*Fuse.IArray*/])));
}

// private void Fuse.Reactive.IObserver.OnNewAt(int index, object value) :235
void WhileCount__FuseReactiveIObserverOnNewAt_fn(WhileCount* __this, int32_t* index, uObject* value)
{
}

// private void Fuse.Reactive.IObserver.OnRemoveAt(int index) :230
void WhileCount__FuseReactiveIObserverOnRemoveAt_fn(WhileCount* __this, int32_t* index)
{
    __this->Assess(__this->_oldCount - 1);
}

// private void Fuse.Reactive.IObserver.OnSet(object newValue) :218
void WhileCount__FuseReactiveIObserverOnSet_fn(WhileCount* __this, uObject* newValue)
{
    __this->Assess(1);
}

// public int get_GreaterThan() :182
void WhileCount__get_GreaterThan_fn(WhileCount* __this, int32_t* __retval)
{
    *__retval = __this->GreaterThan();
}

// public void set_GreaterThan(int value) :183
void WhileCount__set_GreaterThan_fn(WhileCount* __this, int32_t* value)
{
    __this->GreaterThan(*value);
}

// public int get_GreaterThanEqual() :194
void WhileCount__get_GreaterThanEqual_fn(WhileCount* __this, int32_t* __retval)
{
    *__retval = __this->GreaterThanEqual();
}

// public void set_GreaterThanEqual(int value) :195
void WhileCount__set_GreaterThanEqual_fn(WhileCount* __this, int32_t* value)
{
    __this->GreaterThanEqual(*value);
}

// private bool IsOn(int count) :131
void WhileCount__IsOn_fn(WhileCount* __this, int32_t* count, bool* __retval)
{
    *__retval = __this->IsOn(*count);
}

// public object get_Items() :69
void WhileCount__get_Items_fn(WhileCount* __this, uObject** __retval)
{
    *__retval = __this->Items();
}

// public void set_Items(object value) :70
void WhileCount__set_Items_fn(WhileCount* __this, uObject* value)
{
    __this->Items(value);
}

// public int get_LessThan() :158
void WhileCount__get_LessThan_fn(WhileCount* __this, int32_t* __retval)
{
    *__retval = __this->LessThan();
}

// public void set_LessThan(int value) :159
void WhileCount__set_LessThan_fn(WhileCount* __this, int32_t* value)
{
    __this->LessThan(*value);
}

// public int get_LessThanEqual() :170
void WhileCount__get_LessThanEqual_fn(WhileCount* __this, int32_t* __retval)
{
    *__retval = __this->LessThanEqual();
}

// public void set_LessThanEqual(int value) :171
void WhileCount__set_LessThanEqual_fn(WhileCount* __this, int32_t* value)
{
    __this->LessThanEqual(*value);
}

// public generated WhileCount New() :44
void WhileCount__New2_fn(WhileCount** __retval)
{
    *__retval = WhileCount::New2();
}

// private void OnItemsChanged() :80
void WhileCount__OnItemsChanged_fn(WhileCount* __this)
{
    __this->OnItemsChanged();
}

// protected override sealed void OnRooted() :46
void WhileCount__OnRooted_fn(WhileCount* __this)
{
    uStackFrame __("Fuse.Reactive.WhileCount", "OnRooted()");
    ::g::Fuse::Triggers::Trigger__OnRooted_fn(__this);
    __this->OnItemsChanged();
}

// protected override sealed void OnUnrooted() :52
void WhileCount__OnUnrooted_fn(WhileCount* __this)
{
    uStackFrame __("Fuse.Reactive.WhileCount", "OnUnrooted()");

    if (__this->_subscription != NULL)
    {
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(__this->_subscription), ::TYPES[3/*Uno.IDisposable*/]));
        __this->_subscription = NULL;
    }

    ::g::Fuse::Triggers::Trigger__OnUnrooted_fn(__this);
}

// private void UpdateState() :94
void WhileCount__UpdateState_fn(WhileCount* __this)
{
    __this->UpdateState();
}

// public generated WhileCount() [instance] :44
void WhileCount::ctor_6()
{
    ctor_5();
}

// private void Assess(int count) [instance] :125
void WhileCount::Assess(int32_t count)
{
    _oldCount = count;
    SetActive(IsOn(_oldCount));
}

// public int get_EqualTo() [instance] :206
int32_t WhileCount::EqualTo()
{
    return _compare.X;
}

// public void set_EqualTo(int value) [instance] :207
void WhileCount::EqualTo(int32_t value)
{
    uStackFrame __("Fuse.Reactive.WhileCount", "set_EqualTo(int)");
    _compare.X = (_compare.Y = value);
    _low = 2;
    _high = 2;
    UpdateState();
}

// public int get_GreaterThan() [instance] :182
int32_t WhileCount::GreaterThan()
{
    return _compare.X;
}

// public void set_GreaterThan(int value) [instance] :183
void WhileCount::GreaterThan(int32_t value)
{
    uStackFrame __("Fuse.Reactive.WhileCount", "set_GreaterThan(int)");
    _compare.X = value;
    _low = 1;
    UpdateState();
}

// public int get_GreaterThanEqual() [instance] :194
int32_t WhileCount::GreaterThanEqual()
{
    return _compare.X;
}

// public void set_GreaterThanEqual(int value) [instance] :195
void WhileCount::GreaterThanEqual(int32_t value)
{
    uStackFrame __("Fuse.Reactive.WhileCount", "set_GreaterThanEqual(int)");
    _compare.X = value;
    _low = 2;
    UpdateState();
}

// private bool IsOn(int count) [instance] :131
bool WhileCount::IsOn(int32_t count)
{
    if ((_low == 1) && (count <= _compare.X))
        return false;

    if ((_low == 2) && (count < _compare.X))
        return false;

    if ((_high == 1) && (count >= _compare.Y))
        return false;

    if ((_high == 2) && (count > _compare.Y))
        return false;

    return true;
}

// public object get_Items() [instance] :69
uObject* WhileCount::Items()
{
    return _items;
}

// public void set_Items(object value) [instance] :70
void WhileCount::Items(uObject* value)
{
    uStackFrame __("Fuse.Reactive.WhileCount", "set_Items(object)");

    if (_items != value)
    {
        _items = value;
        OnItemsChanged();
    }
}

// public int get_LessThan() [instance] :158
int32_t WhileCount::LessThan()
{
    return _compare.Y;
}

// public void set_LessThan(int value) [instance] :159
void WhileCount::LessThan(int32_t value)
{
    uStackFrame __("Fuse.Reactive.WhileCount", "set_LessThan(int)");
    _compare.Y = value;
    _high = 1;
    UpdateState();
}

// public int get_LessThanEqual() [instance] :170
int32_t WhileCount::LessThanEqual()
{
    return _compare.Y;
}

// public void set_LessThanEqual(int value) [instance] :171
void WhileCount::LessThanEqual(int32_t value)
{
    uStackFrame __("Fuse.Reactive.WhileCount", "set_LessThanEqual(int)");
    _compare.Y = value;
    _high = 2;
    UpdateState();
}

// private void OnItemsChanged() [instance] :80
void WhileCount::OnItemsChanged()
{
    uStackFrame __("Fuse.Reactive.WhileCount", "OnItemsChanged()");

    if (!IsRootingStarted())
        return;

    if (_subscription != NULL)
        ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_subscription), ::TYPES[3/*Uno.IDisposable*/]));

    uObject* obs = uAs<uObject*>(_items, ::TYPES[30/*Fuse.Reactive.IObservableArray*/]);

    if (obs != NULL)
        _subscription = ::g::Fuse::Reactive::IObservableArray::Subscribe(uInterface(uPtr(obs), ::TYPES[30/*Fuse.Reactive.IObservableArray*/]), (uObject*)this);

    UpdateState();
}

// private void UpdateState() [instance] :94
void WhileCount::UpdateState()
{
    uStackFrame __("Fuse.Reactive.WhileCount", "UpdateState()");

    if (!IsRootingStarted())
        return;

    uArray* e = uAs<uArray*>(_items, ::TYPES[4/*object[]*/]);

    if (e != NULL)
    {
        Assess(uPtr(e)->Length());
        return;
    }

    uObject* obs = uAs<uObject*>(_items, ::TYPES[30/*Fuse.Reactive.IObservableArray*/]);

    if (obs != NULL)
    {
        Assess(::g::Fuse::IArray::Length(uInterface(uPtr(obs), ::TYPES[28/*Fuse.IArray*/])));
        return;
    }

    uObject* arr = uAs<uObject*>(_items, ::TYPES[28/*Fuse.IArray*/]);

    if (arr != NULL)
    {
        Assess(::g::Fuse::IArray::Length(uInterface(uPtr(arr), ::TYPES[28/*Fuse.IArray*/])));
        return;
    }

    Assess(0);
}

// public generated WhileCount New() [static] :44
WhileCount* WhileCount::New2()
{
    WhileCount* obj1 = (WhileCount*)uNew(WhileCount_typeof());
    obj1->ctor_6();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\WhileEmpty.uno
// -----------------------------------------------------------------------------------------------

// public sealed class WhileEmpty :29
// {
static void WhileEmpty_build(uType* type)
{
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::WhileCount_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::WhileCount_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::WhileCount_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::WhileCount_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::WhileCount_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::WhileCount_type, interface5),
        ::g::Fuse::Animations::IUnwrappedPlayerFeedback_typeof(), offsetof(::g::Fuse::Reactive::WhileCount_type, interface6),
        ::g::Fuse::Animations::IBasePlayerFeedback_typeof(), offsetof(::g::Fuse::Reactive::WhileCount_type, interface7),
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(::g::Fuse::Reactive::WhileCount_type, interface8));
    type->SetFields(44);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)WhileEmpty__New3_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::WhileCount_type* WhileEmpty_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::WhileCount_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::WhileCount_typeof();
    options.FieldCount = 44;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(WhileEmpty);
    options.TypeSize = sizeof(::g::Fuse::Reactive::WhileCount_type);
    type = (::g::Fuse::Reactive::WhileCount_type*)uClassType::New("Fuse.Reactive.WhileEmpty", options);
    type->fp_build_ = WhileEmpty_build;
    type->fp_ctor_ = (void*)WhileEmpty__New3_fn;
    type->interface8.fp_OnSet = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnSet_fn;
    type->interface8.fp_OnFailed = (void(*)(uObject*, uString*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnFailed_fn;
    type->interface8.fp_OnAdd = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnAdd_fn;
    type->interface8.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface8.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnNewAt_fn;
    type->interface8.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnInsertAt_fn;
    type->interface8.fp_OnClear = (void(*)(uObject*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnClear_fn;
    type->interface8.fp_OnNewAll = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnNewAll_fn;
    type->interface7.fp_OnPlaybackDone = (void(*)(uObject*, uObject*))::g::Fuse::Triggers::Trigger__FuseAnimationsIBasePlayerFeedbackOnPlaybackDone_fn;
    type->interface7.fp_OnStable = (void(*)(uObject*, uObject*))::g::Fuse::Triggers::Trigger__FuseAnimationsIBasePlayerFeedbackOnStable_fn;
    type->interface6.fp_OnProgressUpdated = (void(*)(uObject*, uObject*, double*, double*, int32_t*))::g::Fuse::Triggers::Trigger__FuseAnimationsIUnwrappedPlayerFeedbackOnProgressUpdated_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public WhileEmpty() :31
void WhileEmpty__ctor_7_fn(WhileEmpty* __this)
{
    __this->ctor_7();
}

// public WhileEmpty New() :31
void WhileEmpty__New3_fn(WhileEmpty** __retval)
{
    *__retval = WhileEmpty::New3();
}

// public WhileEmpty() [instance] :31
void WhileEmpty::ctor_7()
{
    uStackFrame __("Fuse.Reactive.WhileEmpty", ".ctor()");
    ctor_6();
    EqualTo(0);
}

// public WhileEmpty New() [static] :31
WhileEmpty* WhileEmpty::New3()
{
    WhileEmpty* obj1 = (WhileEmpty*)uNew(WhileEmpty_typeof());
    obj1->ctor_7();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\WhileEmpty.uno
// -----------------------------------------------------------------------------------------------

// public sealed class WhileNotEmpty :57
// {
static void WhileNotEmpty_build(uType* type)
{
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::WhileCount_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(::g::Fuse::Reactive::WhileCount_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(::g::Fuse::Reactive::WhileCount_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(::g::Fuse::Reactive::WhileCount_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::WhileCount_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(::g::Fuse::Reactive::WhileCount_type, interface5),
        ::g::Fuse::Animations::IUnwrappedPlayerFeedback_typeof(), offsetof(::g::Fuse::Reactive::WhileCount_type, interface6),
        ::g::Fuse::Animations::IBasePlayerFeedback_typeof(), offsetof(::g::Fuse::Reactive::WhileCount_type, interface7),
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(::g::Fuse::Reactive::WhileCount_type, interface8));
    type->SetFields(44);
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)WhileNotEmpty__New3_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::WhileCount_type* WhileNotEmpty_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::WhileCount_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::WhileCount_typeof();
    options.FieldCount = 44;
    options.InterfaceCount = 9;
    options.ObjectSize = sizeof(WhileNotEmpty);
    options.TypeSize = sizeof(::g::Fuse::Reactive::WhileCount_type);
    type = (::g::Fuse::Reactive::WhileCount_type*)uClassType::New("Fuse.Reactive.WhileNotEmpty", options);
    type->fp_build_ = WhileNotEmpty_build;
    type->fp_ctor_ = (void*)WhileNotEmpty__New3_fn;
    type->interface8.fp_OnSet = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnSet_fn;
    type->interface8.fp_OnFailed = (void(*)(uObject*, uString*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnFailed_fn;
    type->interface8.fp_OnAdd = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnAdd_fn;
    type->interface8.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface8.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnNewAt_fn;
    type->interface8.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnInsertAt_fn;
    type->interface8.fp_OnClear = (void(*)(uObject*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnClear_fn;
    type->interface8.fp_OnNewAll = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::WhileCount__FuseReactiveIObserverOnNewAll_fn;
    type->interface7.fp_OnPlaybackDone = (void(*)(uObject*, uObject*))::g::Fuse::Triggers::Trigger__FuseAnimationsIBasePlayerFeedbackOnPlaybackDone_fn;
    type->interface7.fp_OnStable = (void(*)(uObject*, uObject*))::g::Fuse::Triggers::Trigger__FuseAnimationsIBasePlayerFeedbackOnStable_fn;
    type->interface6.fp_OnProgressUpdated = (void(*)(uObject*, uObject*, double*, double*, int32_t*))::g::Fuse::Triggers::Trigger__FuseAnimationsIUnwrappedPlayerFeedbackOnProgressUpdated_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public WhileNotEmpty() :59
void WhileNotEmpty__ctor_7_fn(WhileNotEmpty* __this)
{
    __this->ctor_7();
}

// public WhileNotEmpty New() :59
void WhileNotEmpty__New3_fn(WhileNotEmpty** __retval)
{
    *__retval = WhileNotEmpty::New3();
}

// public WhileNotEmpty() [instance] :59
void WhileNotEmpty::ctor_7()
{
    uStackFrame __("Fuse.Reactive.WhileNotEmpty", ".ctor()");
    ctor_6();
    GreaterThan(0);
}

// public WhileNotEmpty New() [static] :59
WhileNotEmpty* WhileNotEmpty::New3()
{
    WhileNotEmpty* obj1 = (WhileNotEmpty*)uNew(WhileNotEmpty_typeof());
    obj1->ctor_7();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Controls.Panels\1.8.1\Window.uno
// -----------------------------------------------------------------------------------------

// internal sealed class WindowCaps :83
// {
// static generated WindowCaps() :83
static void WindowCaps__cctor__fn(uType* __type)
{
    WindowCaps::NameWidth_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[156/*"width"*/]);
    WindowCaps::NameHeight_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[157/*"height"*/]);
    WindowCaps::NameSize_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[148/*"size"*/]);
    WindowCaps::NamePixelsPerPoint_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[158/*"pixelsPerPo...*/]);
    WindowCaps::NamePixelsPerOSPoint_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[159/*"pixelsPerOS...*/]);
    WindowCaps::NameSafeMargins_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[160/*"safeMargins"*/]);
    WindowCaps::NameDeviceMargins_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[161/*"deviceMargins"*/]);
    WindowCaps::NameStaticMargins_ = ::g::Uno::UX::Selector__op_Implicit(::STRINGS[162/*"staticMargins"*/]);
}

static void WindowCaps_build(uType* type)
{
    ::STRINGS[156] = uString::Const("width");
    ::STRINGS[157] = uString::Const("height");
    ::STRINGS[148] = uString::Const("size");
    ::STRINGS[158] = uString::Const("pixelsPerPoint");
    ::STRINGS[159] = uString::Const("pixelsPerOSPoint");
    ::STRINGS[160] = uString::Const("safeMargins");
    ::STRINGS[161] = uString::Const("deviceMargins");
    ::STRINGS[162] = uString::Const("staticMargins");
    ::STRINGS[163] = uString::Const("No RootViewport found");
    ::TYPES[68] = ::g::Uno::Action1_typeof()->MakeType(::g::Uno::Float2_typeof(), NULL);
    ::TYPES[37] = ::g::Uno::Action_typeof();
    ::TYPES[69] = ::g::Fuse::Node_typeof()->MakeMethod(2/*GetNearestAncestorOfType<Fuse.RootViewport>*/, ::g::Fuse::RootViewport_typeof(), NULL);
    type->SetDependencies(
        ::g::Fuse::Platform::SystemUI_typeof(),
        ::g::Fuse::UpdateManager_typeof());
    type->SetInterfaces(
        ::g::Fuse::Reactive::IObservableObject_typeof(), offsetof(::g::Fuse::Reactive::CapsObject_type, interface0),
        ::g::Uno::UX::IPropertyListener_typeof(), offsetof(::g::Fuse::Reactive::CapsObject_type, interface1),
        ::g::Fuse::IObject_typeof(), offsetof(::g::Fuse::Reactive::CapsObject_type, interface2));
    type->SetFields(3,
        ::g::Fuse::RootViewport_typeof(), offsetof(WindowCaps, _rootViewport), 0,
        ::g::Uno::Int_typeof(), offsetof(WindowCaps, _attachCount), 0,
        type, (uintptr_t)&WindowCaps::_singleton_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&WindowCaps::NameWidth_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&WindowCaps::NameHeight_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&WindowCaps::NameSize_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&WindowCaps::NamePixelsPerPoint_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&WindowCaps::NamePixelsPerOSPoint_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&WindowCaps::NameSafeMargins_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&WindowCaps::NameDeviceMargins_, uFieldFlagsStatic,
        ::g::Uno::UX::Selector_typeof(), (uintptr_t)&WindowCaps::NameStaticMargins_, uFieldFlagsStatic);
}

::g::Fuse::Reactive::CapsObject_type* WindowCaps_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::CapsObject_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::CapsObject_typeof();
    options.FieldCount = 14;
    options.InterfaceCount = 3;
    options.DependencyCount = 2;
    options.ObjectSize = sizeof(WindowCaps);
    options.TypeSize = sizeof(::g::Fuse::Reactive::CapsObject_type);
    type = (::g::Fuse::Reactive::CapsObject_type*)uClassType::New("Fuse.Reactive.WindowCaps", options);
    type->fp_build_ = WindowCaps_build;
    type->fp_cctor_ = WindowCaps__cctor__fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject**))::g::Fuse::Reactive::CapsObject__FuseReactiveIObservableObjectSubscribe_fn;
    type->interface1.fp_OnPropertyChanged = (void(*)(uObject*, ::g::Uno::UX::PropertyObject*, ::g::Uno::UX::Selector*))::g::Fuse::Reactive::CapsObject__UnoUXIPropertyListenerOnPropertyChanged_fn;
    type->interface2.fp_ContainsKey = (void(*)(uObject*, uString*, bool*))::g::Fuse::Reactive::CapsObject__ContainsKey_fn;
    type->interface2.fp_get_Item = (void(*)(uObject*, uString*, uObject**))::g::Fuse::Reactive::CapsObject__get_Item_fn;
    type->interface2.fp_get_Keys = (void(*)(uObject*, uArray**))::g::Fuse::Reactive::CapsObject__get_Keys_fn;
    return type;
}

// private WindowCaps(Fuse.RootViewport rv) :132
void WindowCaps__ctor_2_fn(WindowCaps* __this, ::g::Fuse::RootViewport* rv)
{
    __this->ctor_2(rv);
}

// public static Fuse.Reactive.WindowCaps Attach(Fuse.RootViewport target) :90
void WindowCaps__Attach_fn(::g::Fuse::RootViewport* target, WindowCaps** __retval)
{
    *__retval = WindowCaps::Attach(target);
}

// public static Fuse.Reactive.WindowCaps AttachFrom(Fuse.Node node) :103
void WindowCaps__AttachFrom_fn(::g::Fuse::Node* node, WindowCaps** __retval)
{
    *__retval = WindowCaps::AttachFrom(node);
}

// public void Detach() :112
void WindowCaps__Detach_fn(WindowCaps* __this)
{
    __this->Detach();
}

// private WindowCaps New(Fuse.RootViewport rv) :132
void WindowCaps__New3_fn(::g::Fuse::RootViewport* rv, WindowCaps** __retval)
{
    *__retval = WindowCaps::New3(rv);
}

// private void OnMarginsChanged() :159
void WindowCaps__OnMarginsChanged_fn(WindowCaps* __this)
{
    __this->OnMarginsChanged();
}

// private void OnResized() :151
void WindowCaps__OnResized_fn(WindowCaps* __this)
{
    __this->OnResized();
}

// private void OnResizedRV(float2 ignore) :150
void WindowCaps__OnResizedRV_fn(WindowCaps* __this, ::g::Uno::Float2* ignore)
{
    __this->OnResizedRV(*ignore);
}

// private void Unroot() :145
void WindowCaps__Unroot_fn(WindowCaps* __this)
{
    __this->Unroot();
}

// private void UpdateMargins() :164
void WindowCaps__UpdateMargins_fn(WindowCaps* __this)
{
    __this->UpdateMargins();
}

uSStrong<WindowCaps*> WindowCaps::_singleton_;
::g::Uno::UX::Selector WindowCaps::NameWidth_;
::g::Uno::UX::Selector WindowCaps::NameHeight_;
::g::Uno::UX::Selector WindowCaps::NameSize_;
::g::Uno::UX::Selector WindowCaps::NamePixelsPerPoint_;
::g::Uno::UX::Selector WindowCaps::NamePixelsPerOSPoint_;
::g::Uno::UX::Selector WindowCaps::NameSafeMargins_;
::g::Uno::UX::Selector WindowCaps::NameDeviceMargins_;
::g::Uno::UX::Selector WindowCaps::NameStaticMargins_;

// private WindowCaps(Fuse.RootViewport rv) [instance] :132
void WindowCaps::ctor_2(::g::Fuse::RootViewport* rv)
{
    uStackFrame __("Fuse.Reactive.WindowCaps", ".ctor(Fuse.RootViewport)");
    ctor_1();
    _rootViewport = rv;
    uPtr(_rootViewport)->add_Resized(uDelegate::New(::TYPES[68/*Uno.Action<float2>*/], (void*)WindowCaps__OnResizedRV_fn, this));
    OnResized();
    ::g::Fuse::Platform::SystemUI::add_MarginsChanged(uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)WindowCaps__OnMarginsChanged_fn, this));
    UpdateMargins();
    ChangeProperty(WindowCaps::NamePixelsPerPoint_, uBox(::TYPES[21/*float*/], uPtr(_rootViewport)->PixelsPerPoint()));
    ChangeProperty(WindowCaps::NamePixelsPerOSPoint_, uBox(::TYPES[21/*float*/], uPtr(_rootViewport)->PixelsPerOSPoint()));
}

// public void Detach() [instance] :112
void WindowCaps::Detach()
{
    if ((--_attachCount) == 0)
    {
        Unroot();
        WindowCaps::_singleton_ = NULL;
    }
}

// private void OnMarginsChanged() [instance] :159
void WindowCaps::OnMarginsChanged()
{
    uStackFrame __("Fuse.Reactive.WindowCaps", "OnMarginsChanged()");
    ::g::Fuse::UpdateManager::AddDeferredAction2(uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)WindowCaps__UpdateMargins_fn, this), -1, 2);
}

// private void OnResized() [instance] :151
void WindowCaps::OnResized()
{
    uStackFrame __("Fuse.Reactive.WindowCaps", "OnResized()");
    ChangeProperty(WindowCaps::NameWidth_, uBox(::TYPES[21/*float*/], uPtr(_rootViewport)->Size().X));
    ChangeProperty(WindowCaps::NameHeight_, uBox(::TYPES[21/*float*/], uPtr(_rootViewport)->Size().Y));
    ChangeProperty(WindowCaps::NameSize_, uBox(::g::Uno::Float2_typeof(), uPtr(_rootViewport)->Size()));
    ::g::Fuse::UpdateManager::AddDeferredAction2(uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)WindowCaps__UpdateMargins_fn, this), -1, 2);
}

// private void OnResizedRV(float2 ignore) [instance] :150
void WindowCaps::OnResizedRV(::g::Uno::Float2 ignore)
{
    uStackFrame __("Fuse.Reactive.WindowCaps", "OnResizedRV(float2)");
    OnResized();
}

// private void Unroot() [instance] :145
void WindowCaps::Unroot()
{
    uStackFrame __("Fuse.Reactive.WindowCaps", "Unroot()");
    ::g::Fuse::Platform::SystemUI::remove_MarginsChanged(uDelegate::New(::TYPES[37/*Uno.Action*/], (void*)WindowCaps__OnMarginsChanged_fn, this));
}

// private void UpdateMargins() [instance] :164
void WindowCaps::UpdateMargins()
{
    uStackFrame __("Fuse.Reactive.WindowCaps", "UpdateMargins()");
    float osToFuse = uPtr(_rootViewport)->PixelsPerOSPoint() / uPtr(_rootViewport)->PixelsPerPoint();
    ChangeProperty(WindowCaps::NameDeviceMargins_, uBox(::g::Uno::Float4_typeof(), ::g::Uno::Float4__op_Multiply1(::g::Fuse::Platform::SystemUI::DeviceMargins(), osToFuse)));
    ChangeProperty(WindowCaps::NameSafeMargins_, uBox(::g::Uno::Float4_typeof(), ::g::Uno::Float4__op_Multiply1(::g::Fuse::Platform::SystemUI::SafeMargins(), osToFuse)));
    ChangeProperty(WindowCaps::NameStaticMargins_, uBox(::g::Uno::Float4_typeof(), ::g::Uno::Float4__op_Multiply1(::g::Fuse::Platform::SystemUI::StaticMargins(), osToFuse)));
}

// public static Fuse.Reactive.WindowCaps Attach(Fuse.RootViewport target) [static] :90
WindowCaps* WindowCaps::Attach(::g::Fuse::RootViewport* target)
{
    uStackFrame __("Fuse.Reactive.WindowCaps", "Attach(Fuse.RootViewport)");
    WindowCaps_typeof()->Init();
    WindowCaps* rv = WindowCaps::_singleton_;

    if (rv == NULL)
    {
        rv = WindowCaps::New3(target);
        WindowCaps::_singleton_ = rv;
    }

    uPtr(rv)->_attachCount++;
    return rv;
}

// public static Fuse.Reactive.WindowCaps AttachFrom(Fuse.Node node) [static] :103
WindowCaps* WindowCaps::AttachFrom(::g::Fuse::Node* node)
{
    uStackFrame __("Fuse.Reactive.WindowCaps", "AttachFrom(Fuse.Node)");
    WindowCaps_typeof()->Init();
    ::g::Fuse::RootViewport* rv = (::g::Fuse::RootViewport*)uPtr(node)->GetNearestAncestorOfType(::TYPES[69/*Fuse.Node.GetNearestAncestorOfType<Fuse.RootViewport>*/]);

    if (rv == NULL)
        U_THROW(::g::Uno::Exception::New2(::STRINGS[163/*"No RootView...*/]));

    return WindowCaps::Attach(rv);
}

// private WindowCaps New(Fuse.RootViewport rv) [static] :132
WindowCaps* WindowCaps::New3(::g::Fuse::RootViewport* rv)
{
    WindowCaps* obj1 = (WindowCaps*)uNew(WindowCaps_typeof());
    obj1->ctor_2(rv);
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Controls.Panels\1.8.1\Window.uno
// -----------------------------------------------------------------------------------------

// public sealed class WindowFunction :25
// {
static void WindowFunction_build(uType* type)
{
    type->SetInterfaces(
        ::g::Fuse::Reactive::IExpression_typeof(), offsetof(::g::Fuse::Reactive::Expression_type, interface0));
    type->Reflection.SetFunctions(1,
        new uFunction(".ctor", NULL, (void*)WindowFunction__New1_fn, 0, true, type, 0));
}

::g::Fuse::Reactive::Expression_type* WindowFunction_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::Expression_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::Expression_typeof();
    options.InterfaceCount = 1;
    options.ObjectSize = sizeof(WindowFunction);
    options.TypeSize = sizeof(::g::Fuse::Reactive::Expression_type);
    type = (::g::Fuse::Reactive::Expression_type*)uClassType::New("Fuse.Reactive.WindowFunction", options);
    type->fp_build_ = WindowFunction_build;
    type->fp_ctor_ = (void*)WindowFunction__New1_fn;
    type->fp_Subscribe = (void(*)(::g::Fuse::Reactive::Expression*, uObject*, uObject*, uObject**))WindowFunction__Subscribe_fn;
    type->fp_ToString = (void(*)(uObject*, uString**))WindowFunction__ToString_fn;
    type->interface0.fp_Subscribe = (void(*)(uObject*, uObject*, uObject*, uObject**))WindowFunction__Subscribe_fn;
    return type;
}

// public WindowFunction() :28
void WindowFunction__ctor_1_fn(WindowFunction* __this)
{
    __this->ctor_1();
}

// public WindowFunction New() :28
void WindowFunction__New1_fn(WindowFunction** __retval)
{
    *__retval = WindowFunction::New1();
}

// public override sealed Uno.IDisposable Subscribe(Fuse.Reactive.IContext context, Fuse.Reactive.IListener listener) :35
void WindowFunction__Subscribe_fn(WindowFunction* __this, uObject* context, uObject* listener, uObject** __retval)
{
    uStackFrame __("Fuse.Reactive.WindowFunction", "Subscribe(Fuse.Reactive.IContext,Fuse.Reactive.IListener)");
    ::g::Fuse::RootViewport* rv = (::g::Fuse::RootViewport*)uPtr(::g::Fuse::Reactive::IContext::Node(uInterface(uPtr(context), ::TYPES[27/*Fuse.Reactive.IContext*/])))->GetNearestAncestorOfType(::TYPES[69/*Fuse.Node.GetNearestAncestorOfType<Fuse.RootViewport>*/]);
    WindowFunction__Subscription* sub = WindowFunction__Subscription::New1(__this, rv, listener);
    sub->Init();
    return *__retval = (uObject*)sub, void();
}

// public override sealed string ToString() :30
void WindowFunction__ToString_fn(WindowFunction* __this, uString** __retval)
{
    return *__retval = uString::Const("window()"), void();
}

// public WindowFunction() [instance] :28
void WindowFunction::ctor_1()
{
    ctor_();
}

// public WindowFunction New() [static] :28
WindowFunction* WindowFunction::New1()
{
    WindowFunction* obj1 = (WindowFunction*)uNew(WindowFunction_typeof());
    obj1->ctor_1();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\Instantiator.uno
// -------------------------------------------------------------------------------------------------

// internal sealed class WindowItem :73
// {
static void WindowItem_build(uType* type)
{
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(::g::Fuse::Reactive::ValueObserver_type, interface0),
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(::g::Fuse::Reactive::ValueObserver_type, interface1));
    type->SetFields(6,
        ::g::Uno::Collections::List_typeof()->MakeType(::g::Fuse::Node_typeof(), NULL), offsetof(WindowItem, Nodes), 0,
        ::g::Fuse::Reactive::TemplateMatch_typeof(), offsetof(WindowItem, Template), 0);
}

::g::Fuse::Reactive::ValueObserver_type* WindowItem_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::ValueObserver_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::WindowListItem_typeof();
    options.FieldCount = 8;
    options.InterfaceCount = 2;
    options.ObjectSize = sizeof(WindowItem);
    options.TypeSize = sizeof(::g::Fuse::Reactive::ValueObserver_type);
    type = (::g::Fuse::Reactive::ValueObserver_type*)uClassType::New("Fuse.Reactive.WindowItem", options);
    type->fp_build_ = WindowItem_build;
    type->fp_ctor_ = (void*)WindowItem__New1_fn;
    type->interface1.fp_OnClear = (void(*)(uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnClear_fn;
    type->interface1.fp_OnSet = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnSet_fn;
    type->interface1.fp_OnAdd = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnAdd_fn;
    type->interface1.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnNewAt_fn;
    type->interface1.fp_OnFailed = (void(*)(uObject*, uString*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnFailed_fn;
    type->interface1.fp_OnNewAll = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnNewAll_fn;
    type->interface1.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface1.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnInsertAt_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))::g::Fuse::Reactive::WindowListItem__Dispose_fn;
    return type;
}

// public generated WindowItem() :73
void WindowItem__ctor_2_fn(WindowItem* __this)
{
    __this->ctor_2();
}

// public generated WindowItem New() :73
void WindowItem__New1_fn(WindowItem** __retval)
{
    *__retval = WindowItem::New1();
}

// public generated WindowItem() [instance] :73
void WindowItem::ctor_2()
{
    ctor_1();
}

// public generated WindowItem New() [static] :73
WindowItem* WindowItem::New1()
{
    WindowItem* obj1 = (WindowItem*)uNew(WindowItem_typeof());
    obj1->ctor_2();
    return obj1;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\WindowList.uno
// -----------------------------------------------------------------------------------------------

// internal abstract class WindowList<T> :95
// {
static void WindowList_build(uType* type)
{
    ::STRINGS[164] = uString::Const("Item insertion order invalid");
    ::STRINGS[165] = uString::Const("C:\\Users\\borde_000\\AppData\\Local\\Fusetools\\Packages\\Fuse.Reactive.Bindings\\1.8.1\\WindowList.uno");
    ::STRINGS[166] = uString::Const("InsertedDataAt");
    ::STRINGS[35] = uString::Const("error");
    ::STRINGS[167] = uString::Const("Limit cannot be less than 0");
    ::STRINGS[168] = uString::Const("set_Limit");
    ::STRINGS[169] = uString::Const("Offset cannot be less than 0");
    ::STRINGS[170] = uString::Const("set_Offset");
    ::TYPES[70] = ::g::Fuse::Internal::ObjectList_typeof();
    type->SetPrecalc(
        ::g::Fuse::Internal::ObjectList_typeof()->MakeType(type->T(0), NULL));
    type->SetFields(0,
        ::g::Uno::Int_typeof(), offsetof(WindowList, _offset), 0,
        ::g::Uno::Int_typeof(), offsetof(WindowList, _limit), 0,
        ::g::Uno::Bool_typeof(), offsetof(WindowList, _hasLimit), 0,
        ::TYPES[70/*Fuse.Internal.ObjectList`1*/]->MakeType(type->T(0), NULL), offsetof(WindowList, _windowItems), 0,
        ::g::Uno::String_typeof(), offsetof(WindowList, _errorMessage), 0);
}

WindowList_type* WindowList_typeof()
{
    static uSStrong<WindowList_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.FieldCount = 5;
    options.GenericCount = 1;
    options.PrecalcCount = 1;
    options.ObjectSize = sizeof(WindowList);
    options.TypeSize = sizeof(WindowList_type);
    type = (WindowList_type*)uClassType::New("Fuse.Reactive.WindowList`1", options);
    type->fp_build_ = WindowList_build;
    return type;
}

// protected generated WindowList() :95
void WindowList__ctor__fn(WindowList* __this)
{
    __this->ctor_();
}

// protected int CalcOffsetLimitCountOf(int length) :162
void WindowList__CalcOffsetLimitCountOf_fn(WindowList* __this, int32_t* length, int32_t* __retval)
{
    *__retval = __this->CalcOffsetLimitCountOf(*length);
}

// private void ClearError() :197
void WindowList__ClearError_fn(WindowList* __this)
{
    __this->ClearError();
}

// protected int DataToWindowIndex(int dataIndex) :224
void WindowList__DataToWindowIndex_fn(WindowList* __this, int32_t* dataIndex, int32_t* __retval)
{
    *__retval = __this->DataToWindowIndex(*dataIndex);
}

// protected string get_ErrorMessage() :188
void WindowList__get_ErrorMessage_fn(WindowList* __this, uString** __retval)
{
    *__retval = __this->ErrorMessage();
}

// private void set_ErrorMessage(string value) :189
void WindowList__set_ErrorMessage_fn(WindowList* __this, uString* value)
{
    __this->ErrorMessage(value);
}

// public T GetWindowItem(int i) :172
void WindowList__GetWindowItem_fn(WindowList* __this, int32_t* i, uObject** __retval)
{
    *__retval = __this->GetWindowItem(*i);
}

// public int GetWindowItemIndex(T item) :174
void WindowList__GetWindowItemIndex_fn(WindowList* __this, uObject* item, int32_t* __retval)
{
    *__retval = __this->GetWindowItemIndex(item);
}

// internal bool get_HasLimit() :160
void WindowList__get_HasLimit_fn(WindowList* __this, bool* __retval)
{
    *__retval = __this->HasLimit();
}

// protected void InsertedDataAt(int dataIndex) :234
void WindowList__InsertedDataAt_fn(WindowList* __this, int32_t* dataIndex)
{
    __this->InsertedDataAt(*dataIndex);
}

// protected void InsertWindowItem(int windowIndex, int dataIndex) :252
void WindowList__InsertWindowItem_fn(WindowList* __this, int32_t* windowIndex, int32_t* dataIndex)
{
    __this->InsertWindowItem(*windowIndex, *dataIndex);
}

// internal int get_Limit() :142
void WindowList__get_Limit_fn(WindowList* __this, int32_t* __retval)
{
    *__retval = __this->Limit();
}

// internal void set_Limit(int value) :143
void WindowList__set_Limit_fn(WindowList* __this, int32_t* value)
{
    __this->Limit(*value);
}

// internal int get_Offset() :100
void WindowList__get_Offset_fn(WindowList* __this, int32_t* __retval)
{
    *__retval = __this->Offset();
}

// internal void set_Offset(int value) :101
void WindowList__set_Offset_fn(WindowList* __this, int32_t* value)
{
    __this->Offset(*value);
}

// protected void RemoveAll() :212
void WindowList__RemoveAll_fn(WindowList* __this)
{
    __this->RemoveAll();
}

// protected void RemovedDataAt(int dataIndex) :200
void WindowList__RemovedDataAt_fn(WindowList* __this, int32_t* dataIndex)
{
    __this->RemovedDataAt(*dataIndex);
}

// protected void SetError(string msg) :198
void WindowList__SetError_fn(WindowList* __this, uString* msg)
{
    __this->SetError(msg);
}

// protected void TrimAndPad() :262
void WindowList__TrimAndPad_fn(WindowList* __this)
{
    __this->TrimAndPad();
}

// public int get_WindowItemCount() :171
void WindowList__get_WindowItemCount_fn(WindowList* __this, int32_t* __retval)
{
    *__retval = __this->WindowItemCount();
}

// protected generated WindowList() [instance] :95
void WindowList::ctor_()
{
    uType* __types[] = {
        __type->GetBase(WindowList_typeof())->Precalced(0/*Fuse.Internal.ObjectList<T>*/),
    };
    uStackFrame __("Fuse.Reactive.WindowList`1", ".ctor()");
    _windowItems = ((::g::Fuse::Internal::ObjectList*)::g::Fuse::Internal::ObjectList::New1(__types[0], 0));
}

// protected int CalcOffsetLimitCountOf(int length) [instance] :162
int32_t WindowList::CalcOffsetLimitCountOf(int32_t length)
{
    int32_t q = ::g::Uno::Math::Max8(0, length - Offset());
    return HasLimit() ? ::g::Uno::Math::Min8(Limit(), q) : q;
}

// private void ClearError() [instance] :197
void WindowList::ClearError()
{
    uStackFrame __("Fuse.Reactive.WindowList`1", "ClearError()");
    ErrorMessage(NULL);
}

// protected int DataToWindowIndex(int dataIndex) [instance] :224
int32_t WindowList::DataToWindowIndex(int32_t dataIndex)
{
    return dataIndex - Offset();
}

// protected string get_ErrorMessage() [instance] :188
uString* WindowList::ErrorMessage()
{
    return _errorMessage;
}

// private void set_ErrorMessage(string value) [instance] :189
void WindowList::ErrorMessage(uString* value)
{
    uStackFrame __("Fuse.Reactive.WindowList`1", "set_ErrorMessage(string)");

    if (::g::Uno::String::op_Equality(_errorMessage, value))
        return;

    _errorMessage = value;
    OnErrorMessageChanged(_errorMessage);
}

// public T GetWindowItem(int i) [instance] :172
uObject* WindowList::GetWindowItem(int32_t i)
{
    uStackFrame __("Fuse.Reactive.WindowList`1", "GetWindowItem(int)");
    return (uObject*)uPtr(_windowItems)->Item(i);
}

// public int GetWindowItemIndex(T item) [instance] :174
int32_t WindowList::GetWindowItemIndex(uObject* item)
{
    uStackFrame __("Fuse.Reactive.WindowList`1", "GetWindowItemIndex(T)");

    for (int32_t i = 0; i < uPtr(_windowItems)->Count(); ++i)
        if (item == ((uObject*)uPtr(_windowItems)->Item(i)))
            return i;

    return -1;
}

// internal bool get_HasLimit() [instance] :160
bool WindowList::HasLimit()
{
    return _hasLimit;
}

// protected void InsertedDataAt(int dataIndex) [instance] :234
void WindowList::InsertedDataAt(int32_t dataIndex)
{
    uStackFrame __("Fuse.Reactive.WindowList`1", "InsertedDataAt(int)");

    if ((dataIndex < Offset()) || (HasLimit() && ((dataIndex - Offset()) >= Limit())))
        return;

    int32_t windowIndex = DataToWindowIndex(dataIndex);

    if ((windowIndex > uPtr(_windowItems)->Count()) || (windowIndex < 0))
    {
        ::g::Fuse::Diagnostics::InternalError(::STRINGS[164/*"Item insert...*/], this, ::STRINGS[165/*"C:\\Users\\...*/], 245, ::STRINGS[166/*"InsertedDat...*/]);
        return;
    }

    InsertWindowItem(windowIndex, dataIndex);
}

// protected void InsertWindowItem(int windowIndex, int dataIndex) [instance] :252
void WindowList::InsertWindowItem(int32_t windowIndex, int32_t dataIndex)
{
    uStackFrame __("Fuse.Reactive.WindowList`1", "InsertWindowItem(int,int)");
    uObject* wi = CreateWindowItem(dataIndex);
    uPtr(_windowItems)->Insert(windowIndex, wi);
    OnAddedWindowItem(windowIndex, wi);
}

// internal int get_Limit() [instance] :142
int32_t WindowList::Limit()
{
    return _limit;
}

// internal void set_Limit(int value) [instance] :143
void WindowList::Limit(int32_t value)
{
    uStackFrame __("Fuse.Reactive.WindowList`1", "set_Limit(int)");

    if (_hasLimit && (_limit == value))
        return;

    if (value < 0)
    {
        ::g::Fuse::Diagnostics::UserError(::STRINGS[167/*"Limit canno...*/], this, ::STRINGS[165/*"C:\\Users\\...*/], 150, ::STRINGS[168/*"set_Limit"*/], NULL);
        value = 0;
    }

    _hasLimit = true;
    _limit = value;
    TrimAndPad();
}

// internal int get_Offset() [instance] :100
int32_t WindowList::Offset()
{
    return _offset;
}

// internal void set_Offset(int value) [instance] :101
void WindowList::Offset(int32_t value)
{
    uStackFrame __("Fuse.Reactive.WindowList`1", "set_Offset(int)");

    if (_offset == value)
        return;

    if (value < 0)
    {
        ::g::Fuse::Diagnostics::UserError(::STRINGS[169/*"Offset cann...*/], this, ::STRINGS[165/*"C:\\Users\\...*/], 108, ::STRINGS[170/*"set_Offset"*/], NULL);
        value = 0;
    }

    int32_t dataCount = GetDataCount();

    while (_offset < value)
    {
        if (_offset < dataCount)
            RemovedDataAt(_offset);

        _offset++;
        int32_t end = (_offset + Limit()) - 1;

        if (HasLimit() && (end < dataCount))
            InsertedDataAt(end);
    }

    while (_offset > value)
    {
        int32_t end1 = (_offset + Limit()) - 1;

        if (HasLimit() && (end1 < dataCount))
            RemovedDataAt((_offset + Limit()) - 1);

        _offset--;

        if (_offset < dataCount)
            InsertedDataAt(_offset);
    }
}

// protected void RemoveAll() [instance] :212
void WindowList::RemoveAll()
{
    uStackFrame __("Fuse.Reactive.WindowList`1", "RemoveAll()");

    for (int32_t i = 0; i < WindowItemCount(); ++i)
    {
        uObject* wi = GetWindowItem(i);
        OnRemovedWindowItem(wi);
    }

    uPtr(_windowItems)->Clear();
    ClearError();
}

// protected void RemovedDataAt(int dataIndex) [instance] :200
void WindowList::RemovedDataAt(int32_t dataIndex)
{
    uStackFrame __("Fuse.Reactive.WindowList`1", "RemovedDataAt(int)");
    int32_t windowIndex = DataToWindowIndex(dataIndex);

    if ((windowIndex >= 0) && (windowIndex < WindowItemCount()))
    {
        OnRemovedWindowItem(GetWindowItem(windowIndex));
        uPtr(_windowItems)->RemoveAt(windowIndex);
    }

    ClearError();
}

// protected void SetError(string msg) [instance] :198
void WindowList::SetError(uString* msg)
{
    uStackFrame __("Fuse.Reactive.WindowList`1", "SetError(string)");
    ErrorMessage((msg != NULL) ? msg : ::STRINGS[35/*"error"*/]);
}

// protected void TrimAndPad() [instance] :262
void WindowList::TrimAndPad()
{
    uStackFrame __("Fuse.Reactive.WindowList`1", "TrimAndPad()");

    if (HasLimit())

        for (int32_t i = WindowItemCount() - Limit(); i > 0; --i)
            RemovedDataAt((Offset() + WindowItemCount()) - 1);

    int32_t dataCount = GetDataCount();
    int32_t add = HasLimit() ? ::g::Uno::Math::Min8(Limit() - WindowItemCount(), dataCount - (Offset() + WindowItemCount())) : dataCount - (Offset() + WindowItemCount());

    for (int32_t i1 = 0; i1 < add; ++i1)
        InsertedDataAt(Offset() + WindowItemCount());

    ClearError();
}

// public int get_WindowItemCount() [instance] :171
int32_t WindowList::WindowItemCount()
{
    uStackFrame __("Fuse.Reactive.WindowList`1", "get_WindowItemCount()");
    return uPtr(_windowItems)->Count();
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\WindowList.uno
// -----------------------------------------------------------------------------------------------

// internal abstract class WindowListItem :10
// {
static void WindowListItem_build(uType* type)
{
    type->SetInterfaces(
        ::g::Uno::IDisposable_typeof(), offsetof(::g::Fuse::Reactive::ValueObserver_type, interface0),
        ::g::Fuse::Reactive::IObserver_typeof(), offsetof(::g::Fuse::Reactive::ValueObserver_type, interface1));
    type->SetFields(2,
        WindowListItem__IDataWatcher_typeof(), offsetof(WindowListItem, _owner), 0,
        uObject_typeof(), offsetof(WindowListItem, _curData), 0,
        uObject_typeof(), offsetof(WindowListItem, _data), 0,
        uObject_typeof(), offsetof(WindowListItem, _Id), 0);
}

::g::Fuse::Reactive::ValueObserver_type* WindowListItem_typeof()
{
    static uSStrong< ::g::Fuse::Reactive::ValueObserver_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Reactive::ValueObserver_typeof();
    options.FieldCount = 6;
    options.InterfaceCount = 2;
    options.MethodTypeCount = 1;
    options.ObjectSize = sizeof(WindowListItem);
    options.TypeSize = sizeof(::g::Fuse::Reactive::ValueObserver_type);
    type = (::g::Fuse::Reactive::ValueObserver_type*)uClassType::New("Fuse.Reactive.WindowListItem", options);
    type->MethodTypes[0] = type->NewMethodType(1, 0,0);
    type->fp_build_ = WindowListItem_build;
    type->fp_Dispose = (void(*)(::g::Fuse::Reactive::ValueObserver*))WindowListItem__Dispose_fn;
    type->fp_LostData = (void(*)(::g::Fuse::Reactive::ValueObserver*))WindowListItem__LostData_fn;
    type->fp_PushData = (void(*)(::g::Fuse::Reactive::ValueObserver*, uObject*))WindowListItem__PushData_fn;
    type->interface1.fp_OnClear = (void(*)(uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnClear_fn;
    type->interface1.fp_OnSet = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnSet_fn;
    type->interface1.fp_OnAdd = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnAdd_fn;
    type->interface1.fp_OnNewAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnNewAt_fn;
    type->interface1.fp_OnFailed = (void(*)(uObject*, uString*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnFailed_fn;
    type->interface1.fp_OnNewAll = (void(*)(uObject*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnNewAll_fn;
    type->interface1.fp_OnRemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnRemoveAt_fn;
    type->interface1.fp_OnInsertAt = (void(*)(uObject*, int32_t*, uObject*))::g::Fuse::Reactive::ValueObserver__FuseReactiveIObserverOnInsertAt_fn;
    type->interface0.fp_Dispose = (void(*)(uObject*))WindowListItem__Dispose_fn;
    return type;
}

// protected WindowListItem() :59
void WindowListItem__ctor_1_fn(WindowListItem* __this)
{
    __this->ctor_1();
}

// public static T Create<T>(Fuse.Reactive.WindowListItem.IDataWatcher owner, object id, object data) :61
void WindowListItem__Create_fn(uType* __type, uObject* owner, uObject* id, uObject* data, WindowListItem** __retval)
{
    *__retval = WindowListItem::Create(__type, owner, id, data);
}

// public object get_CurrentData() :72
void WindowListItem__get_CurrentData_fn(WindowListItem* __this, uObject** __retval)
{
    *__retval = __this->CurrentData();
}

// public object get_Data() :24
void WindowListItem__get_Data_fn(WindowListItem* __this, uObject** __retval)
{
    *__retval = __this->Data();
}

// public void set_Data(object value) :25
void WindowListItem__set_Data_fn(WindowListItem* __this, uObject* value)
{
    __this->Data(value);
}

// public override sealed void Dispose() :78
void WindowListItem__Dispose_fn(WindowListItem* __this)
{
    uStackFrame __("Fuse.Reactive.WindowListItem", "Dispose()");
    __this->_curData = NULL;
    __this->_data = NULL;
    __this->_owner = NULL;
    __this->Id(NULL);
    ::g::Fuse::Reactive::ValueObserver__Dispose_fn(__this);
}

// public generated object get_Id() :57
void WindowListItem__get_Id_fn(WindowListItem* __this, uObject** __retval)
{
    *__retval = __this->Id();
}

// private generated void set_Id(object value) :57
void WindowListItem__set_Id_fn(WindowListItem* __this, uObject* value)
{
    __this->Id(value);
}

// protected override sealed void LostData() :51
void WindowListItem__LostData_fn(WindowListItem* __this)
{
    uStackFrame __("Fuse.Reactive.WindowListItem", "LostData()");
    __this->PushData(NULL);
}

// protected override sealed void PushData(object newValue) :44
void WindowListItem__PushData_fn(WindowListItem* __this, uObject* newValue)
{
    uStackFrame __("Fuse.Reactive.WindowListItem", "PushData(object)");
    uObject* oldData = __this->CurrentData();
    __this->_curData = newValue;

    if (__this->_owner != NULL)
        WindowListItem__IDataWatcher::OnCurrentDataChanged(uInterface(uPtr(__this->_owner), WindowListItem__IDataWatcher_typeof()), __this, oldData);
}

// protected WindowListItem() [instance] :59
void WindowListItem::ctor_1()
{
    ctor_();
}

// public object get_CurrentData() [instance] :72
uObject* WindowListItem::CurrentData()
{
    return _curData;
}

// public object get_Data() [instance] :24
uObject* WindowListItem::Data()
{
    return _data;
}

// public void set_Data(object value) [instance] :25
void WindowListItem::Data(uObject* value)
{
    uStackFrame __("Fuse.Reactive.WindowListItem", "set_Data(object)");
    uObject* oldData = CurrentData();
    Unsubscribe();
    _data = value;
    _curData = _data;
    uObject* obs = uAs<uObject*>(_data, ::TYPES[46/*Fuse.Reactive.IObservable*/]);

    if (obs != NULL)
    {
        SubscribeNoPush(obs);
        _curData = Value();
    }

    if (_owner != NULL)
        WindowListItem__IDataWatcher::OnCurrentDataChanged(uInterface(uPtr(_owner), WindowListItem__IDataWatcher_typeof()), this, oldData);
}

// public generated object get_Id() [instance] :57
uObject* WindowListItem::Id()
{
    return _Id;
}

// private generated void set_Id(object value) [instance] :57
void WindowListItem::Id(uObject* value)
{
    _Id = value;
}

// public static T Create<T>(Fuse.Reactive.WindowListItem.IDataWatcher owner, object id, object data) [static] :61
WindowListItem* WindowListItem::Create(uType* __type, uObject* owner, uObject* id, uObject* data)
{
    uStackFrame __("Fuse.Reactive.WindowListItem", "Create`1(Fuse.Reactive.WindowListItem.IDataWatcher,object,object)");
    WindowListItem* lwi = (WindowListItem*)__type->U(0)->New();
    lwi->Data(data);
    lwi->Id(id);
    lwi->_owner = owner;
    return lwi;
}
// }

// C:\Users\borde_000\AppData\Local\Fusetools\Packages\Fuse.Reactive.Bindings\1.8.1\With.uno
// -----------------------------------------------------------------------------------------

// public class With :28
// {
static void With_build(uType* type)
{
    ::TYPES[3] = ::g::Uno::IDisposable_typeof();
    ::TYPES[46] = ::g::Fuse::Reactive::IObservable_typeof();
    type->SetInterfaces(
        ::g::Uno::Collections::IList_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(With_type, interface0),
        ::g::Fuse::Scripting::IScriptObject_typeof(), offsetof(With_type, interface1),
        ::g::Fuse::IProperties_typeof(), offsetof(With_type, interface2),
        ::g::Fuse::INotifyUnrooted_typeof(), offsetof(With_type, interface3),
        ::g::Uno::Collections::ICollection_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(With_type, interface4),
        ::g::Uno::Collections::IEnumerable_typeof()->MakeType(::g::Fuse::Binding_typeof(), NULL), offsetof(With_type, interface5),
        ::g::Fuse::Animations::IUnwrappedPlayerFeedback_typeof(), offsetof(With_type, interface6),
        ::g::Fuse::Animations::IBasePlayerFeedback_typeof(), offsetof(With_type, interface7),
        ::g::Fuse::Node__ISubtreeDataProvider_typeof(), offsetof(With_type, interface8),
        ::g::Fuse::Reactive::ValueForwarder__IValueListener_typeof(), offsetof(With_type, interface9));
    type->SetFields(37,
        ::TYPES[3/*Uno.IDisposable*/], offsetof(With, _sub), 0,
        uObject_typeof(), offsetof(With, _sourceData), 0,
        uObject_typeof(), offsetof(With, _subtreeData), 0);
    type->Reflection.SetFunctions(3,
        new uFunction("get_Data", NULL, (void*)With__get_Data_fn, 0, false, uObject_typeof(), 0),
        new uFunction("set_Data", NULL, (void*)With__set_Data_fn, 0, false, uVoid_typeof(), 1, uObject_typeof()),
        new uFunction(".ctor", NULL, (void*)With__New2_fn, 0, true, type, 0));
}

With_type* With_typeof()
{
    static uSStrong<With_type*> type;
    if (type != NULL) return type;

    uTypeOptions options;
    options.BaseDefinition = ::g::Fuse::Triggers::Trigger_typeof();
    options.FieldCount = 40;
    options.InterfaceCount = 10;
    options.ObjectSize = sizeof(With);
    options.TypeSize = sizeof(With_type);
    type = (With_type*)uClassType::New("Fuse.Reactive.With", options);
    type->fp_build_ = With_build;
    type->fp_ctor_ = (void*)With__New2_fn;
    type->fp_OnRooted = (void(*)(::g::Fuse::Node*))With__OnRooted_fn;
    type->interface8.fp_TryGetDataProvider = (void(*)(uObject*, ::g::Fuse::Node*, int32_t*, uObject**, int32_t*))With__FuseNodeISubtreeDataProviderTryGetDataProvider_fn;
    type->interface9.fp_NewValue = (void(*)(uObject*, uObject*))With__FuseReactiveValueForwarderIValueListenerNewValue_fn;
    type->interface9.fp_LostValue = (void(*)(uObject*))With__FuseReactiveValueForwarderIValueListenerLostValue_fn;
    type->interface7.fp_OnPlaybackDone = (void(*)(uObject*, uObject*))::g::Fuse::Triggers::Trigger__FuseAnimationsIBasePlayerFeedbackOnPlaybackDone_fn;
    type->interface7.fp_OnStable = (void(*)(uObject*, uObject*))::g::Fuse::Triggers::Trigger__FuseAnimationsIBasePlayerFeedbackOnStable_fn;
    type->interface6.fp_OnProgressUpdated = (void(*)(uObject*, uObject*, double*, double*, int32_t*))::g::Fuse::Triggers::Trigger__FuseAnimationsIUnwrappedPlayerFeedbackOnProgressUpdated_fn;
    type->interface4.fp_Clear = (void(*)(uObject*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingClear_fn;
    type->interface4.fp_Contains = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingContains_fn;
    type->interface0.fp_RemoveAt = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsIListFuseBindingRemoveAt_fn;
    type->interface5.fp_GetEnumerator = (void(*)(uObject*, uObject**))::g::Fuse::Node__UnoCollectionsIEnumerableFuseBindingGetEnumerator_fn;
    type->interface1.fp_SetScriptObject = (void(*)(uObject*, uObject*, ::g::Fuse::Scripting::Context*))::g::Fuse::Node__FuseScriptingIScriptObjectSetScriptObject_fn;
    type->interface4.fp_get_Count = (void(*)(uObject*, int32_t*))::g::Fuse::Node__UnoCollectionsICollectionFuseBindingget_Count_fn;
    type->interface0.fp_get_Item = (void(*)(uObject*, int32_t*, uTRef))::g::Fuse::Node__UnoCollectionsIListFuseBindingget_Item_fn;
    type->interface1.fp_get_ScriptObject = (void(*)(uObject*, uObject**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptObject_fn;
    type->interface1.fp_get_ScriptContext = (void(*)(uObject*, ::g::Fuse::Scripting::Context**))::g::Fuse::Node__FuseScriptingIScriptObjectget_ScriptContext_fn;
    type->interface3.fp_add_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedadd_Unrooted_fn;
    type->interface3.fp_remove_Unrooted = (void(*)(uObject*, uDelegate*))::g::Fuse::Node__FuseINotifyUnrootedremove_Unrooted_fn;
    type->interface0.fp_Insert = (void(*)(uObject*, int32_t*, void*))::g::Fuse::Node__Insert_fn;
    type->interface2.fp_get_Properties = (void(*)(uObject*, ::g::Fuse::Properties**))::g::Fuse::Node__get_Properties_fn;
    type->interface4.fp_Add = (void(*)(uObject*, void*))::g::Fuse::Node__Add_fn;
    type->interface4.fp_Remove = (void(*)(uObject*, void*, bool*))::g::Fuse::Node__Remove_fn;
    return type;
}

// public generated With() :28
void With__ctor_5_fn(With* __this)
{
    __this->ctor_5();
}

// public object get_Data() :46
void With__get_Data_fn(With* __this, uObject** __retval)
{
    *__retval = __this->Data();
}

// public void set_Data(object value) :47
void With__set_Data_fn(With* __this, uObject* value)
{
    __this->Data(value);
}

// private Fuse.Node.ContextDataResult Fuse.Node.ISubtreeDataProvider.TryGetDataProvider(Fuse.Node child, Fuse.Node.DataType type, object& provider) :71
void With__FuseNodeISubtreeDataProviderTryGetDataProvider_fn(With* __this, ::g::Fuse::Node* child, int32_t* type, uObject** provider, int32_t* __retval)
{
    int32_t type_ = *type;
    *provider = __this->_subtreeData;
    return *__retval = (type_ == 1) ? 2 : 0, void();
}

// private void Fuse.Reactive.ValueForwarder.IValueListener.LostValue() :82
void With__FuseReactiveValueForwarderIValueListenerLostValue_fn(With* __this)
{
    __this->SetSubtreeData(NULL);
}

// private void Fuse.Reactive.ValueForwarder.IValueListener.NewValue(object value) :77
void With__FuseReactiveValueForwarderIValueListenerNewValue_fn(With* __this, uObject* value)
{
    __this->SetSubtreeData(value);
}

// public generated With New() :28
void With__New2_fn(With** __retval)
{
    *__retval = With::New2();
}

// protected override sealed void OnRooted() :30
void With__OnRooted_fn(With* __this)
{
    ::g::Fuse::Triggers::Trigger__OnRooted_fn(__this);
    __this->Activate(NULL);
}

// private void SetSubtreeData(object value) :87
void With__SetSubtreeData_fn(With* __this, uObject* value)
{
    __this->SetSubtreeData(value);
}

// public generated With() [instance] :28
void With::ctor_5()
{
    ctor_4();
}

// public object get_Data() [instance] :46
uObject* With::Data()
{
    return _sourceData;
}

// public void set_Data(object value) [instance] :47
void With::Data(uObject* value)
{
    uStackFrame __("Fuse.Reactive.With", "set_Data(object)");

    if (_sourceData != value)
    {
        if (_sub != NULL)
            ::g::Uno::IDisposable::Dispose(uInterface(uPtr(_sub), ::TYPES[3/*Uno.IDisposable*/]));

        _sourceData = value;
        uObject* obs = uAs<uObject*>(value, ::TYPES[46/*Fuse.Reactive.IObservable*/]);

        if (obs != NULL)
        {
            SetSubtreeData(NULL);
            _sub = (uObject*)::g::Fuse::Reactive::ValueForwarder::New1(obs, (uObject*)this);
        }
        else
            SetSubtreeData(value);
    }
}

// private void SetSubtreeData(object value) [instance] :87
void With::SetSubtreeData(uObject* value)
{
    uStackFrame __("Fuse.Reactive.With", "SetSubtreeData(object)");
    uObject* oldData = _subtreeData;
    _subtreeData = value;
    BroadcastDataChange(oldData, value);
}

// public generated With New() [static] :28
With* With::New2()
{
    With* obj1 = (With*)uNew(With_typeof());
    obj1->ctor_5();
    return obj1;
}
// }

}}} // ::g::Fuse::Reactive
